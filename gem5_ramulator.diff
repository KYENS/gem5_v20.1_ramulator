diff --git a/BO.log b/BO.log
deleted file mode 100644
index adcaacf0e..000000000
--- a/BO.log
+++ /dev/null
@@ -1,11 +0,0 @@
-src/base/types.hh:#include "enums/ByteOrder.hh"
-uild/X86/python/_m5/param_SimpleUart.cc:#include "enums/ByteOrder.hh"
-build/X86/python/_m5/param_System.cc:#include "enums/ByteOrder.hh"
-build/X86/python/_m5/param_VirtIODeviceBase.cc:#include "enums/ByteOrder.hh"
-build/X86/params/System.hh:#include "enums/ByteOrder.hh"
-build/X86/params/System.hh:#include "enums/ByteOrder.hh"
-build/X86/params/VirtIODeviceBase.hh:#include "enums/ByteOrder.hh"
-build/X86/params/VirtIODeviceBase.hh:#include "enums/ByteOrder.hh"
-build/X86/params/SimpleUart.hh:#include "enums/ByteOrder.hh"
-build/X86/params/SimpleUart.hh:#include "enums/ByteOrder.hh"
-build/X86/enums/ByteOrder.cc:#include "enums/ByteOrder.hh"
diff --git a/configs/common/MemConfig.py b/configs/common/MemConfig.py
index 522cfe064..8221f85f0 100644
--- a/configs/common/MemConfig.py
+++ b/configs/common/MemConfig.py
@@ -41,8 +41,7 @@ from common import ObjectList
 from common import HMC
 
 def create_mem_intf(intf, r, i, nbr_mem_ctrls, intlv_bits, intlv_size,
-                    xor_low_bit, options):
-
+                    xor_low_bit):
     """
     Helper function for creating a single memoy controller from the given
     options.  This function is invoked multiple times in config_mem function
@@ -67,16 +66,7 @@ def create_mem_intf(intf, r, i, nbr_mem_ctrls, intlv_bits, intlv_size,
     interface = intf()
 
     # Only do this for DRAMs
-     # gagan : ramulator integration
-    if issubclass(intf, m5.objects.Ramulator):
-        if not options.ramulator_config:
-            fatal("--mem-type=ramulator require --ramulator-config option")
-#        interface.real_warm_up = options.real_warm_up
-        interface.config_file = options.ramulator_config
-        interface.output_dir = m5.options.outdir + "/"
-        print("Ramulator system configuration file = ", options.ramulator_config)
-        interface.num_cpus = options.num_cpus
-    elif issubclass(intf, m5.objects.DRAMInterface):
+    if issubclass(intf, m5.objects.DRAMInterface):
         # If the channel bits are appearing after the column
         # bits, we need to add the appropriate number of bits
         # for the row buffer size
@@ -213,8 +203,7 @@ def config_mem(options, system):
             if opt_mem_type and (not opt_nvm_type or range_iter % 2 != 0):
                 # Create the DRAM interface
                 dram_intf = create_mem_intf(intf, r, i, nbr_mem_ctrls,
-                                    intlv_bits, intlv_size, opt_xor_low_bit, options)
-
+                                    intlv_bits, intlv_size, opt_xor_low_bit)
 
                 # Set the number of ranks based on the command-line
                 # options if it was explicitly set
@@ -232,11 +221,7 @@ def config_mem(options, system):
                         "latency to 1ns.")
 
                 # Create the controller that will drive the interface
-                if opt_mem_type == "Ramulator":
-                    print("MEMORY TYPE::",opt_mem_type)
-                    print(type(dram_intf))
-                    mem_ctrl = dram_intf
-                elif opt_mem_type == "HMC_2500_1x32":
+                if opt_mem_type == "HMC_2500_1x32":
                     # The static latency of the vault controllers is estimated
                     # to be smaller than a full DRAM channel controller
                     mem_ctrl = m5.objects.MemCtrl(min_writes_per_switch = 8,
@@ -249,10 +234,7 @@ def config_mem(options, system):
 
                 # Hookup the controller to the interface and add to the list
                 if opt_mem_type != "SimpleMemory":
-                    if opt_mem_type != "Ramulator":
-                       mem_ctrl.dram = dram_intf
-
-
+                    mem_ctrl.dram = dram_intf
 
                 mem_ctrls.append(mem_ctrl)
 
diff --git a/configs/common/Options.py b/configs/common/Options.py
index 547297e8c..32f8dd94b 100644
--- a/configs/common/Options.py
+++ b/configs/common/Options.py
@@ -112,8 +112,6 @@ def addNoISAOptions(parser):
                        help="Enable low-power states in DRAMInterface")
     parser.add_option("--mem-channels-intlv", type="int", default=0,
                       help="Memory channels interleave")
-    parser.add_option("--ramulator-config", type="string", dest="ramulator_config",
-                      help="Specify Ramulator configuration file, overrides other --mem-XXX options")
 
 
     parser.add_option("--memchecker", action="store_true")
diff --git a/ext/ramulator/README b/ext/ramulator/README
deleted file mode 100644
index e1850e929..000000000
--- a/ext/ramulator/README
+++ /dev/null
@@ -1,11 +0,0 @@
-To use Ramulator in gem5 simulations
-
-1. Download Ramulator
-    1.1 Go to ext/ramulator (this directory)
-    1.2 Clone Ramulator: git clone git://github.com/CMU-SAFARI/ramulator.git
-
-2. Compile gem5
-
-3. Run gem5 with Ramulator
-    3.1 Use --mem-type=ramulator and --ramulator-config=XXX
-
diff --git a/ext/ramulator/Ramulator/src/ALDRAM.cpp b/ext/ramulator/Ramulator/src/ALDRAM.cpp
deleted file mode 100644
index 453300baa..000000000
--- a/ext/ramulator/Ramulator/src/ALDRAM.cpp
+++ /dev/null
@@ -1,362 +0,0 @@
-#include <iostream>
-
-#include "ALDRAM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string ALDRAM::standard_name = "ALDRAM";
-string ALDRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum ALDRAM::Org> ALDRAM::org_map = {
-    {"ALDRAM_512Mb_x4", ALDRAM::Org::ALDRAM_512Mb_x4}, {"ALDRAM_512Mb_x8", ALDRAM::Org::ALDRAM_512Mb_x8}, {"ALDRAM_512Mb_x16", ALDRAM::Org::ALDRAM_512Mb_x16},
-    {"ALDRAM_1Gb_x4", ALDRAM::Org::ALDRAM_1Gb_x4}, {"ALDRAM_1Gb_x8", ALDRAM::Org::ALDRAM_1Gb_x8}, {"ALDRAM_1Gb_x16", ALDRAM::Org::ALDRAM_1Gb_x16},
-    {"ALDRAM_2Gb_x4", ALDRAM::Org::ALDRAM_2Gb_x4}, {"ALDRAM_2Gb_x8", ALDRAM::Org::ALDRAM_2Gb_x8}, {"ALDRAM_2Gb_x16", ALDRAM::Org::ALDRAM_2Gb_x16},
-    {"ALDRAM_4Gb_x4", ALDRAM::Org::ALDRAM_4Gb_x4}, {"ALDRAM_4Gb_x8", ALDRAM::Org::ALDRAM_4Gb_x8}, {"ALDRAM_4Gb_x16", ALDRAM::Org::ALDRAM_4Gb_x16},
-    {"ALDRAM_8Gb_x4", ALDRAM::Org::ALDRAM_8Gb_x4}, {"ALDRAM_8Gb_x8", ALDRAM::Org::ALDRAM_8Gb_x8}, {"ALDRAM_8Gb_x16", ALDRAM::Org::ALDRAM_8Gb_x16},
-};
-
-map<string, enum ALDRAM::Speed> ALDRAM::speed_map = {
-    {"ALDRAM_800D", ALDRAM::Speed::ALDRAM_800D}, {"ALDRAM_800E", ALDRAM::Speed::ALDRAM_800E},
-    {"ALDRAM_1066E", ALDRAM::Speed::ALDRAM_1066E}, {"ALDRAM_1066F", ALDRAM::Speed::ALDRAM_1066F}, {"ALDRAM_1066G", ALDRAM::Speed::ALDRAM_1066G},
-    {"ALDRAM_1333G", ALDRAM::Speed::ALDRAM_1333G}, {"ALDRAM_1333H", ALDRAM::Speed::ALDRAM_1333H},
-    {"ALDRAM_1600H", ALDRAM::Speed::ALDRAM_1600H}, {"ALDRAM_1600J", ALDRAM::Speed::ALDRAM_1600J}, {"ALDRAM_1600K", ALDRAM::Speed::ALDRAM_1600K},
-    {"ALDRAM_1866K", ALDRAM::Speed::ALDRAM_1866K}, {"ALDRAM_1866L", ALDRAM::Speed::ALDRAM_1866L},
-    {"ALDRAM_2133L", ALDRAM::Speed::ALDRAM_2133L}, {"ALDRAM_2133M", ALDRAM::Speed::ALDRAM_2133M},
-};
-
-
-ALDRAM::ALDRAM(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(Temp::COLD)][int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    current_speed = speed;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_lambda();
-    init_timing(speed_table[int(Temp::HOT)][int(speed)]);
-    temperature = Temp::COLD;
-}
-
-ALDRAM::ALDRAM(const string& org_str, const string& speed_str) :
-    ALDRAM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void ALDRAM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void ALDRAM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void ALDRAM::aldram_timing(Temp current_temperature)
-{
-    for (int i = 0; i < int(Level::MAX); i++) {
-        for (int j = 0; j < int(Command::MAX); j++) {
-            timing[i][j].clear();
-        }
-    }
-    temperature = current_temperature;
-    read_latency = speed_entry.nCL + speed_entry.nBL;
-    init_timing(speed_table[int(temperature)][int(current_speed)]);
-
-    //std::cout << "vector size: " << timing[int(Temp::HOT)][int(current_speed)].size() << endl;
-    //std::cout << "after cold nRCD : ";
-    //std::cout << int(timing[int(Level::Bank)][int(Command::ACT)][0].val) << endl << endl;
-}
-
-void ALDRAM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void ALDRAM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void ALDRAM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-
-void ALDRAM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<ALDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<ALDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<ALDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<ALDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<ALDRAM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void ALDRAM::init_timing(SpeedEntry speed_entry)
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/ALDRAM.h b/ext/ramulator/Ramulator/src/ALDRAM.h
deleted file mode 100644
index dad6228ac..000000000
--- a/ext/ramulator/Ramulator/src/ALDRAM.h
+++ /dev/null
@@ -1,249 +0,0 @@
-#ifndef __ALDRAM_H
-#define __ALDRAM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class ALDRAM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    enum class Temp;
-
-    ALDRAM(Org org, Speed speed);
-    ALDRAM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<ALDRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<ALDRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<ALDRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<ALDRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        ALDRAM_512Mb_x4, ALDRAM_512Mb_x8, ALDRAM_512Mb_x16,
-        ALDRAM_1Gb_x4,   ALDRAM_1Gb_x8,   ALDRAM_1Gb_x16,
-        ALDRAM_2Gb_x4,   ALDRAM_2Gb_x8,   ALDRAM_2Gb_x16,
-        ALDRAM_4Gb_x4,   ALDRAM_4Gb_x8,   ALDRAM_4Gb_x16,
-        ALDRAM_8Gb_x4,   ALDRAM_8Gb_x8,   ALDRAM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        ALDRAM_800D,  ALDRAM_800E,
-        ALDRAM_1066E, ALDRAM_1066F, ALDRAM_1066G,
-        ALDRAM_1333G, ALDRAM_1333H,
-        ALDRAM_1600H, ALDRAM_1600J, ALDRAM_1600K,
-        ALDRAM_1866K, ALDRAM_1866L,
-        ALDRAM_2133L, ALDRAM_2133M,
-        MAX
-    };
-
-    Speed current_speed;
-
-    enum class Temp : int
-    {
-        COLD, HOT, MAX
-    };
-
-    Temp temperature = Temp::HOT;  // DHL
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Temp::MAX)][int(Speed::MAX)] = {
-        {
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5-1,  5-1,  5, 15-5, 20-6, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6-1,  6-1,  5, 15-5, 21-6, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6-1,  6-1,  6, 20-5, 26-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7-1,  7-1,  6, 20-5, 27-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8-1,  8-1,  6, 20-5, 28-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8-1,  8-1,  7, 24-5, 32-6, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9-1,  9-1,  7, 24-5, 33-6, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9-2,  9-2,  8, 28-10, 37-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10-2, 10-2,  8, 28-10, 38-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11-2, 11-2,  8, 28-10, 39-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11-2, 11-2,  9, 32-10, 43-12, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12-2, 12-3,  9, 32-10, 44-13, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12-2, 12-3, 10, 36-10, 48-13, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13-2, 13-3, 10, 36-10, 49-13, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-        },
-        {
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-        }
-    }, speed_entry;
-
-    int read_latency;
-    void aldram_timing(Temp current_temperature);
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing(SpeedEntry speed_entry);
-};
-
-} /*namespace ramulator*/
-
-#endif /*__ALDRAM_H*/
diff --git a/ext/ramulator/Ramulator/src/Cache.cpp b/ext/ramulator/Ramulator/src/Cache.cpp
deleted file mode 100644
index 6a383ed41..000000000
--- a/ext/ramulator/Ramulator/src/Cache.cpp
+++ /dev/null
@@ -1,432 +0,0 @@
-#include "Cache.h"
-
-#ifndef DEBUG_CACHE
-#define debug(...)
-#else
-#define debug(...) do { \
-          printf("\033[36m[DEBUG] %s ", __FUNCTION__); \
-          printf(__VA_ARGS__); \
-          printf("\033[0m\n"); \
-      } while (0)
-#endif
-
-namespace ramulator
-{
-
-Cache::Cache(int size, int assoc, int block_size,
-    int mshr_entry_num, Level level,
-    std::shared_ptr<CacheSystem> cachesys):
-    level(level), cachesys(cachesys), higher_cache(0),
-    lower_cache(nullptr), size(size), assoc(assoc),
-    block_size(block_size), mshr_entry_num(mshr_entry_num) {
-
-  debug("level %d size %d assoc %d block_size %d\n",
-      int(level), size, assoc, block_size);
-
-  if (level == Level::L1) {
-    level_string = "L1";
-  } else if (level == Level::L2) {
-    level_string = "L2";
-  } else if (level == Level::L3) {
-    level_string = "L3";
-  }
-
-  is_first_level = (level == cachesys->first_level);
-  is_last_level = (level == cachesys->last_level);
-
-  // Check size, block size and assoc are 2^N
-  assert((size & (size - 1)) == 0);
-  assert((block_size & (block_size - 1)) == 0);
-  assert((assoc & (assoc - 1)) == 0);
-  assert(size >= block_size);
-
-  // Initialize cache configuration
-  block_num = size / (block_size * assoc);
-  index_mask = block_num - 1;
-  index_offset = calc_log2(block_size);
-  tag_offset = calc_log2(block_num) + index_offset;
-
-  debug("index_offset %d", index_offset);
-  debug("index_mask 0x%x", index_mask);
-  debug("tag_offset %d", tag_offset);
-
-  // regStats
-  cache_read_miss.name(level_string + string("_cache_read_miss"))
-                 .desc("cache read miss count")
-                 .precision(0)
-                 ;
-
-  cache_write_miss.name(level_string + string("_cache_write_miss"))
-                  .desc("cache write miss count")
-                  .precision(0)
-                  ;
-
-  cache_total_miss.name(level_string + string("_cache_total_miss"))
-                  .desc("cache total miss count")
-                  .precision(0)
-                  ;
-
-  cache_eviction.name(level_string + string("_cache_eviction"))
-                .desc("number of evict from this level to lower level")
-                .precision(0)
-                ;
-
-  cache_read_access.name(level_string + string("_cache_read_access"))
-                  .desc("cache read access count")
-                  .precision(0)
-                  ;
-
-  cache_write_access.name(level_string + string("_cache_write_access"))
-                    .desc("cache write access count")
-                    .precision(0)
-                    ;
-
-  cache_total_access.name(level_string + string("_cache_total_access"))
-                    .desc("cache total access count")
-                    .precision(0)
-                    ;
-
-  cache_mshr_hit.name(level_string + string("_cache_mshr_hit"))
-                .desc("cache mshr hit count")
-                .precision(0)
-                ;
-  cache_mshr_unavailable.name(level_string + string("_cache_mshr_unavailable"))
-                         .desc("cache mshr not available count")
-                         .precision(0)
-                         ;
-  cache_set_unavailable.name(level_string + string("_cache_set_unavailable"))
-                         .desc("cache set not available")
-                         .precision(0)
-                         ;
-}
-
-bool Cache::send(Request req) {
-  debug("level %d req.addr %lx req.type %d, index %d, tag %ld",
-      int(level), req.addr, int(req.type), get_index(req.addr),
-      get_tag(req.addr));
-
-  cache_total_access++;
-  if (req.type == Request::Type::WRITE) {
-    cache_write_access++;
-  } else {
-    assert(req.type == Request::Type::READ);
-    cache_read_access++;
-  }
-  // If there isn't a set, create it.
-  auto& lines = get_lines(req.addr);
-  std::list<Line>::iterator line;
-
-  if (is_hit(lines, req.addr, &line)) {
-    lines.push_back(Line(req.addr, get_tag(req.addr), false,
-        line->dirty || (req.type == Request::Type::WRITE)));
-    lines.erase(line);
-    cachesys->hit_list.push_back(
-        make_pair(cachesys->clk + latency[int(level)], req));
-
-    debug("hit, update timestamp %ld", cachesys->clk);
-    debug("hit finish time %ld",
-        cachesys->clk + latency[int(level)]);
-
-    return true;
-
-  } else {
-    debug("miss @level %d", int(level));
-    cache_total_miss++;
-    if (req.type == Request::Type::WRITE) {
-      cache_write_miss++;
-    } else {
-      assert(req.type == Request::Type::READ);
-      cache_read_miss++;
-    }
-
-    // The dirty bit will be set if this is a write request and @L1
-    bool dirty = (req.type == Request::Type::WRITE);
-
-    // Modify the type of the request to lower level
-    if (req.type == Request::Type::WRITE) {
-      req.type = Request::Type::READ;
-    }
-
-    // Look it up in MSHR entries
-    assert(req.type == Request::Type::READ);
-    auto mshr = hit_mshr(req.addr);
-    if (mshr != mshr_entries.end()) {
-      debug("hit mshr");
-      cache_mshr_hit++;
-      mshr->second->dirty = dirty || mshr->second->dirty;
-      return true;
-    }
-
-    // All requests come to this stage will be READ, so they
-    // should be recorded in MSHR entries.
-    if (mshr_entries.size() == mshr_entry_num) {
-      // When no MSHR entries available, the miss request
-      // is stalling.
-      cache_mshr_unavailable++;
-      debug("no mshr entry available");
-      return false;
-    }
-
-    // Check whether there is a line available
-    if (all_sets_locked(lines)) {
-      cache_set_unavailable++;
-      return false;
-    }
-
-    auto newline = allocate_line(lines, req.addr);
-    if (newline == lines.end()) {
-      return false;
-    }
-
-    newline->dirty = dirty;
-
-    // Add to MSHR entries
-    mshr_entries.push_back(make_pair(req.addr, newline));
-
-    // Send the request to next level;
-    if (!is_last_level) {
-      if(!lower_cache->send(req)) {
-        retry_list.push_back(req);
-      }
-    } else {
-      cachesys->wait_list.push_back(
-          make_pair(cachesys->clk + latency[int(level)], req));
-    }
-    return true;
-  }
-}
-
-void Cache::evictline(long addr, bool dirty) {
-
-  auto it = cache_lines.find(get_index(addr));
-  assert(it != cache_lines.end()); // check inclusive cache
-  auto& lines = it->second;
-  auto line = find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){return (l.tag == get_tag(addr));});
-
-  assert(line != lines.end());
-  // Update LRU queue. The dirty bit will be set if the dirty
-  // bit inherited from higher level(s) is set.
-  lines.push_back(Line(addr, get_tag(addr), false,
-      dirty || line->dirty));
-  lines.erase(line);
-}
-
-std::pair<long, bool> Cache::invalidate(long addr) {
-  long delay = latency_each[int(level)];
-  bool dirty = false;
-
-  auto& lines = get_lines(addr);
-  if (lines.size() == 0) {
-    // The line of this address doesn't exist.
-    return make_pair(0, false);
-  }
-  auto line = find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){return (l.tag == get_tag(addr));});
-
-  // If the line is in this level cache, then erase it from
-  // the buffer.
-  if (line != lines.end()) {
-    assert(!line->lock);
-    debug("invalidate %lx @ level %d", addr, int(level));
-    lines.erase(line);
-  } else {
-    // If it's not in current level, then no need to go up.
-    return make_pair(delay, false);
-  }
-
-  if (higher_cache.size()) {
-    long max_delay = delay;
-    for (auto hc : higher_cache) {
-      auto result = hc->invalidate(addr);
-      if (result.second) {
-        max_delay = max(max_delay, delay + result.first * 2);
-      } else {
-        max_delay = max(max_delay, delay + result.first);
-      }
-      dirty = dirty || line->dirty || result.second;
-    }
-    delay = max_delay;
-  } else {
-    dirty = line->dirty;
-  }
-  return make_pair(delay, dirty);
-}
-
-
-void Cache::evict(std::list<Line>* lines,
-    std::list<Line>::iterator victim) {
-  debug("level %d miss evict victim %lx", int(level), victim->addr);
-  cache_eviction++;
-
-  long addr = victim->addr;
-  long invalidate_time = 0;
-  bool dirty = victim->dirty;
-
-  // First invalidate the victim line in higher level.
-  if (higher_cache.size()) {
-    for (auto hc : higher_cache) {
-      auto result = hc->invalidate(addr);
-      invalidate_time = max(invalidate_time,
-          result.first + (result.second ? latency_each[int(level)] : 0));
-      dirty = dirty || result.second || victim->dirty;
-    }
-  }
-
-  debug("invalidate delay: %ld, dirty: %s", invalidate_time,
-      dirty ? "true" : "false");
-
-  if (!is_last_level) {
-    // not LLC eviction
-    assert(lower_cache != nullptr);
-    lower_cache->evictline(addr, dirty);
-  } else {
-    // LLC eviction
-    if (dirty) {
-      Request write_req(addr, Request::Type::WRITE);
-      cachesys->wait_list.push_back(make_pair(
-          cachesys->clk + invalidate_time + latency[int(level)],
-          write_req));
-
-      debug("inject one write request to memory system "
-          "addr %lx, invalidate time %ld, issue time %ld",
-          write_req.addr, invalidate_time,
-          cachesys->clk + invalidate_time + latency[int(level)]);
-    }
-  }
-
-  lines->erase(victim);
-}
-
-std::list<Cache::Line>::iterator Cache::allocate_line(
-    std::list<Line>& lines, long addr) {
-  // See if an eviction is needed
-  if (need_eviction(lines, addr)) {
-    // Get victim.
-    // The first one might still be locked due to reorder in MC
-    auto victim = find_if(lines.begin(), lines.end(),
-        [this](Line line) {
-          bool check = !line.lock;
-          if (!is_first_level) {
-            for (auto hc : higher_cache) {
-              if(!check) {
-                return check;
-              }
-              check = check && hc->check_unlock(line.addr);
-            }
-          }
-          return check;
-        });
-    if (victim == lines.end()) {
-      return victim;  // doesn't exist a line that's already unlocked in each level
-    }
-    assert(victim != lines.end());
-    evict(&lines, victim);
-  }
-
-  // Allocate newline, with lock bit on and dirty bit off
-  lines.push_back(Line(addr, get_tag(addr)));
-  auto last_element = lines.end();
-  --last_element;
-  return last_element;
-}
-
-bool Cache::is_hit(std::list<Line>& lines, long addr,
-    std::list<Line>::iterator* pos_ptr) {
-  auto pos = find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){return (l.tag == get_tag(addr));});
-  *pos_ptr = pos;
-  if (pos == lines.end()) {
-    return false;
-  }
-  return !pos->lock;
-}
-
-void Cache::concatlower(Cache* lower) {
-  lower_cache = lower;
-  assert(lower != nullptr);
-  lower->higher_cache.push_back(this);
-};
-
-bool Cache::need_eviction(const std::list<Line>& lines, long addr) {
-  if (find_if(lines.begin(), lines.end(),
-      [addr, this](Line l){
-        return (get_tag(addr) == l.tag);})
-      != lines.end()) {
-    // Due to MSHR, the program can't reach here. Just for checking
-    assert(false);
-  } else {
-    if (lines.size() < assoc) {
-      return false;
-    } else {
-      return true;
-    }
-  }
-}
-
-void Cache::callback(Request& req) {
-  debug("level %d", int(level));
-
-  auto it = find_if(mshr_entries.begin(), mshr_entries.end(),
-      [&req, this](std::pair<long, std::list<Line>::iterator> mshr_entry) {
-        return (align(mshr_entry.first) == align(req.addr));
-      });
-
-  if (it != mshr_entries.end()) {
-    it->second->lock = false;
-    mshr_entries.erase(it);
-  }
-
-  if (higher_cache.size()) {
-    for (auto hc : higher_cache) {
-      hc->callback(req);
-    }
-  }
-}
-
-void Cache::tick() {
-
-    if(!lower_cache->is_last_level)
-        lower_cache->tick();
-
-    for (auto it = retry_list.begin(); it != retry_list.end(); it++) {
-        if(lower_cache->send(*it))
-            it = retry_list.erase(it);
-    }
-
-}
-
-void CacheSystem::tick() {
-  debug("clk %ld", clk);
-
-  ++clk;
-
-  // Sends ready waiting request to memory
-  auto it = wait_list.begin();
-  while (it != wait_list.end() && clk >= it->first) {
-    if (!send_memory(it->second)) {
-      ++it;
-    } else {
-
-      debug("complete req: addr %lx", (it->second).addr);
-
-      it = wait_list.erase(it);
-    }
-  }
-
-  // hit request callback
-  it = hit_list.begin();
-  while (it != hit_list.end()) {
-    if (clk >= it->first) {
-      it->second.callback(it->second);
-
-      debug("finish hit: addr %lx", (it->second).addr);
-
-      it = hit_list.erase(it);
-    } else {
-      ++it;
-    }
-  }
-}
-
-} // namespace ramulator
diff --git a/ext/ramulator/Ramulator/src/Cache.h b/ext/ramulator/Ramulator/src/Cache.h
deleted file mode 100644
index b9869c7e4..000000000
--- a/ext/ramulator/Ramulator/src/Cache.h
+++ /dev/null
@@ -1,242 +0,0 @@
-#ifndef __CACHE_H
-#define __CACHE_H
-
-#include "Config.h"
-#include "Request.h"
-#include "Statistics.h"
-#include <algorithm>
-#include <cstdio>
-#include <cassert>
-#include <functional>
-#include <list>
-#include <map>
-#include <memory>
-#include <queue>
-#include <list>
-
-namespace ramulator
-{
-class CacheSystem;
-
-class Cache {
-protected:
-  ScalarStat cache_read_miss;
-  ScalarStat cache_write_miss;
-  ScalarStat cache_total_miss;
-  ScalarStat cache_eviction;
-  ScalarStat cache_read_access;
-  ScalarStat cache_write_access;
-  ScalarStat cache_total_access;
-  ScalarStat cache_mshr_hit;
-  ScalarStat cache_mshr_unavailable;
-  ScalarStat cache_set_unavailable;
-public:
-  enum class Level {
-    L1,
-    L2,
-    L3,
-    MAX
-  } level;
-  std::string level_string;
-
-  struct Line {
-    long addr;
-    long tag;
-    bool lock; // When the lock is on, the value is not valid yet.
-    bool dirty;
-    Line(long addr, long tag):
-        addr(addr), tag(tag), lock(true), dirty(false) {}
-    Line(long addr, long tag, bool lock, bool dirty):
-        addr(addr), tag(tag), lock(lock), dirty(dirty) {}
-  };
-
-  Cache(int size, int assoc, int block_size, int mshr_entry_num,
-      Level level, std::shared_ptr<CacheSystem> cachesys);
-
-  void tick();
-
-  // L1, L2, L3 accumulated latencies
-  int latency[int(Level::MAX)] = {4, 4 + 12, 4 + 12 + 31};
-  int latency_each[int(Level::MAX)] = {4, 12, 31};
-
-  std::shared_ptr<CacheSystem> cachesys;
-  // LLC has multiple higher caches
-  std::vector<Cache*> higher_cache;
-  Cache* lower_cache;
-
-  bool send(Request req);
-
-  void concatlower(Cache* lower);
-
-  void callback(Request& req);
-
-protected:
-
-  bool is_first_level;
-  bool is_last_level;
-  size_t size;
-  unsigned int assoc;
-  unsigned int block_num;
-  unsigned int index_mask;
-  unsigned int block_size;
-  unsigned int index_offset;
-  unsigned int tag_offset;
-  unsigned int mshr_entry_num;
-  std::vector<std::pair<long, std::list<Line>::iterator>> mshr_entries;
-  std::list<Request> retry_list;
-
-  std::map<int, std::list<Line> > cache_lines;
-
-  int calc_log2(int val) {
-      int n = 0;
-      while ((val >>= 1))
-          n ++;
-      return n;
-  }
-
-  int get_index(long addr) {
-    return (addr >> index_offset) & index_mask;
-  };
-
-  long get_tag(long addr) {
-    return (addr >> tag_offset);
-  }
-
-  // Align the address to cache line size
-  long align(long addr) {
-    return (addr & ~(block_size-1l));
-  }
-
-  // Evict the cache line from higher level to this level.
-  // Pass the dirty bit and update LRU queue.
-  void evictline(long addr, bool dirty);
-
-  // Invalidate the line from this level to higher levels
-  // The return value is a pair. The first element is invalidation
-  // latency, and the second is wether the value has new version
-  // in higher level and this level.
-  std::pair<long, bool> invalidate(long addr);
-
-  // Evict the victim from current set of lines.
-  // First do invalidation, then call evictline(L1 or L2) or send
-  // a write request to memory(L3) when dirty bit is on.
-  void evict(std::list<Line>* lines,
-      std::list<Line>::iterator victim);
-
-  // First test whether need eviction, if so, do eviction by
-  // calling evict function. Then allocate a new line and return
-  // the iterator points to it.
-  std::list<Line>::iterator allocate_line(
-      std::list<Line>& lines, long addr);
-
-  // Check whether the set to hold addr has space or eviction is
-  // needed.
-  bool need_eviction(const std::list<Line>& lines, long addr);
-
-  // Check whether this addr is hit and fill in the pos_ptr with
-  // the iterator to the hit line or lines.end()
-  bool is_hit(std::list<Line>& lines, long addr,
-              std::list<Line>::iterator* pos_ptr);
-
-  bool all_sets_locked(const std::list<Line>& lines) {
-    if (lines.size() < assoc) {
-      return false;
-    }
-    for (const auto& line : lines) {
-      if (!line.lock) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  bool check_unlock(long addr) {
-    auto it = cache_lines.find(get_index(addr));
-    if (it == cache_lines.end()) {
-      return true;
-    } else {
-      auto& lines = it->second;
-      auto line = find_if(lines.begin(), lines.end(),
-          [addr, this](Line l){return (l.tag == get_tag(addr));});
-      if (line == lines.end()) {
-        return true;
-      } else {
-        bool check = !line->lock;
-        if (!is_first_level) {
-          for (auto hc : higher_cache) {
-            if (!check) {
-              return check;
-            }
-            check = check && hc->check_unlock(line->addr);
-          }
-        }
-        return check;
-      }
-    }
-  }
-
-  std::vector<std::pair<long, std::list<Line>::iterator>>::iterator
-  hit_mshr(long addr) {
-    auto mshr_it =
-        find_if(mshr_entries.begin(), mshr_entries.end(),
-            [addr, this](std::pair<long, std::list<Line>::iterator>
-                   mshr_entry) {
-              return (align(mshr_entry.first) == align(addr));
-            });
-    return mshr_it;
-  }
-
-  std::list<Line>& get_lines(long addr) {
-    if (cache_lines.find(get_index(addr))
-        == cache_lines.end()) {
-      cache_lines.insert(make_pair(get_index(addr),
-          std::list<Line>()));
-    }
-    return cache_lines[get_index(addr)];
-  }
-
-};
-
-class CacheSystem {
-public:
-  CacheSystem(const Config& configs, std::function<bool(Request)> send_memory):
-    send_memory(send_memory) {
-      if (configs.has_core_caches()) {
-        first_level = Cache::Level::L1;
-      } else if (configs.has_l3_cache()) {
-        first_level = Cache::Level::L3;
-      } else {
-        last_level = Cache::Level::MAX; // no cache
-      }
-
-      if (configs.has_l3_cache()) {
-        last_level = Cache::Level::L3;
-      } else if (configs.has_core_caches()) {
-        last_level = Cache::Level::L2;
-      } else {
-        last_level = Cache::Level::MAX; // no cache
-      }
-    }
-
-  // wait_list contains miss requests with their latencies in
-  // cache. When this latency is met, the send_memory function
-  // will be called to send the request to the memory system.
-  std::list<std::pair<long, Request> > wait_list;
-
-  // hit_list contains hit requests with their latencies in cache.
-  // callback function will be called when this latency is met and
-  // set the instruction status to ready in processor's window.
-  std::list<std::pair<long, Request> > hit_list;
-
-  std::function<bool(Request)> send_memory;
-
-  long clk = 0;
-  void tick();
-
-  Cache::Level first_level;
-  Cache::Level last_level;
-};
-
-} // namespace ramulator
-
-#endif /* __CACHE_H */
diff --git a/ext/ramulator/Ramulator/src/Config.cpp b/ext/ramulator/Ramulator/src/Config.cpp
deleted file mode 100644
index b3a4658bb..000000000
--- a/ext/ramulator/Ramulator/src/Config.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-#include "Config.h"
-
-using namespace std;
-using namespace ramulator;
-
-Config::Config(const std::string& fname) {
-  parse(fname);
-}
-
-void Config::parse(const string& fname)
-{
-    ifstream file(fname);
-    assert(file.good() && "Bad config file");
-    string line;
-
-    while (getline(file, line)) {
-        char delim[] = " \t=";
-        vector<string> tokens;
-
-        while (true) {
-            size_t start = line.find_first_not_of(delim);
-            if (start == string::npos) 
-                break;
-
-            size_t end = line.find_first_of(delim, start);
-            if (end == string::npos) {
-                tokens.push_back(line.substr(start));
-                break;
-            }
-
-            tokens.push_back(line.substr(start, end - start));
-            line = line.substr(end);
-        }
-
-        // empty line
-        if (!tokens.size())
-            continue;
-
-        // comment line
-        if (tokens[0][0] == '#')
-            continue;
-
-        // parameter line
-        assert(tokens.size() == 2 && "Only allow two tokens in one line");
-
-        options[tokens[0]] = tokens[1];
-
-        if (tokens[0] == "channels") {
-          channels = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "ranks") {
-          ranks = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "subarrays") {
-          subarrays = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "cpu_tick") {
-          cpu_tick = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "mem_tick") {
-          mem_tick = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "expected_limit_insts") {
-          expected_limit_insts = atoi(tokens[1].c_str());
-        } else if (tokens[0] == "warmup_insts") {
-          warmup_insts = atoi(tokens[1].c_str());
-        }
-    }
-    file.close();
-}
-
-
diff --git a/ext/ramulator/Ramulator/src/Config.h b/ext/ramulator/Ramulator/src/Config.h
deleted file mode 100644
index aef68dc70..000000000
--- a/ext/ramulator/Ramulator/src/Config.h
+++ /dev/null
@@ -1,126 +0,0 @@
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <string>
-#include <fstream>
-#include <vector>
-#include <map>
-#include <iostream>
-#include <cassert>
-
-namespace ramulator
-{
-
-class Config {
-
-private:
-    std::map<std::string, std::string> options;
-    int channels;
-    int ranks;
-    int subarrays;
-    int cpu_tick;
-    int mem_tick;
-    int core_num = 0;
-    long expected_limit_insts = 0;
-    long warmup_insts = 0;
-    std::string tracefile_directory;
-
-public:
-    Config() {}
-    Config(const std::string& fname);
-    void parse(const std::string& fname);
-    std::string operator [] (const std::string& name) const {
-      if (options.find(name) != options.end()) {
-        return (options.find(name))->second;
-      } else {
-        return "";
-      }
-    }
-
-    bool contains(const std::string& name) const {
-      if (options.find(name) != options.end()) {
-        return true;
-      } else {
-        return false;
-      }
-    }
-
-    void add (const std::string& name, const std::string& value) {
-      if (!contains(name)) {
-        options.insert(make_pair(name, value));
-      } else {
-        printf("ramulator::Config::add options[%s] already set.\n", name.c_str());
-      }
-    }
-
-    std::string get_tracefile_directory() const { return tracefile_directory; }
-    void set_tracefile_directory(std::string directory) { tracefile_directory = directory; }
-    
-
-    void set_core_num(int _core_num) {core_num = _core_num;}
-
-    int get_channels() const {return channels;}
-    int get_subarrays() const {return subarrays;}
-    int get_ranks() const {return ranks;}
-    int get_cpu_tick() const {return cpu_tick;}
-    int get_mem_tick() const {return mem_tick;}
-    int get_core_num() const {return core_num;}
-    long get_expected_limit_insts() const {return expected_limit_insts;}
-    long get_warmup_insts() const {return warmup_insts;}
-
-    bool has_l3_cache() const {
-      if (options.find("cache") != options.end()) {
-        const std::string& cache_option = (options.find("cache"))->second;
-        return (cache_option == "all") || (cache_option == "L3");
-      } else {
-        return false;
-      }
-    }
-    bool has_core_caches() const {
-      if (options.find("cache") != options.end()) {
-        const std::string& cache_option = (options.find("cache"))->second;
-        return (cache_option == "all" || cache_option == "L1L2");
-      } else {
-        return false;
-      }
-    }
-    bool is_early_exit() const {
-      // the default value is true
-      if (options.find("early_exit") != options.end()) {
-        if ((options.find("early_exit"))->second == "off") {
-          return false;
-        }
-        return true;
-      }
-      return true;
-    }
-    bool calc_weighted_speedup() const {
-      return (expected_limit_insts != 0);
-    }
-    bool record_cmd_trace() const {
-      // the default value is false
-      if (options.find("record_cmd_trace") != options.end()) {
-        if ((options.find("record_cmd_trace"))->second == "on") {
-          return true;
-        }
-        return false;
-      }
-      return false;
-    }
-    bool print_cmd_trace() const {
-      // the default value is false
-      if (options.find("print_cmd_trace") != options.end()) {
-        if ((options.find("print_cmd_trace"))->second == "on") {
-          return true;
-        }
-        return false;
-      }
-      return false;
-    }
-};
-
-
-} /* namespace ramulator */
-
-#endif /* _CONFIG_H */
-
diff --git a/ext/ramulator/Ramulator/src/Controller.cpp b/ext/ramulator/Ramulator/src/Controller.cpp
deleted file mode 100644
index af2e9db13..000000000
--- a/ext/ramulator/Ramulator/src/Controller.cpp
+++ /dev/null
@@ -1,204 +0,0 @@
-#include "Controller.h"
-#include "SALP.h"
-#include "ALDRAM.h"
-#include "TLDRAM.h"
-
-using namespace ramulator;
-
-namespace ramulator
-{
-
-static vector<int> get_offending_subarray(DRAM<SALP>* channel, vector<int> & addr_vec){
-    int sa_id = 0;
-    auto rank = channel->children[addr_vec[int(SALP::Level::Rank)]];
-    auto bank = rank->children[addr_vec[int(SALP::Level::Bank)]];
-    auto sa = bank->children[addr_vec[int(SALP::Level::SubArray)]];
-    for (auto sa_other : bank->children)
-        if (sa != sa_other && sa_other->state == SALP::State::Opened){
-            sa_id = sa_other->id;
-            break;
-        }
-    vector<int> offending = addr_vec;
-    offending[int(SALP::Level::SubArray)] = sa_id;
-    offending[int(SALP::Level::Row)] = -1;
-    return offending;
-}
-
-
-template <>
-vector<int> Controller<SALP>::get_addr_vec(SALP::Command cmd, list<Request>::iterator req){
-    if (cmd == SALP::Command::PRE_OTHER)
-        return get_offending_subarray(channel, req->addr_vec);
-    else
-        return req->addr_vec;
-}
-
-
-template <>
-bool Controller<SALP>::is_ready(list<Request>::iterator req){
-    SALP::Command cmd = get_first_cmd(req);
-    if (cmd == SALP::Command::PRE_OTHER){
-
-        vector<int> addr_vec = get_offending_subarray(channel, req->addr_vec);
-        return channel->check(cmd, addr_vec.data(), clk);
-    }
-    else return channel->check(cmd, req->addr_vec.data(), clk);
-}
-
-template <>
-void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature){
-    channel->spec->aldram_timing(current_temperature);
-}
-
-
-template <>
-void Controller<TLDRAM>::tick(){
-    clk++;
-    req_queue_length_sum += readq.size() + writeq.size();
-    read_req_queue_length_sum += readq.size();
-    write_req_queue_length_sum += writeq.size();
-
-    /*** 1. Serve completed reads ***/
-    if (pending.size()) {
-        Request& req = pending[0];
-        if (req.depart <= clk) {
-          if (req.depart - req.arrive > 1) {
-                  read_latency_sum += req.depart - req.arrive;
-		  // gagan : demand and prefetch reads
-		  if(req.is_prefetch)
-		    prefetch_read_latency_sum += req.depart - req.arrive;
-		  else
-		    demand_read_latency_sum += req.depart - req.arrive;
-                  channel->update_serving_requests(
-                      req.addr_vec.data(), -1, clk);
-          }
-            req.callback(req);
-            pending.pop_front();
-        }
-    }
-
-    /*** 2. Should we schedule refreshes? ***/
-    refresh->tick_ref();
-
-    /*** 3. Should we schedule writes? ***/
-    if (!write_mode) {
-        // yes -- write queue is almost full or read queue is empty
-        if (writeq.size() >= int(0.8 * writeq.max) /*|| readq.size() == 0*/)
-            write_mode = true;
-    }
-    else {
-        // no -- write queue is almost empty and read queue is not empty
-        if (writeq.size() <= int(0.2 * writeq.max) && readq.size() != 0)
-            write_mode = false;
-    }
-
-    /*** 4. Find the best command to schedule, if any ***/
-    Queue* queue = !write_mode ? &readq : &writeq;
-    if (otherq.size())
-        queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-
-    auto req = scheduler->get_head(queue->q);
-    if (req == queue->q.end() || !is_ready(req)) {
-        // we couldn't find a command to schedule -- let's try to be speculative
-        auto cmd = TLDRAM::Command::PRE;
-        vector<int> victim = rowpolicy->get_victim(cmd);
-        if (!victim.empty()){
-            issue_cmd(cmd, victim);
-        }
-        return;  // nothing more to be done this cycle
-    }
-
-    if (req->is_first_command) {
-        int coreid = req->coreid;
-        req->is_first_command = false;
-        if (req->type == Request::Type::READ || req->type == Request::Type::WRITE) {
-          channel->update_serving_requests(req->addr_vec.data(), 1, clk);
-        }
-        int tx = (channel->spec->prefetch_size * channel->spec->channel_width / 8);
-        if (req->type == Request::Type::READ) {
-            if (is_row_hit(req)) {
-                ++read_row_hits[coreid];
-                ++row_hits;
-                // daz3
-                period_read_row_hits++;
-            } else if (is_row_open(req)) {
-                ++read_row_conflicts[coreid];
-                ++row_conflicts;
-                // daz3
-                period_read_row_conflicts++;
-            } else {
-                ++read_row_misses[coreid];
-                ++row_misses;
-                // daz3
-                period_read_row_misses++;
-            }
-            read_transaction_bytes += tx;
-        } else if (req->type == Request::Type::WRITE) {
-            if (is_row_hit(req)) {
-                ++write_row_hits[coreid];
-                ++row_hits;
-                // daz3
-                period_write_row_hits++;
-            } else if (is_row_open(req)) {
-                ++write_row_conflicts[coreid];
-                ++row_conflicts;
-                // daz3
-                period_write_row_conflicts++;
-            } else {
-                ++write_row_misses[coreid];
-                ++row_misses;
-                // daz3
-                period_write_row_misses++;
-            }
-          write_transaction_bytes += tx;
-        }
-    }
-
-    /*** 5. Change a read request to a migration request ***/
-    if (req->type == Request::Type::READ) {
-        req->type = Request::Type::EXTENSION;
-    }
-
-    // issue command on behalf of request
-    auto cmd = get_first_cmd(req);
-    issue_cmd(cmd, get_addr_vec(cmd, req));
-
-    // check whether this is the last command (which finishes the request)
-    if (cmd != channel->spec->translate[int(req->type)])
-        return;
-
-    // set a future completion time for read requests
-    if (req->type == Request::Type::READ || req->type == Request::Type::EXTENSION) {
-        req->depart = clk + channel->spec->read_latency;
-        pending.push_back(*req);
-    }
-    if (req->type == Request::Type::WRITE) {
-        channel->update_serving_requests(req->addr_vec.data(), -1, clk);
-    }
-
-    // remove request from queue
-    queue->q.erase(req);
-
-    // daz3
-    if(clk % my_print_intelval == 0)
-    {
-        std::cout << "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv" << std::endl;
-        std::cout << "clk " << clk << std::endl;
-        std::cout << "period_read_row_hits " << period_read_row_hits << std::endl;
-        std::cout << "period_read_row_misses " << period_read_row_misses << std::endl;
-        std::cout << "period_read_row_conflicts " << period_read_row_conflicts << std::endl;
-        std::cout << "period_write_row_hits " << period_write_row_hits << std::endl;
-        std::cout << "period_write_row_misses " << period_write_row_misses << std::endl;
-        std::cout << "period_write_row_conflicts " << period_write_row_conflicts << std::endl;
-        std::cout << "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" << std::endl;
-    }
-}
-
-template<>
-void Controller<TLDRAM>::cmd_issue_autoprecharge(typename TLDRAM::Command& cmd,
-                                                    const vector<int>& addr_vec) {
-    //TLDRAM currently does not have autoprecharge commands
-    return;
-}
-
-} /* namespace ramulator */
diff --git a/ext/ramulator/Ramulator/src/Controller.h b/ext/ramulator/Ramulator/src/Controller.h
deleted file mode 100644
index 8a30e9d85..000000000
--- a/ext/ramulator/Ramulator/src/Controller.h
+++ /dev/null
@@ -1,902 +0,0 @@
-#ifndef __CONTROLLER_H
-#define __CONTROLLER_H
-
-#include <cassert>
-#include <cstdio>
-#include <deque>
-#include <fstream>
-#include <list>
-#include <string>
-#include <vector>
-#include <queue>
-
-#include "Config.h"
-#include "DRAM.h"
-#include "Refresh.h"
-#include "Request.h"
-#include "Scheduler.h"
-#include "Statistics.h"
-
-#include "ALDRAM.h"
-#include "SALP.h"
-#include "TLDRAM.h"
-#include "DDR4.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-    extern bool warmup_complete;
-
-template <typename T>
-class Controller
-{
-protected:
-    // For counting bandwidth
-    ScalarStat read_transaction_bytes;
-    ScalarStat write_transaction_bytes;
-
-    ScalarStat row_hits;
-    ScalarStat row_misses;
-    ScalarStat row_conflicts;
-    VectorStat read_row_hits;
-    VectorStat read_row_misses;
-    VectorStat read_row_conflicts;
-    VectorStat write_row_hits;
-    VectorStat write_row_misses;
-    VectorStat write_row_conflicts;
-    ScalarStat useless_activates;
-
-    ScalarStat read_latency_avg;
-    ScalarStat read_latency_sum;
-    // gagan : demand requests and prefetch requests
-    ScalarStat demand_read_latency_avg;
-    ScalarStat demand_read_latency_sum;
-    ScalarStat prefetch_read_latency_avg;
-    ScalarStat prefetch_read_latency_sum;
-
-    ScalarStat req_queue_length_avg;
-    ScalarStat req_queue_length_sum;
-    ScalarStat read_req_queue_length_avg;
-    ScalarStat read_req_queue_length_sum;
-    ScalarStat write_req_queue_length_avg;
-    ScalarStat write_req_queue_length_sum;
-
-#ifndef INTEGRATED_WITH_GEM5
-    VectorStat record_read_hits;
-    VectorStat record_read_misses;
-    VectorStat record_read_conflicts;
-    VectorStat record_write_hits;
-    VectorStat record_write_misses;
-    VectorStat record_write_conflicts;
-#endif
-
-public:
-    /* Member Variables */
-    long clk = 0;
-    DRAM<T>* channel;
-
-    // gagan : enable_debug
-    bool enable_debug;
-
-    // daz3
-    long period_read_row_hits;
-    long period_read_row_misses;
-    long period_read_row_conflicts;
-    long period_write_row_hits;
-    long period_write_row_misses;
-    long period_write_row_conflicts;
-    long my_print_intelval = 200000000; //every 0.2ms
-
-    Scheduler<T>* scheduler;  // determines the highest priority request whose commands will be issued
-    RowPolicy<T>* rowpolicy;  // determines the row-policy (e.g., closed-row vs. open-row)
-    RowTable<T>* rowtable;  // tracks metadata about rows (e.g., which are open and for how long)
-    Refresh<T>* refresh;
-
-    struct Queue {
-        list<Request> q;
-        unsigned int max = 32;
-        // daz3: test tWTR
-        // unsigned int max = 16;
-        unsigned int size() { return q.size(); }
-      void print()
-      {
-	//std::cout << "Printing queue: " << std::endl;
-	for(auto &i : q)
-	  {
-	    i.print();
-	  }
-      }
-
-      bool hasRequestType(Request::Type type)
-      {
-	for(auto &r : q)
-	  {
-	    if(r.type == type)
-	      return true;
-	  }
-	return false;
-      }
-    };
-
-    Queue readq;  // queue for read requests
-    Queue writeq;  // queue for write requests
-    Queue actq; // read and write requests for which activate was issued are moved to 
-                   // actq, which has higher priority than readq and writeq.
-                   // This is an optimization
-                   // for avoiding useless activations (i.e., PRECHARGE
-                   // after ACTIVATE w/o READ of WRITE command)
-    Queue otherq;  // queue for all "other" requests (e.g., refresh)
-
-    deque<Request> pending;  // read requests that are about to receive data from DRAM
-    bool write_mode = false;  // whether write requests should be prioritized over reads
-    float wr_high_watermark = 0.8f; // threshold for switching to write mode
-    float wr_low_watermark = 0.2f; // threshold for switching back to read mode
-    //long refreshed = 0;  // last time refresh requests were generated
-
-    /* Command trace for DRAMPower 3.1 */
-    string cmd_trace_prefix = "cmd-trace-";
-    vector<ofstream> cmd_trace_files;
-    bool record_cmd_trace = false;
-    /* Commands to stdout */
-    bool print_cmd_trace = false;
-
-    /* Constructor */
-    Controller(const Config& configs, DRAM<T>* channel, bool enable_debug) :
-        enable_debug(enable_debug),
-        channel(channel),
-        scheduler(new Scheduler<T>(this)),
-        rowpolicy(new RowPolicy<T>(this)),
-        rowtable(new RowTable<T>(this)),
-        refresh(new Refresh<T>(this)),
-        cmd_trace_files(channel->children.size())
-    {
-        // daz3: set read/write queue
-        // readq.max = 128;
-        readq.max = 512;
-        writeq.max = 128;
-        // writeq.max = 256;
-        std::cout << "Controller readq " << readq.max << ", writeq " << writeq.max << std::endl;
-
-        record_cmd_trace = configs.record_cmd_trace();
-        print_cmd_trace = configs.print_cmd_trace();
-        if (record_cmd_trace){
-            if (configs["cmd_trace_prefix"] != "") {
-              cmd_trace_prefix = configs["cmd_trace_prefix"];
-            }
-	    std::string traceDir = configs.get_tracefile_directory();
-            string prefix = traceDir + cmd_trace_prefix + "chan-" + to_string(channel->id) + "-rank-";
-            string suffix = ".cmdtrace";
-            for (unsigned int i = 0; i < channel->children.size(); i++)
-                cmd_trace_files[i].open(prefix + to_string(i) + suffix);
-        }
-
-        // daz3
-        period_read_row_hits = 0;
-        period_read_row_misses = 0;
-        period_read_row_conflicts = 0;
-        period_write_row_hits = 0;
-        period_write_row_misses = 0;
-        period_write_row_conflicts = 0;
-
-        // regStats
-
-        row_hits
-            .name("row_hits_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row hits per channel per core")
-            .precision(0)
-            ;
-        row_misses
-            .name("row_misses_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row misses per channel per core")
-            .precision(0)
-            ;
-        row_conflicts
-            .name("row_conflicts_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row conflicts per channel per core")
-            .precision(0)
-            ;
-
-        read_row_hits
-            .init(configs.get_core_num())
-            .name("read_row_hits_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row hits for read requests per channel per core")
-            .precision(0)
-            ;
-        read_row_misses
-            .init(configs.get_core_num())
-            .name("read_row_misses_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row misses for read requests per channel per core")
-            .precision(0)
-            ;
-        read_row_conflicts
-            .init(configs.get_core_num())
-            .name("read_row_conflicts_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row conflicts for read requests per channel per core")
-            .precision(0)
-            ;
-
-        write_row_hits
-            .init(configs.get_core_num())
-            .name("write_row_hits_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row hits for write requests per channel per core")
-            .precision(0)
-            ;
-        write_row_misses
-            .init(configs.get_core_num())
-            .name("write_row_misses_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row misses for write requests per channel per core")
-            .precision(0)
-            ;
-        write_row_conflicts
-            .init(configs.get_core_num())
-            .name("write_row_conflicts_channel_"+to_string(channel->id) + "_core")
-            .desc("Number of row conflicts for write requests per channel per core")
-            .precision(0)
-            ;
-
-        useless_activates
-            .name("useless_activates_"+to_string(channel->id)+ "_core")
-            .desc("Number of useless activations. E.g, ACT -> PRE w/o RD or WR")
-            .precision(0)
-            ;
-
-        read_transaction_bytes
-            .name("read_transaction_bytes_"+to_string(channel->id))
-            .desc("The total byte of read transaction per channel")
-            .precision(0)
-            ;
-        write_transaction_bytes
-            .name("write_transaction_bytes_"+to_string(channel->id))
-            .desc("The total byte of write transaction per channel")
-            .precision(0)
-            ;
-
-        read_latency_sum
-            .name("read_latency_sum_"+to_string(channel->id))
-            .desc("The memory latency cycles (in memory time domain) sum for all read requests in this channel")
-            .precision(0)
-            ;
-        read_latency_avg
-            .name("read_latency_avg_"+to_string(channel->id))
-            .desc("The average memory latency cycles (in memory time domain) per request for all read requests in this channel")
-            .precision(6)
-            ;
-	// gagan : demand and prefetch read requests
-        demand_read_latency_sum
-            .name("demand_read_latency_sum_"+to_string(channel->id))
-            .desc("The memory latency cycles (in memory time domain) sum for demand read requests in this channel")
-            .precision(0)
-            ;
-        demand_read_latency_avg
-            .name("demand_read_latency_avg_"+to_string(channel->id))
-            .desc("The average memory latency cycles (in memory time domain) per request for demand read requests in this channel")
-            .precision(6)
-            ;
-	prefetch_read_latency_sum
-            .name("prefetch_read_latency_sum_"+to_string(channel->id))
-            .desc("The memory latency cycles (in memory time domain) sum for prefetch read requests in this channel")
-            .precision(0)
-            ;
-        prefetch_read_latency_avg
-            .name("prefetch_read_latency_avg_"+to_string(channel->id))
-            .desc("The average memory latency cycles (in memory time domain) per request for prefetch read requests in this channel")
-            .precision(6)
-            ;
-        req_queue_length_sum
-            .name("req_queue_length_sum_"+to_string(channel->id))
-            .desc("Sum of read and write queue length per memory cycle per channel.")
-            .precision(0)
-            ;
-        req_queue_length_avg
-            .name("req_queue_length_avg_"+to_string(channel->id))
-            .desc("Average of read and write queue length per memory cycle per channel.")
-            .precision(6)
-            ;
-
-        read_req_queue_length_sum
-            .name("read_req_queue_length_sum_"+to_string(channel->id))
-            .desc("Read queue length sum per memory cycle per channel.")
-            .precision(0)
-            ;
-        read_req_queue_length_avg
-            .name("read_req_queue_length_avg_"+to_string(channel->id))
-            .desc("Read queue length average per memory cycle per channel.")
-            .precision(6)
-            ;
-
-        write_req_queue_length_sum
-            .name("write_req_queue_length_sum_"+to_string(channel->id))
-            .desc("Write queue length sum per memory cycle per channel.")
-            .precision(0)
-            ;
-        write_req_queue_length_avg
-            .name("write_req_queue_length_avg_"+to_string(channel->id))
-            .desc("Write queue length average per memory cycle per channel.")
-            .precision(6)
-            ;
-
-#ifndef INTEGRATED_WITH_GEM5
-        record_read_hits
-            .init(configs.get_core_num())
-            .name("record_read_hits")
-            .desc("record read hit count for this core when it reaches request limit or to the end")
-            ;
-
-        record_read_misses
-            .init(configs.get_core_num())
-            .name("record_read_misses")
-            .desc("record_read_miss count for this core when it reaches request limit or to the end")
-            ;
-
-        record_read_conflicts
-            .init(configs.get_core_num())
-            .name("record_read_conflicts")
-            .desc("record read conflict count for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_hits
-            .init(configs.get_core_num())
-            .name("record_write_hits")
-            .desc("record write hit count for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_misses
-            .init(configs.get_core_num())
-            .name("record_write_misses")
-            .desc("record write miss count for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_conflicts
-            .init(configs.get_core_num())
-            .name("record_write_conflicts")
-            .desc("record write conflict for this core when it reaches request limit or to the end")
-            ;
-#endif
-    }
-
-    ~Controller(){
-        delete scheduler;
-        delete rowpolicy;
-        delete rowtable;
-        delete channel;
-        delete refresh;
-        for (auto& file : cmd_trace_files)
-            file.close();
-        cmd_trace_files.clear();
-    }
-
-    void finish(long read_req, long demand_read_req, long prefetch_read_req,long dram_cycles) {
-      read_latency_avg = read_latency_sum.value() / read_req;
-      req_queue_length_avg = req_queue_length_sum.value() / dram_cycles;
-      read_req_queue_length_avg = read_req_queue_length_sum.value() / dram_cycles;
-      write_req_queue_length_avg = write_req_queue_length_sum.value() / dram_cycles;
-      // gagan : demand and prefetch reads
-      demand_read_latency_avg = demand_read_latency_sum.value() / demand_read_req;
-      prefetch_read_latency_avg = prefetch_read_latency_sum.value() / prefetch_read_req;
-      // call finish function of each channel
-      channel->finish(dram_cycles);
-    }
-
-    /* Member Functions */
-    Queue& get_queue(Request::Type type)
-    {
-        switch (int(type)) {
-            case int(Request::Type::READ): return readq;
-            case int(Request::Type::WRITE): return writeq;
-            default: return otherq;
-        }
-    }
-
-    // gagan :
-    bool promote(Request& req)
-    {
-      assert(req.type == Request::Type::READ);
-      // promote : actq
-      for(auto &r : actq.q)
-	{
-	  if(r.addr == req.addr && r.type == Request::Type::READ)
-	    {
-	      assert(r.is_prefetch == true);
-	      r.is_prefetch = false;
-	      r.arrive = clk;
-	    }
-	}
-
-      for(auto &r : readq.q)
-	{
-	  if(r.addr == req.addr)
-	    {
-	      assert(r.is_prefetch == true);
-	      r.arrive = clk;
-	      r.is_prefetch = false;
-	    }
-	}
-
-      return true;
-    }
-    
-    bool enqueue(Request& req)
-    {
-        Queue& queue = get_queue(req.type);
-        if (queue.max == queue.size())
-            return false;
-
-        req.arrive = clk;
-        queue.q.push_back(req);
-        // shortcut for read requests, if a write to same addr exists
-        // necessary for coherence
-        if (req.type == Request::Type::READ && find_if(writeq.q.begin(), writeq.q.end(),
-                [req](Request& wreq){ return req.addr == wreq.addr;}) != writeq.q.end()){
-            req.depart = clk + 1;
-            pending.push_back(req);
-            readq.q.pop_back();
-        }
-        return true;
-    }
-
-    void tick()
-    {
-        clk++;
-        req_queue_length_sum += readq.size() + writeq.size() + pending.size();
-        read_req_queue_length_sum += readq.size() + pending.size();
-        write_req_queue_length_sum += writeq.size();
-
-        /*** 1. Serve completed reads ***/
-        if (pending.size()) {
-            Request& req = pending[0];
-            if (req.depart <= clk) {
-                if (req.depart - req.arrive > 1) { // this request really accessed a row
-                  read_latency_sum += req.depart - req.arrive;
-		  // gagan : demand and prefetch reads
-		  if(req.is_prefetch)
-		      prefetch_read_latency_sum += req.depart - req.arrive;
-		  else
-		      demand_read_latency_sum += req.depart - req.arrive;
-                  channel->update_serving_requests(
-                      req.addr_vec.data(), -1, clk);
-                }
-                req.callback(req);
-                pending.pop_front();
-            }
-        }
-
-        /*** 2. Refresh scheduler ***/
-        refresh->tick_ref();
-
-        /*** 3. Should we schedule writes? ***/
-        if (!write_mode)
-	  {
-            // yes -- write queue is almost full or read queue is empty
-            if (writeq.size() > int(wr_high_watermark * writeq.max) 
-                    /*|| readq.size() == 0*/) // Hasan: Switching to write mode when there are just a few 
-                                              // write requests, even if the read queue is empty, incurs a lot of overhead. 
-                                              // Commented out the read request queue empty condition
-	      write_mode = true;
-        }
-        else {
-            // no -- write queue is almost empty and read queue is not empty
-            if (writeq.size() < int(wr_low_watermark * writeq.max) && readq.size() != 0)
-	      write_mode = false;
-        }
-
-        /*** 4. Find the best command to schedule, if any ***/
-
-        // First check the actq (which has higher priority) to see if there
-        // are requests available to service in this cycle
-        Queue* queue = &actq;
-
-	if(enable_debug)
-	  {
-	    std::cout << "<------------------------------------------->" << std::endl;
-	    std::cout << "Clk: " << clk << std::endl;
-	    std::cout << "Channel: " << channel->id << std::endl;
-	    if(actq.q.size() != 0)
-	      {
-		std::cout << "Activation Queue: " << std::endl;
-		actq.print();
-	      }
-	    if(readq.q.size() != 0)
-	      {
-		std::cout << "Read Queue: " << std::endl;
-		readq.print();
-	      }
-	    if(writeq.q.size() != 0)
-	      {
-		std::cout << "Write Queue: " << std::endl;
-		writeq.print();
-	      }
-	    if(otherq.q.size() != 0)
-	      {
-		std::cout << "Other Queue: " << std::endl;
-		otherq.print();
-	      }
-	    rowtable->print();
-	    std::cout << "<------------------------------------------->" << std::endl;
-	  }
-
-	/*
-	std::cout << "Clk: " << clk << std::endl;
-	std::cout << "Channel: " << channel->id << std::endl;
-	std::cout << "Refreshing rank: " << get_refreshing_rank() << std::endl;
-	if(otherq.q.size() != 0)
-	  {
-	    std::cout << "Other Queue: " << std::endl;
-	    otherq.print();
-	  }
-	*/
-	
-
-        auto req = scheduler->get_head(queue->q);
-        if (req == queue->q.end() || !is_ready(req)) {
-            queue = !write_mode ? &readq : &writeq;
-
-            if (otherq.size())
-                queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-
-            req = scheduler->get_head(queue->q);
-        }
-
-        if (req == queue->q.end() || !is_ready(req)) {
-            // we couldn't find a command to schedule -- let's try to be speculative
-            auto cmd = T::Command::PRE;
-            vector<int> victim = rowpolicy->get_victim(cmd);
-            if (!victim.empty()){
-                issue_cmd(cmd, victim);
-            }
-            return;  // nothing more to be done this cycle
-        }
-
-	if (req->is_first_command) {
-            req->is_first_command = false;
-            int coreid = req->coreid;
-            if (req->type == Request::Type::READ || req->type == Request::Type::WRITE) {
-              channel->update_serving_requests(req->addr_vec.data(), 1, clk);
-            }
-            int tx = (channel->spec->prefetch_size * channel->spec->channel_width / 8);
-            if (req->type == Request::Type::READ) {
-                if (is_row_hit(req)) {
-                    ++read_row_hits[coreid];
-                    ++row_hits;
-                    // daz3
-                    period_read_row_hits++;
-                } else if (is_row_open(req)) {
-                    ++read_row_conflicts[coreid];
-                    ++row_conflicts;
-                    // daz3
-                    period_read_row_conflicts++;
-                } else {
-                    ++read_row_misses[coreid];
-                    ++row_misses;
-                    // daz3
-                    period_read_row_misses++;
-                }
-              read_transaction_bytes += tx;
-            } else if (req->type == Request::Type::WRITE) {
-              if (is_row_hit(req)) {
-                  ++write_row_hits[coreid];
-                  ++row_hits;
-                  // daz3
-                  period_write_row_hits++;
-              } else if (is_row_open(req)) {
-                  ++write_row_conflicts[coreid];
-                  ++row_conflicts;
-                  // daz3
-                  period_write_row_conflicts++;
-              } else {
-                  ++write_row_misses[coreid];
-                  ++row_misses;
-                  // daz3
-                  period_write_row_misses++;
-              }
-              write_transaction_bytes += tx;
-            }
-        }
-
-        // issue command on behalf of request
-	//std::cout << "Issuing command on behalf of request: ";
-	//req->print();	  
-        auto cmd = get_first_cmd(req);
-        issue_cmd(cmd, get_addr_vec(cmd, req));
-
-        // check whether this is the last command (which finishes the request)
-        //if (cmd != channel->spec->translate[int(req->type)]){
-        if (!(channel->spec->is_accessing(cmd) || channel->spec->is_refreshing(cmd))) {
-            if(channel->spec->is_opening(cmd)) {
-                // promote the request that caused issuing activation to actq
-                actq.q.push_back(*req);
-                queue->q.erase(req);
-            }
-
-            return;
-        }
-
-        // set a future completion time for read requests
-        if (req->type == Request::Type::READ) {
-            req->depart = clk + channel->spec->read_latency;
-            pending.push_back(*req);
-        }
-
-        if (req->type == Request::Type::WRITE) {
-            channel->update_serving_requests(req->addr_vec.data(), -1, clk);
-        }
-
-	if(enable_debug)
-	  {
-	    std::cout << "Request completed: "; req->print();
-	  }
-
-	/*
-	// gagan : debug
-	if(req->type == Request::Type::REFRESH)
-	  {
-	    std::cout << "Request completed: "; req->print();
-	  }
-	*/
-	
-	if(req->type == Request::Type::READ || req->type == Request::Type::WRITE)
-	  {
-	    int rank = req->addr_vec[1];
-	    assert(rank != get_refreshing_rank());
-	  }
-        // remove request from queue
-        queue->q.erase(req);
-
-        // daz3
-        if(clk % my_print_intelval == 0)
-        {
-            std::cout << "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv" << std::endl;
-            std::cout << "clk " << clk << std::endl;
-            std::cout << "period_read_row_hits " << period_read_row_hits << std::endl;
-            std::cout << "period_read_row_misses " << period_read_row_misses << std::endl;
-            std::cout << "period_read_row_conflicts " << period_read_row_conflicts << std::endl;
-            std::cout << "period_write_row_hits " << period_write_row_hits << std::endl;
-            std::cout << "period_write_row_misses " << period_write_row_misses << std::endl;
-            std::cout << "period_write_row_conflicts " << period_write_row_conflicts << std::endl;
-            std::cout << "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" << std::endl;
-        }
-    }
-
-    bool is_ready(list<Request>::iterator req)
-    {
-        typename T::Command cmd = get_first_cmd(req);
-        return channel->check(cmd, req->addr_vec.data(), clk);
-    }
-
-    bool is_ready(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-        return channel->check(cmd, addr_vec.data(), clk);
-    }
-
-    bool is_row_hit(list<Request>::iterator req)
-    {
-        // cmd must be decided by the request type, not the first cmd
-        typename T::Command cmd = channel->spec->translate[int(req->type)];
-        return channel->check_row_hit(cmd, req->addr_vec.data());
-    }
-
-    bool is_row_hit(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-        return channel->check_row_hit(cmd, addr_vec.data());
-    }
-
-    bool is_row_open(list<Request>::iterator req)
-    {
-        // cmd must be decided by the request type, not the first cmd
-        typename T::Command cmd = channel->spec->translate[int(req->type)];
-        return channel->check_row_open(cmd, req->addr_vec.data());
-    }
-
-    bool is_row_open(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-        return channel->check_row_open(cmd, addr_vec.data());
-    }
-
-    void update_temp(ALDRAM::Temp current_temperature)
-    {
-    }
-
-    // For telling whether this channel is busying in processing read or write
-    bool is_active() {
-      return (channel->cur_serving_requests > 0);
-    }
-
-    // For telling whether this channel is under refresh
-    /*
-    bool is_refresh() {
-      // gagan : for all-rank refresh
-      // return clk <= channel->end_of_refreshing;
-      // gagan : for staggered refresh
-      bool isAnyRankRefresh = false;
-      for(auto rank : channel->children)
-	{
-	  assert(isAnyRankRefresh == false);
-	  isAnyRankRefresh = (bool)(clk <= rank->end_of_refreshing);
-	}
-      return isAnyRankRefresh;
-    }
-    */
-
-    // gagan : returns which rank is refreshing, otherwise returns -1.
-    int get_refreshing_rank()
-    {
-      for(auto rank : channel->children)
-	{
-	  if(clk <= rank->end_of_refreshing)
-	    {
-	      return rank->id;
-	    }
-	}
-      return -1;
-    }
-
-    bool no_reads_to_non_refreshing_ranks(int refreshing_rank)
-    {
-      auto &read_queue = readq.q;
-      for(auto &req : read_queue)
-	{
-	  int rank = req.addr_vec[1];
-	  if(rank != refreshing_rank)
-	    return false;
-	}
-      return true;
-    }
-
-    void set_high_writeq_watermark(const float watermark) {
-       wr_high_watermark = watermark; 
-    }
-
-    void set_low_writeq_watermark(const float watermark) {
-       wr_low_watermark = watermark;
-    }
-
-    void record_core(int coreid) {
-#ifndef INTEGRATED_WITH_GEM5
-      record_read_hits[coreid] = read_row_hits[coreid];
-      record_read_misses[coreid] = read_row_misses[coreid];
-      record_read_conflicts[coreid] = read_row_conflicts[coreid];
-      record_write_hits[coreid] = write_row_hits[coreid];
-      record_write_misses[coreid] = write_row_misses[coreid];
-      record_write_conflicts[coreid] = write_row_conflicts[coreid];
-#endif
-    }
-
-private:
-    typename T::Command get_first_cmd(list<Request>::iterator req)
-    {
-        typename T::Command cmd = channel->spec->translate[int(req->type)];
-        return channel->decode(cmd, req->addr_vec.data());
-    }
-
-    // upgrade to an autoprecharge command
-    void cmd_issue_autoprecharge(typename T::Command& cmd,
-                                            const vector<int>& addr_vec) {
-
-        // currently, autoprecharge is only used with closed row policy
-        if(channel->spec->is_accessing(cmd) && rowpolicy->type == RowPolicy<T>::Type::ClosedAP) {
-            // check if it is the last request to the opened row
-            Queue* queue = write_mode ? &writeq : &readq;
-
-            auto begin = addr_vec.begin();
-            vector<int> rowgroup(begin, begin + int(T::Level::Row) + 1);
-
-			int num_row_hits = 0;
-
-            for (auto itr = queue->q.begin(); itr != queue->q.end(); ++itr) {
-                if (is_row_hit(itr)) { 
-                    auto begin2 = itr->addr_vec.begin();
-                    vector<int> rowgroup2(begin2, begin2 + int(T::Level::Row) + 1);
-                    if(rowgroup == rowgroup2)
-                        num_row_hits++;
-                }
-            }
-
-            if(num_row_hits == 0) {
-                Queue* queue = &actq;
-                for (auto itr = queue->q.begin(); itr != queue->q.end(); ++itr) {
-                    if (is_row_hit(itr)) {
-                        auto begin2 = itr->addr_vec.begin();
-                        vector<int> rowgroup2(begin2, begin2 + int(T::Level::Row) + 1);
-                        if(rowgroup == rowgroup2)
-                            num_row_hits++;
-                    }
-                }
-            }
-
-            assert(num_row_hits > 0); // The current request should be a hit, 
-                                      // so there should be at least one request 
-                                      // that hits in the current open row
-            if(num_row_hits == 1) {
-                if(cmd == T::Command::RD)
-                    cmd = T::Command::RDA;
-                else if (cmd == T::Command::WR)
-                    cmd = T::Command::WRA;
-                else
-                    assert(false && "Unimplemented command type.");
-            }
-        }
-
-    }
-
-    void issue_cmd(typename T::Command cmd, const vector<int>& addr_vec)
-    {
-      	// gagan : staggered refresh
-      /*
-	if(channel->spec->standard_name == "DDR4" && int(cmd) == int(T::Command::REF))
-	  {
-	    assert(is_refresh() == false);
-	  }
-      */
-      
-        cmd_issue_autoprecharge(cmd, addr_vec);
-        assert(is_ready(cmd, addr_vec));
-        channel->update(cmd, addr_vec.data(), clk);
-
-	/*
-	 // gagan : debug
-	if(channel->spec->standard_name == "DDR4" && int(cmd) == int(T::Command::REF))
-	  {
-	    int i = 0;
-	    for (auto child : channel->children)
-	      {
-		std::cout << "end_of_refreshing_rank: " << i << ", clk: " << child->end_of_refreshing << std::endl;
-		i++;
-	      }
-	  }
-	*/
-
-        if(cmd == T::Command::PRE){
-            if(rowtable->get_hits(addr_vec, true) == 0){
-                useless_activates++;
-            }
-        }
- 
-        rowtable->update(cmd, addr_vec, clk);
-        if (record_cmd_trace){
-            // select rank
-            auto& file = cmd_trace_files[addr_vec[1]];
-            string& cmd_name = channel->spec->command_name[int(cmd)];
-            file<<clk<<','<<cmd_name;
-            // TODO bad coding here
-            if (cmd_name == "PREA" || cmd_name == "REF")
-                file<<endl;
-            else{
-                int bank_id = addr_vec[int(T::Level::Bank)];
-                if (channel->spec->standard_name == "DDR4" || channel->spec->standard_name == "GDDR5")
-                    bank_id += addr_vec[int(T::Level::Bank) - 1] * channel->spec->org_entry.count[int(T::Level::Bank)];
-                file<<','<<bank_id<<endl;
-            }
-        }
-        if (print_cmd_trace){
-            printf("%5s %10ld:", channel->spec->command_name[int(cmd)].c_str(), clk);
-            for (int lev = 0; lev < int(T::Level::MAX); lev++)
-                printf(" %5d", addr_vec[lev]);
-            printf("\n");
-        }
-    }
-    vector<int> get_addr_vec(typename T::Command cmd, list<Request>::iterator req){
-        return req->addr_vec;
-    }
-};
-
-template <>
-vector<int> Controller<SALP>::get_addr_vec(
-    SALP::Command cmd, list<Request>::iterator req);
-
-template <>
-bool Controller<SALP>::is_ready(list<Request>::iterator req);
-
-template <>
-void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature);
-
-template <>
-void Controller<TLDRAM>::tick();
-
-template <>
-void Controller<TLDRAM>::cmd_issue_autoprecharge(typename TLDRAM::Command& cmd,
-                                                    const vector<int>& addr_vec);
-
-} /*namespace ramulator*/
-
-#endif /*__CONTROLLER_H*/
diff --git a/ext/ramulator/Ramulator/src/DDR3.cpp b/ext/ramulator/Ramulator/src/DDR3.cpp
deleted file mode 100644
index bc3957dc0..000000000
--- a/ext/ramulator/Ramulator/src/DDR3.cpp
+++ /dev/null
@@ -1,357 +0,0 @@
-#include "DDR3.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string DDR3::standard_name = "DDR3";
-string DDR3::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum DDR3::Org> DDR3::org_map = {
-    {"DDR3_512Mb_x4", DDR3::Org::DDR3_512Mb_x4}, {"DDR3_512Mb_x8", DDR3::Org::DDR3_512Mb_x8}, {"DDR3_512Mb_x16", DDR3::Org::DDR3_512Mb_x16},
-    {"DDR3_1Gb_x4", DDR3::Org::DDR3_1Gb_x4}, {"DDR3_1Gb_x8", DDR3::Org::DDR3_1Gb_x8}, {"DDR3_1Gb_x16", DDR3::Org::DDR3_1Gb_x16},
-    {"DDR3_2Gb_x4", DDR3::Org::DDR3_2Gb_x4}, {"DDR3_2Gb_x8", DDR3::Org::DDR3_2Gb_x8}, {"DDR3_2Gb_x16", DDR3::Org::DDR3_2Gb_x16},
-    {"DDR3_4Gb_x4", DDR3::Org::DDR3_4Gb_x4}, {"DDR3_4Gb_x8", DDR3::Org::DDR3_4Gb_x8}, {"DDR3_4Gb_x16", DDR3::Org::DDR3_4Gb_x16},
-    {"DDR3_8Gb_x4", DDR3::Org::DDR3_8Gb_x4}, {"DDR3_8Gb_x8", DDR3::Org::DDR3_8Gb_x8}, {"DDR3_8Gb_x16", DDR3::Org::DDR3_8Gb_x16},
-};
-
-map<string, enum DDR3::Speed> DDR3::speed_map = {
-    {"DDR3_800D", DDR3::Speed::DDR3_800D}, {"DDR3_800E", DDR3::Speed::DDR3_800E},
-    {"DDR3_1066E", DDR3::Speed::DDR3_1066E}, {"DDR3_1066F", DDR3::Speed::DDR3_1066F}, {"DDR3_1066G", DDR3::Speed::DDR3_1066G},
-    {"DDR3_1333G", DDR3::Speed::DDR3_1333G}, {"DDR3_1333H", DDR3::Speed::DDR3_1333H},
-    {"DDR3_1600H", DDR3::Speed::DDR3_1600H}, {"DDR3_1600J", DDR3::Speed::DDR3_1600J}, {"DDR3_1600K", DDR3::Speed::DDR3_1600K},
-    {"DDR3_1866K", DDR3::Speed::DDR3_1866K}, {"DDR3_1866L", DDR3::Speed::DDR3_1866L},
-    {"DDR3_2133L", DDR3::Speed::DDR3_2133L}, {"DDR3_2133M", DDR3::Speed::DDR3_2133M},
-};
-
-
-DDR3::DDR3(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-DDR3::DDR3(const string& org_str, const string& speed_str) :
-    DDR3(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void DDR3::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void DDR3::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void DDR3::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void DDR3::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void DDR3::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR3::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR3::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DDR3>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR3>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DDR3>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void DDR3::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/DDR3.h b/ext/ramulator/Ramulator/src/DDR3.h
deleted file mode 100644
index bed966b1f..000000000
--- a/ext/ramulator/Ramulator/src/DDR3.h
+++ /dev/null
@@ -1,220 +0,0 @@
-#ifndef __DDR3_H
-#define __DDR3_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DDR3
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    DDR3(Org org, Speed speed);
-    DDR3(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-    
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<DDR3>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DDR3>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DDR3>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DDR3>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        DDR3_512Mb_x4, DDR3_512Mb_x8, DDR3_512Mb_x16,
-        DDR3_1Gb_x4,   DDR3_1Gb_x8,   DDR3_1Gb_x16,
-        DDR3_2Gb_x4,   DDR3_2Gb_x8,   DDR3_2Gb_x16,
-        DDR3_4Gb_x4,   DDR3_4Gb_x8,   DDR3_4Gb_x16,
-        DDR3_8Gb_x4,   DDR3_8Gb_x8,   DDR3_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DDR3_800D,  DDR3_800E,
-        DDR3_1066E, DDR3_1066F, DDR3_1066G,
-        DDR3_1333G, DDR3_1333H,
-        DDR3_1600H, DDR3_1600J, DDR3_1600K,
-        DDR3_1866K, DDR3_1866L,
-        DDR3_2133L, DDR3_2133M,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__DDR3_H*/
diff --git a/ext/ramulator/Ramulator/src/DDR4.cpp b/ext/ramulator/Ramulator/src/DDR4.cpp
deleted file mode 100644
index 1fceb8889..000000000
--- a/ext/ramulator/Ramulator/src/DDR4.cpp
+++ /dev/null
@@ -1,634 +0,0 @@
-
-#include "DDR4.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string DDR4::standard_name = "DDR4";
-string DDR4::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-
-map<string, enum DDR4::Org> DDR4::org_map = {
-    {"DDR4_2Gb_x4", DDR4::Org::DDR4_2Gb_x4}, {"DDR4_2Gb_x8", DDR4::Org::DDR4_2Gb_x8}, {"DDR4_2Gb_x16", DDR4::Org::DDR4_2Gb_x16},
-    {"DDR4_4Gb_x4", DDR4::Org::DDR4_4Gb_x4}, {"DDR4_4Gb_x8", DDR4::Org::DDR4_4Gb_x8}, {"DDR4_4Gb_x16", DDR4::Org::DDR4_4Gb_x16},
-    {"DDR4_8Gb_x4", DDR4::Org::DDR4_8Gb_x4}, {"DDR4_8Gb_x8", DDR4::Org::DDR4_8Gb_x8}, {"DDR4_8Gb_x16", DDR4::Org::DDR4_8Gb_x16},
-    {"DDR4_4Gb_x8_w16", DDR4::Org::DDR4_4Gb_x8_w16}, {"DDR4_4Gb_x8_w32", DDR4::Org::DDR4_4Gb_x8_w32}, {"DDR4_4Gb_x8_w64", DDR4::Org::DDR4_4Gb_x8_w64},
-    {"DDR4_4Gb_x8_w8", DDR4::Org::DDR4_4Gb_x8_w8},
-    {"DDR4_4Gb_x8_4xBank", DDR4::Org::DDR4_4Gb_x8_4xBank},
-    {"DDR4_4Gb_x8_2xBank", DDR4::Org::DDR4_4Gb_x8_2xBank}
-};
-
-map<string, enum DDR4::Speed> DDR4::speed_map = {
-    {"DDR4_1600K", DDR4::Speed::DDR4_1600K},
-    {"DDR4_1600L", DDR4::Speed::DDR4_1600L},
-    {"DDR4_1866M", DDR4::Speed::DDR4_1866M},
-    {"DDR4_1866N", DDR4::Speed::DDR4_1866N},
-    {"DDR4_2133P", DDR4::Speed::DDR4_2133P},
-    {"DDR4_2133R", DDR4::Speed::DDR4_2133R},
-    {"DDR4_2400R", DDR4::Speed::DDR4_2400R},
-    // gagan
-    {"DDR4_2400R_base", DDR4::Speed::DDR4_2400R_base},
-    {"DDR4_2400R_ideal_nbr_lbb", DDR4::Speed::DDR4_2400R_ideal_nbr_lbb},
-    {"DDR4_2933R_ideal_nbr_lbb_ts", DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts},
-    {"DDR4_2933R_ideal_nbr_lbb_sts", DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts},
-    // Ramulator
-    {"DDR4_2400U", DDR4::Speed::DDR4_2400U},
-    {"DDR4_3200", DDR4::Speed::DDR4_3200},
-    // daz3
-    {"DDR4_3200_base", DDR4::Speed::DDR4_3200_base},
-    {"DDR4_3200_ideal_v1", DDR4::Speed::DDR4_3200_ideal_v1},
-    {"DDR4_3200_ideal_v2", DDR4::Speed::DDR4_3200_ideal_v2},
-    {"DDR4_3200_ideal_v2_modified", DDR4::Speed::DDR4_3200_ideal_v2_modified},
-    {"DDR4_3200_ideal_v3", DDR4::Speed::DDR4_3200_ideal_v3},
-    {"DDR4_3200_ideal_v4", DDR4::Speed::DDR4_3200_ideal_v4},
-    {"DDR4_3200_ideal_v7", DDR4::Speed::DDR4_3200_ideal_v7},
-    {"DDR4_3200_ideal_v4s", DDR4::Speed::DDR4_3200_ideal_v4s},
-    {"DDR4_3200_ideal_v5a", DDR4::Speed::DDR4_3200_ideal_v5a},
-    {"DDR4_3600_ideal_v4", DDR4::Speed::DDR4_3600_ideal_v4},
-    {"DDR4_3866_ideal_v4", DDR4::Speed::DDR4_3866_ideal_v4},
-    {"DDR4_3200_ideal_nbr_lbb", DDR4::Speed::DDR4_3200_ideal_nbr_lbb},
-    {"DDR4_3866_ideal_nbr_lbb_ts", DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts},
-    {"DDR4_3866_ideal_nbr_lbb_sts", DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts},
-    {"DDR4_3200_base_half_w8", DDR4::Speed::DDR4_3200_base_half_w8},
-    {"DDR4_3200_base_half_w16", DDR4::Speed::DDR4_3200_base_half_w16},
-    {"DDR4_3200_base_half_w32", DDR4::Speed::DDR4_3200_base_half_w32},
-    {"DDR4_3200_base_half_w64", DDR4::Speed::DDR4_3200_base_half_w64},
-    {"DDR4_3200_base_full_w8", DDR4::Speed::DDR4_3200_base_full_w8},
-    {"DDR4_3200_base_full_w16", DDR4::Speed::DDR4_3200_base_full_w16},
-    {"DDR4_3200_base_full_w32", DDR4::Speed::DDR4_3200_base_full_w32},
-    {"DDR4_3200_base_full_w64", DDR4::Speed::DDR4_3200_base_full_w64},
-    {"DDR4_3200_base_quarter_w8", DDR4::Speed::DDR4_3200_base_quarter_w8},
-    {"DDR4_3200_base_quarter_w16", DDR4::Speed::DDR4_3200_base_quarter_w16},
-    {"DDR4_3200_base_quarter_w32", DDR4::Speed::DDR4_3200_base_quarter_w32},
-    {"DDR4_3200_base_quarter_w64", DDR4::Speed::DDR4_3200_base_quarter_w64},
-    {"DDR4_3734_reduced_tRCD_tRP", DDR4::Speed::DDR4_3734_reduced_tRCD_tRP},
-    {"DDR4_2666_base", DDR4::Speed::DDR4_2666_base},
-    {"DDR4_4000_base", DDR4::Speed::DDR4_4000_base},
-    {"DDR4_4000_base_reduced", DDR4::Speed::DDR4_4000_base_reduced},
-};
-
-
-DDR4::DDR4(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]), 
-    read_latency(speed_entry.nCL + speed_entry.nBL),
-    mySpeed(speed)//daz3
-{
-    if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w8))
-    {
-        channel_width = 8;
-    }
-    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w16))
-    {
-        channel_width = 16;
-    }
-    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w32))
-    {
-        channel_width = 32;
-    }
-    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w64))
-    {
-        channel_width = 64;
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3734_reduced_tRCD_tRP)
-            || int(speed) == int(DDR4::Speed::DDR4_4000_base_reduced))
-    {
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        int _RP = s.nRP;
-        int _REFI = s.nREFI;
-        s.nRAS -= 0.12 * _RCD;
-        s.nRC -= (0.12 * _RCD + 0.5 * _RP);
-        _RCD *= 0.88;
-        s.nRCD = _RCD;
-        _RP *= 0.5;
-        s.nRP = _RP;
-        _REFI *= 4;
-        s.nREFI = _REFI;
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v4) || int(speed) == int(DDR4::Speed::DDR4_3600_ideal_v4) ||
-       int(speed) == int(DDR4::Speed::DDR4_3866_ideal_v4) || int(speed) == int(DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts) ||
-       int(speed) == int(DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts))
-    {
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        _RCD *= 0.75;
-        int diff_RCD = _RCD - s.nRCD;
-        s.nRCD = _RCD;
-        s.nRC = s.nRC + diff_RCD;
-
-        int _RP = s.nRP;
-        _RP *= 0.75;
-        int diff_RP = _RP - s.nRP;
-        s.nRP = _RP;
-
-        s.nRAS = s.nRAS + diff_RCD + diff_RP;
-
-      /*
-	// gagan : 
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        _RCD *= 0.75;
-        int diff_RCD = _RCD - s.nRCD;
-        s.nRCD = _RCD;
-
-        int _RP = s.nRP;
-        _RP *= 0.75;
-        int diff_RP = _RP - s.nRP;
-        s.nRP = _RP;
-
-        s.nRC = s.nRC + diff_RCD + diff_RP;
-        s.nRAS = s.nRAS + diff_RCD + diff_RP;
-      */
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v4s) || int(speed) == int(DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts) ||
-       int(speed) == int(DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts))
-    {
-        SpeedEntry& s = speed_entry;
-        int _RCD = s.nRCD;
-        _RCD -= (_RCD - 1);
-        int diff_RCD = _RCD - s.nRCD;
-        s.nRCD = _RCD;
-        s.nRC = s.nRC + diff_RCD;
-
-        int _RP = s.nRP;
-        _RP -= (_RP - 1);
-        int diff_RP = _RP - s.nRP;
-        s.nRP = _RP;
-
-	s.nRAS = s.nRAS + diff_RCD + diff_RP;
-    }
-
-    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v5a))
-    {
-    }
-
-    
-
-
-    std::cout << "ramulator channel width = " << channel_width << std::endl;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-DDR4::DDR4(const string& org_str, const string& speed_str) :
-    DDR4(org_map[org_str], speed_map[speed_str]) 
-{
-}
-
-void DDR4::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void DDR4::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void DDR4::init_speed()
-{
-    const static int RRDS_TABLE[2][7] = {
-      {4, 4, 4, 4, 4, 4, 4},
-      {5, 5, 6, 7, 9, 10, 11}
-    };
-    const static int RRDL_TABLE[2][7] = {
-        {5, 5, 6, 6, 8},
-        {6, 6, 7, 8, 11}
-    };
-    const static int FAW_TABLE[3][7] = {
-      {16, 16, 16, 16, 16, 16, 16},
-      {20, 22, 23, 26, 34, 38, 41},
-      {28, 28, 32, 36, 48, 54, 58}
-    };
-    const static int RFC_TABLE[int(RefreshMode::MAX)][3][7] = {{   
-	{128, 150, 171, 192, 256, 288, 310},
-	{208, 243, 278, 312, 416, 468, 503},
-	{280, 327, 374, 420, 560, 630, 677}
-        },{
-	{88, 103, 118, 132,  176, 198, 213},
-	{128, 150, 171, 192, 256, 288, 310},
-	{208, 243, 278, 312, 416, 468, 503} 
-        },{
-	{72, 84, 96, 108, 144, 162, 174},
-	{88, 103, 118, 132, 176, 198, 213},
-	{128, 150, 171, 192, 256, 288, 310}  
-        }
-    };
-    const static int REFI_TABLE[7] = {
-      6240, 7280, 8320, 9360, 12480, 14040, 15077
-    };
-    const static int XS_TABLE[3][7] = {
-      {136, 159, 182, 204, 272, 306, 329},
-      {216, 252, 288, 324, 432, 486, 522},
-      {288, 336, 384, 432, 576, 648, 697}
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1600: speed = 0; break;
-        case 1866: speed = 1; break;
-        case 2133: speed = 2; break;
-        case 2400: speed = 3; break;
-        case 2933: break; // gagan
-        case 3200: speed = 4; break;
-        case 3600: speed = 5; break;
-        case 3734: break;
-        case 4000: break;
-        case 2666: break;
-        case 3866: speed = 6; break;
-        case 6400: break;//daz3
-        case 800: break;//daz3
-        case 12800: break;
-        case 25600: break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 2: density = 0; break;
-        case 4: density = 1; break;
-        case 8: density = 2; break;
-        default: assert(false);
-    }
-    // daz3
-    if(mySpeed != DDR4::Speed::DDR4_3200_base 
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v1 
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v2 
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v3
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v4
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v7
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v4s
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v5a
-            && mySpeed != DDR4::Speed::DDR4_3600_ideal_v4
-            && mySpeed != DDR4::Speed::DDR4_3866_ideal_v4
-            && mySpeed != DDR4::Speed::DDR4_3200_ideal_nbr_lbb
-            && mySpeed != DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts
-            && mySpeed != DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w8
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w16
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w32
-            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w64
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w8
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w16
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w32
-            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w64
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w8
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w16
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w32
-            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w64
-            && mySpeed != DDR4::Speed::DDR4_3734_reduced_tRCD_tRP
-            && mySpeed != DDR4::Speed::DDR4_2666_base
-            && mySpeed != DDR4::Speed::DDR4_4000_base
-            && mySpeed != DDR4::Speed::DDR4_4000_base_reduced
-       // gagan
-            && mySpeed != DDR4::Speed::DDR4_2400R_base
-            && mySpeed != DDR4::Speed::DDR4_2400R_ideal_nbr_lbb
-            && mySpeed != DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts
-            && mySpeed != DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts)
-    {
-        speed_entry.nRRDS = RRDS_TABLE[org_entry.dq == 16? 1: 0][speed];
-        speed_entry.nRRDL = RRDL_TABLE[org_entry.dq == 16? 1: 0][speed];
-        speed_entry.nFAW = FAW_TABLE[org_entry.dq == 4? 0: org_entry.dq == 8? 1: 2][speed];
-        speed_entry.nRFC = RFC_TABLE[(int)refresh_mode][density][speed];
-        speed_entry.nREFI = (REFI_TABLE[speed] >> int(refresh_mode));
-        speed_entry.nXS = XS_TABLE[density][speed];
-    }
-    // speed_entry.nRRDS = RRDS_TABLE[org_entry.dq == 16? 1: 0][speed];
-    // speed_entry.nRRDL = RRDL_TABLE[org_entry.dq == 16? 1: 0][speed];
-    // speed_entry.nFAW = FAW_TABLE[org_entry.dq == 4? 0: org_entry.dq == 8? 1: 2][speed];
-    // speed_entry.nRFC = RFC_TABLE[(int)refresh_mode][density][speed];
-    // speed_entry.nREFI = (REFI_TABLE[speed] >> int(refresh_mode));
-    // speed_entry.nXS = XS_TABLE[density][speed];
-}
-
-
-void DDR4::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                else return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        for (auto bg : node->children)
-            for (auto bank: bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                return Command::PREA;
-            }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void DDR4::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR4::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void DDR4::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DDR4>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                bank->state = State::Closed;
-                bank->row_state.clear();
-            }};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR4>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                node->state = State::ActPowerDown;
-                return;
-            }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DDR4>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void DDR4::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDS});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::RDA)].push_back({Command::REF, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::REF, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-    
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-    
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-    /*** Bank Group ***/ 
-    t = timing[int(Level::BankGroup)];
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDL});
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-
-    // daz3
-    std::cout << "rate " << s.rate << std::endl; 
-    std::cout << "freq " << s.freq << std::endl; 
-    std::cout << "tCK " << s.tCK << std::endl; 
-    std::cout << "nBL " << s.nBL << std::endl; 
-    std::cout << "nCCDS " << s.nCCDS << std::endl; 
-    std::cout << "nCCDL " << s.nCCDL << std::endl; 
-    std::cout << "nRTRS " << s.nRTRS << std::endl; 
-    std::cout << "nCL " << s.nCL << std::endl; 
-    std::cout << "nRCD " << s.nRCD << std::endl; 
-    std::cout << "nRP " << s.nRP << std::endl; 
-    std::cout << "nCWL " << s.nCWL << std::endl; 
-    std::cout << "nRAS " << s.nRAS << std::endl; 
-    std::cout << "nRC " << s.nRC << std::endl; 
-    std::cout << "nRTP " << s.nRTP << std::endl; 
-    std::cout << "nWTRS " << s.nWTRS << std::endl; 
-    std::cout << "nWTRL " << s.nWTRL << std::endl; 
-    std::cout << "nWR " << s.nWR << std::endl; 
-    std::cout << "nRRDS " << s.nRRDS << std::endl; 
-    std::cout << "nRRDL " << s.nRRDL << std::endl; 
-    std::cout << "nFAW " << s.nFAW << std::endl; 
-    std::cout << "nRFC " << s.nRFC << std::endl; 
-    std::cout << "nREFI " << s.nREFI << std::endl; 
-    std::cout << "nPD " << s.nPD << std::endl; 
-    std::cout << "nXP " << s.nXP << std::endl; 
-    std::cout << "nXPDLL " << s.nXPDLL << std::endl; 
-    std::cout << "nCKESR " << s.nCKESR << std::endl; 
-    std::cout << "nXS " << s.nXS << std::endl; 
-    std::cout << "nXSDLL " << s.nXSDLL << std::endl; 
-    std::cout << "nRCD " << s.nRCD << std::endl; 
-    std::cout << "nRC " << s.nRC << std::endl; 
-    std::cout << "nRP " << s.nRP << std::endl; 
-    std::cout << "channel_id " << org_entry.count[int(Level::Channel)] << std::endl; 
-    std::cout << "ranks " << org_entry.count[int(Level::Rank)] << std::endl; 
-}
diff --git a/ext/ramulator/Ramulator/src/DDR4.h b/ext/ramulator/Ramulator/src/DDR4.h
deleted file mode 100644
index 612e1f21d..000000000
--- a/ext/ramulator/Ramulator/src/DDR4.h
+++ /dev/null
@@ -1,311 +0,0 @@
-#ifndef __DDR4_H
-#define __DDR4_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DDR4
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    DDR4(Org org, Speed speed);
-    DDR4(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prereq */
-    function<Command(DRAM<DDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        DDR4_2Gb_x4,   DDR4_2Gb_x8,   DDR4_2Gb_x16,
-        DDR4_4Gb_x4,   DDR4_4Gb_x8,   DDR4_4Gb_x16,
-        DDR4_8Gb_x4,   DDR4_8Gb_x8,   DDR4_8Gb_x16,
-        DDR4_4Gb_x8_w16, DDR4_4Gb_x8_w32, DDR4_4Gb_x8_w64,
-        DDR4_4Gb_x8_w8,
-        DDR4_4Gb_x8_4xBank,
-        DDR4_4Gb_x8_2xBank,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {2<<10,  4, {0, 0, 4, 4, 1<<15, 1<<10}}, {2<<10,  8, {0, 0, 4, 4, 1<<14, 1<<10}}, {2<<10, 16, {0, 0, 2, 4, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 4, 4, 1<<16, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10, 16, {0, 0, 2, 4, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 4, 4, 1<<17, 1<<10}}, {8<<10,  8, {0, 0, 4, 4, 1<<16, 1<<10}}, {8<<10, 16, {0, 0, 2, 4, 1<<16, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//16,32,64B cacheline
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//8B cacheline
-        {4<<10,  8, {0, 0, 4, 16, 1<<15, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 8, 1<<15, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DDR4_1600K,
-	DDR4_1600L,
-        DDR4_1866M,
-	DDR4_1866N,
-        DDR4_2133P,
-	DDR4_2133R,
-        DDR4_2400R,
-        // gagan
-        DDR4_2400R_base,
-	DDR4_2400R_ideal_nbr_lbb,
-	DDR4_2933R_ideal_nbr_lbb_ts,
-	DDR4_2933R_ideal_nbr_lbb_sts,
-        // Ramulator
-	DDR4_2400U,
-        DDR4_3200,
-        // daz3
-        DDR4_3200_base,
-        DDR4_3200_ideal_v1,// tRFC=0
-        DDR4_3200_ideal_v2,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v2_modified,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v3,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0
-        DDR4_3200_ideal_v4,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0,tRDC*75%,tRP*75%
-        DDR4_3200_ideal_v7,// tRFC=0
-	DDR4_3200_ideal_v4s,
-	DDR4_3200_ideal_v5a,
-	DDR4_3600_ideal_v4,
-	DDR4_3866_ideal_v4,
-	DDR4_3200_ideal_nbr_lbb, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0
-	DDR4_3866_ideal_nbr_lbb_ts, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0,tRDC*=75%,tRP*=75%
-	DDR4_3866_ideal_nbr_lbb_sts, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0,tRDC=1,tRP=1
-        DDR4_3200_base_half_w8,// for different cacheline size
-        DDR4_3200_base_half_w16,// for different cacheline size
-        DDR4_3200_base_half_w32,
-        DDR4_3200_base_half_w64,
-        DDR4_3200_base_full_w8,// for different cacheline size
-        DDR4_3200_base_full_w16,// for different cacheline size
-        DDR4_3200_base_full_w32,
-        DDR4_3200_base_full_w64,
-        DDR4_3200_base_quarter_w8,// for different cacheline size
-        DDR4_3200_base_quarter_w16,// for different cacheline size
-        DDR4_3200_base_quarter_w32,
-        DDR4_3200_base_quarter_w64,
-        DDR4_3734_reduced_tRCD_tRP,
-        DDR4_2666_base,
-        DDR4_4000_base,
-        DDR4_4000_base_reduced,
-        MAX
-    }mySpeed;
-    // };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        Refresh_2X,
-        Refresh_4X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTRS, nWTRL, nWR;
-        int nRRDS, nRRDL, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL; // XPDLL not found in DDR4??
-        int nCKESR, nXS, nXSDLL; // nXSDLL TBD (nDLLK), nXS = (tRFC+10ns)/tCK
-    } speed_table[int(Speed::MAX)] = {
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 11, 11, 11,  9, 28, 39, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 12, 12, 12,  9, 28, 40, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 13, 13, 13, 10, 32, 45, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 14, 14, 14, 10, 32, 46, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 15, 15, 15, 11, 36, 51, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 16, 16, 16, 11, 36, 52, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 16, 16, 16, 12, 39, 55, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-	// gagan
-        {2400, 1200,   0.833, prefetch_size/2/*DDR*/,   4,    6,    2, 16, 16,  16, 12,  39, 55,   9,    3,     9,  18,   4,   6,   26, 660,  9360,    6,    8,    0,   7,   672,  768},
-        {2400, 1200,   0.833, prefetch_size/2/*DDR*/,   4,    6,    2, 16, 16,  16, 12,  39, 55,   9,    0,     0,   0,   0,   0,    0,   0,  9360,    6,    8,    0,   7,   672,  768},
-	{2933, 2933/2, 0.681, prefetch_size/2/*DDR*/,   4,    7,    2, 16, 20,  20, 15,  47, 67,  11,    0,     0,   0,   0,   0,    0,   0, 11439,    7,   10,    0,   9,   821,  939},
-	{2933, 2933/2, 0.681, prefetch_size/2/*DDR*/,   4,    7,    2, 16, 20,  20, 15,  47, 67,  11,    0,     0,   0,   0,   0,    0,   0, 11439,    7,   10,    0,   9,   821,  939},
-	//rate, freq,    tCK,             nBL,       nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC  nREFI   nPD   nXP  nXPDLL nCKESR nXS  nXSDLL
-	// Ramulator
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 18, 18, 18, 12, 39, 57, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,     10,   2,    22, 22,  22, 16,  56,  78, 12,  4,    12,   24, 8,    10,   40,  0,   0,    8,  10, 0,     8,     0,  0},
-        // daz3
-        // {3200, 1600, 0.625, prefetch_size/2[>DDR<], 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  480, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,  480, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   48,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3600, 1800, 0.555, prefetch_size/2/*DDR*/, 4,      9,   2,    25, 25,  25, 22,  57,  82, 13,  0,     0,   27, 0,     0,    0,    0, 14040,   9,   11,  0,   10, 1008, 1152},
-	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,   29, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,    0, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,    0, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,    0, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-	//{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22,  0,   0, 20,  10,  32, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-	//rate, freq, tCK,  nBL,                    nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI   nPD   nXP  nXPDLL nCKESR nXS  nXSDLL
-
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-
-        {25600, 12800, 0.078125, prefetch_size*2/*DDR*/, 32,      64,   16,    176, 176,  176, 160, 416,  592, 96,  0,     0,   192, 0,     0,    0,    0, 99840,   64,   80,  0,   72,   7168, 8192},
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-        {800, 400, 2.5, prefetch_size/8/*DDR*/, 1,      2,   1,    6, 6,  6, 5,  13,  14, 3,  0,     0,   6, 0,     0,    0,    0, 3120,   2,   3,  0,   3,   224, 256},
-        //rate, freq, tCK,  nBL, nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-        // rate, freq, tCK,  nBL,                  nCCDS  nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL 480 nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-        {3734, 1867, 0.537, prefetch_size/2/*DDR*/, 4,      10,   3,    26, 26,  26, 24,  61,  87, 14,  5,    14,   28, 5,     10,   40,   560, 14563,   12,   12,  0,   11,   1046, 1195},
-        {2666, 1333, 0.75, prefetch_size/2/*DDR*/, 4,        7,   2,    19, 19,  19, 17,  44,  62, 10,  4,    10,   20, 4,     7,    29,   734, 10400,   7,   9,   0,   8,   747, 854},
-        {4000, 2000, 0.5, prefetch_size/2/*DDR*/,  4,       10,   2,    27, 27,  27, 25,  65,  92, 15,  4,    15,   30,  4,    10,   42,   600, 15600,   8,   12,  0,   11,   1120, 1280},
-        {4000, 2000, 0.5, prefetch_size/2/*DDR*/,  4,       10,   2,    27, 27,  27, 25,  65,  92, 15,  4,    15,   30, 4,     10,   42,   600, 15600,   0,    0,  0,    0,      0,    0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__DDR4_H*/
diff --git a/ext/ramulator/Ramulator/src/DDR4.h.backup b/ext/ramulator/Ramulator/src/DDR4.h.backup
deleted file mode 100644
index 02ad58508..000000000
--- a/ext/ramulator/Ramulator/src/DDR4.h.backup
+++ /dev/null
@@ -1,267 +0,0 @@
-#ifndef __DDR4_H
-#define __DDR4_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DDR4
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    DDR4(Org org, Speed speed);
-    DDR4(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prereq */
-    function<Command(DRAM<DDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        DDR4_2Gb_x4,   DDR4_2Gb_x8,   DDR4_2Gb_x16,
-        DDR4_4Gb_x4,   DDR4_4Gb_x8,   DDR4_4Gb_x16,
-        DDR4_8Gb_x4,   DDR4_8Gb_x8,   DDR4_8Gb_x16,
-        DDR4_4Gb_x8_w16, DDR4_4Gb_x8_w32, DDR4_4Gb_x8_w64,
-        DDR4_4Gb_x8_w8,
-        DDR4_4Gb_x8_4xBank,
-        DDR4_4Gb_x8_2xBank,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {2<<10,  4, {0, 0, 4, 4, 1<<15, 1<<10}}, {2<<10,  8, {0, 0, 4, 4, 1<<14, 1<<10}}, {2<<10, 16, {0, 0, 2, 4, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 4, 4, 1<<16, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10, 16, {0, 0, 2, 4, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 4, 4, 1<<17, 1<<10}}, {8<<10,  8, {0, 0, 4, 4, 1<<16, 1<<10}}, {8<<10, 16, {0, 0, 2, 4, 1<<16, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//16,32,64B cacheline
-        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//8B cacheline
-        {4<<10,  8, {0, 0, 4, 16, 1<<15, 1<<10}},
-        {4<<10,  8, {0, 0, 4, 8, 1<<15, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DDR4_1600K, DDR4_1600L,
-        DDR4_1866M, DDR4_1866N,
-        DDR4_2133P, DDR4_2133R,
-        DDR4_2400R, DDR4_2400U,
-        DDR4_3200,
-        // daz3
-        DDR4_3200_base,
-        DDR4_3200_ideal_v1,// tRFC=0
-        DDR4_3200_ideal_v2,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v2_modified,// tRFC=0,tWTR_*=0
-        DDR4_3200_ideal_v3,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0
-        DDR4_3200_ideal_v4,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0,tRDC*75%,tRP*75%
-        DDR4_3200_base_half_w8,// for different cacheline size
-        DDR4_3200_base_half_w16,// for different cacheline size
-        DDR4_3200_base_half_w32,
-        DDR4_3200_base_half_w64,
-        DDR4_3200_base_full_w8,// for different cacheline size
-        DDR4_3200_base_full_w16,// for different cacheline size
-        DDR4_3200_base_full_w32,
-        DDR4_3200_base_full_w64,
-        DDR4_3200_base_quarter_w8,// for different cacheline size
-        DDR4_3200_base_quarter_w16,// for different cacheline size
-        DDR4_3200_base_quarter_w32,
-        DDR4_3200_base_quarter_w64,
-        MAX
-    }mySpeed;
-    // };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        Refresh_2X,
-        Refresh_4X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTRS, nWTRL, nWR;
-        int nRRDS, nRRDL, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL; // XPDLL not found in DDR4??
-        int nCKESR, nXS, nXSDLL; // nXSDLL TBD (nDLLK), nXS = (tRFC+10ns)/tCK
-    } speed_table[int(Speed::MAX)] = {
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 11, 11, 11,  9, 28, 39, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 12, 12, 12,  9, 28, 40, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 13, 13, 13, 10, 32, 45, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 14, 14, 14, 10, 32, 46, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 15, 15, 15, 11, 36, 51, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 16, 16, 16, 11, 36, 52, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 16, 16, 16, 12, 39, 55, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 18, 18, 18, 12, 39, 57, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,     10,   2,    22, 22,  22, 16,  56,  78, 12,  4,    12,   24, 8,    10,   40,  0,   0,    8,  10, 0,     8,     0,  0},
-        // daz3
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   48,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-
-        {25600, 12800, 0.078125, prefetch_size*2/*DDR*/, 32,      64,   16,    176, 176,  176, 160, 416,  592, 96,  0,     0,   192, 0,     0,    0,    0, 99840,   64,   80,  0,   72,   7168, 8192},
-        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-
-        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-        {800, 400, 2.5, prefetch_size/8/*DDR*/, 1,      2,   1,    6, 6,  6, 5,  13,  14, 3,  0,     0,   6, 0,     0,    0,    0, 3120,   2,   3,  0,   3,   224, 256}
-        //rate, f eq, tCK,  nBL, nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-        // //rate, freq, tCK,  nBL,           nCCDS  nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__DDR4_H*/
diff --git a/ext/ramulator/Ramulator/src/DRAM.h b/ext/ramulator/Ramulator/src/DRAM.h
deleted file mode 100644
index 1456b4b50..000000000
--- a/ext/ramulator/Ramulator/src/DRAM.h
+++ /dev/null
@@ -1,451 +0,0 @@
-#ifndef __DRAM_H
-#define __DRAM_H
-
-#include "Statistics.h"
-#include <iostream>
-#include <vector>
-#include <deque>
-#include <map>
-#include <functional>
-#include <algorithm>
-#include <cassert>
-#include <type_traits>
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class DRAM
-{
-public:
-    ScalarStat active_cycles;
-    ScalarStat refresh_cycles;
-    ScalarStat busy_cycles;
-    ScalarStat active_refresh_overlap_cycles;
-
-    ScalarStat serving_requests;
-    ScalarStat average_serving_requests;
-
-    // Constructor
-    DRAM(T* spec, typename T::Level level);
-    ~DRAM();
-
-    // Specification (e.g., DDR3)
-    T* spec;
-
-    // Tree Organization (e.g., Channel->Rank->Bank->Row->Column)
-    typename T::Level level;
-    int id;
-    long size;
-    DRAM* parent;
-    vector<DRAM*> children;
-
-    // State (e.g., Opened, Closed)
-    typename T::State state;
-
-    // State of Rows:
-    // There are too many rows for them to be instantiated individually
-    // Instead, their bank (or an equivalent entity) tracks their state for them
-    map<int, typename T::State> row_state;
-
-    // Insert a node as one of my child nodes
-    void insert(DRAM<T>* child);
-
-    // Decode a command into its "prerequisite" command (if any is needed)
-    typename T::Command decode(typename T::Command cmd, const int* addr);
-
-    // Check whether a command is ready to be scheduled
-    bool check(typename T::Command cmd, const int* addr, long clk);
-
-    // Check whether a command is a row hit
-    bool check_row_hit(typename T::Command cmd, const int* addr);
-
-    // Check whether a row is open
-    bool check_row_open(typename T::Command cmd, const int* addr);
-
-    // Return the earliest clock when a command is ready to be scheduled
-    long get_next(typename T::Command cmd, const int* addr);
-
-    // Update the timing/state of the tree, signifying that a command has been issued
-    void update(typename T::Command cmd, const int* addr, long clk);
-    // Update statistics:
-
-    // Update the number of requests it serves currently
-    void update_serving_requests(const int* addr, int delta, long clk);
-
-    // TIANSHI: current serving requests count
-    int cur_serving_requests = 0;
-    long begin_of_serving = -1;
-    long end_of_serving = -1;
-    long begin_of_cur_reqcnt = -1;
-    long begin_of_refreshing = -1;
-    long end_of_refreshing = -1;
-    std::vector<std::pair<long, long>> refresh_intervals;
-
-    // register statistics
-    void regStats(const std::string& identifier);
-
-    void finish(long dram_cycles);
-
-private:
-    // Constructor
-    DRAM(){}
-
-    // Timing
-    long cur_clk = 0;
-    long next[int(T::Command::MAX)]; // the earliest time in the future when a command could be ready
-    deque<long> prev[int(T::Command::MAX)]; // the most recent history of when commands were issued
-
-    // Lookup table for which commands must be preceded by which other commands (i.e., "prerequisite")
-    // E.g., a read command to a closed bank must be preceded by an activate command
-    function<typename T::Command(DRAM<T>*, typename T::Command cmd, int)>* prereq;
-
-    // SAUGATA: added table for row hits
-    // Lookup table for whether a command is a row hit
-    // E.g., a read command to a closed bank must be preceded by an activate command
-    function<bool(DRAM<T>*, typename T::Command cmd, int)>* rowhit;
-    function<bool(DRAM<T>*, typename T::Command cmd, int)>* rowopen;
-
-    // Lookup table between commands and the state transitions they trigger
-    // E.g., an activate command to a closed bank opens both the bank and the row
-    function<void(DRAM<T>*, int)>* lambda;
-
-    // Lookup table for timing parameters
-    // E.g., activate->precharge: tRAS@bank, activate->activate: tRC@bank
-    vector<typename T::TimingEntry>* timing;
-
-    // Helper Functions
-    void update_state(typename T::Command cmd, const int* addr);
-    void update_timing(typename T::Command cmd, const int* addr, long clk);
-}; /* class DRAM */
-
-
-// register statistics
-template <typename T>
-void DRAM<T>::regStats(const std::string& identifier) {
-    active_cycles
-        .name("active_cycles" + identifier + "_" + to_string(id))
-        .desc("Total active cycles for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        ;
-    refresh_cycles
-        .name("refresh_cycles" + identifier + "_" + to_string(id))
-        .desc("(All-bank refresh only, only valid for rank level) The sum of cycles that is under refresh per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        .flags(Stats::nozero)
-        ;
-    busy_cycles
-        .name("busy_cycles" + identifier + "_" + to_string(id))
-        .desc("(All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        ;
-    active_refresh_overlap_cycles
-        .name("active_refresh_overlap_cycles" + identifier + "_" + to_string(id))
-        .desc("(All-bank refresh only, only valid for rank level) The sum of cycles that are both active and under refresh per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        .flags(Stats::nozero)
-        ;
-    serving_requests
-        .name("serving_requests" + identifier + "_" + to_string(id))
-        .desc("The sum of read and write requests that are served in this DRAM element per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(0)
-        ;
-    average_serving_requests
-        .name("average_serving_requests" + identifier + "_" + to_string(id))
-        .desc("The average of read and write requests that are served in this DRAM element per memory cycle for level " + identifier + "_" + to_string(id))
-        .precision(6)
-        ;
-
-    if (!children.size()) {
-      return;
-    }
-
-    // recursively register children statistics
-    for (auto child : children) {
-      child->regStats(identifier + "_" + to_string(id));
-    }
-}
-
-template <typename T>
-void DRAM<T>::finish(long dram_cycles) {
-  // finalize busy cycles
-  busy_cycles = active_cycles.value() + refresh_cycles.value() - active_refresh_overlap_cycles.value();
-
-  // finalize average serving requests
-  average_serving_requests = serving_requests.value() / dram_cycles;
-
-  if (!children.size()) {
-    return;
-  }
-
-  for (auto child : children) {
-    child->finish(dram_cycles);
-  }
-}
-
-// Constructor
-template <typename T>
-DRAM<T>::DRAM(T* spec, typename T::Level level) :
-    spec(spec), level(level), id(0), parent(NULL)
-{
-
-    state = spec->start[(int)level];
-    prereq = spec->prereq[int(level)];
-    rowhit = spec->rowhit[int(level)];
-    rowopen = spec->rowopen[int(level)];
-    lambda = spec->lambda[int(level)];
-    timing = spec->timing[int(level)];
-
-    fill_n(next, int(T::Command::MAX), -1); // initialize future
-    for (int cmd = 0; cmd < int(T::Command::MAX); cmd++) {
-        int dist = 0;
-        for (auto& t : timing[cmd])
-            dist = max(dist, t.dist);
-
-        if (dist)
-            prev[cmd].resize(dist, -1); // initialize history
-    }
-
-    // try to recursively construct my children
-    int child_level = int(level) + 1;
-    if (child_level == int(T::Level::Row))
-        return; // stop recursion: rows are not instantiated as nodes
-
-    int child_max = spec->org_entry.count[child_level];
-    if (!child_max)
-        return; // stop recursion: the number of children is unspecified
-
-    // recursively construct my children
-    for (int i = 0; i < child_max; i++) {
-        DRAM<T>* child = new DRAM<T>(spec, typename T::Level(child_level));
-        child->parent = this;
-        child->id = i;
-        children.push_back(child);
-    }
-
-}
-
-template <typename T>
-DRAM<T>::~DRAM()
-{
-    for (auto child: children)
-        delete child;
-}
-
-// Insert
-template <typename T>
-void DRAM<T>::insert(DRAM<T>* child)
-{
-    child->parent = this;
-    child->id = children.size();
-    children.push_back(child);
-}
-
-// Decode
-template <typename T>
-typename T::Command DRAM<T>::decode(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (prereq[int(cmd)]) {
-        typename T::Command prereq_cmd = prereq[int(cmd)](this, cmd, child_id);
-        if (prereq_cmd != T::Command::MAX)
-            return prereq_cmd; // stop recursion: there is a prerequisite at this level
-    }
-
-    if (child_id < 0 || !children.size())
-        return cmd; // stop recursion: there were no prequisites at any level
-
-    // recursively decode at my child
-    return children[child_id]->decode(cmd, addr);
-}
-
-
-// Check
-template <typename T>
-bool DRAM<T>::check(typename T::Command cmd, const int* addr, long clk)
-{
-    if (next[int(cmd)] != -1 && clk < next[int(cmd)])
-        return false; // stop recursion: the check failed at this level
-
-    int child_id = addr[int(level)+1];
-    if (child_id < 0 || level == spec->scope[int(cmd)] || !children.size())
-        return true; // stop recursion: the check passed at all levels
-
-    // recursively check my child
-    return children[child_id]->check(cmd, addr, clk);
-}
-
-// SAUGATA: added function to check whether a command is a row hit
-// Check row hits
-template <typename T>
-bool DRAM<T>::check_row_hit(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (rowhit[int(cmd)]) {
-        return rowhit[int(cmd)](this, cmd, child_id);  // stop recursion: there is a row hit at this level
-    }
-
-    if (child_id < 0 || !children.size())
-        return false; // stop recursion: there were no row hits at any level
-
-    // recursively check for row hits at my child
-    return children[child_id]->check_row_hit(cmd, addr);
-}
-
-template <typename T>
-bool DRAM<T>::check_row_open(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (rowopen[int(cmd)]) {
-        return rowopen[int(cmd)](this, cmd, child_id);  // stop recursion: there is a row hit at this level
-    }
-
-    if (child_id < 0 || !children.size())
-        return false; // stop recursion: there were no row hits at any level
-
-    // recursively check for row hits at my child
-    return children[child_id]->check_row_open(cmd, addr);
-}
-
-template <typename T>
-long DRAM<T>::get_next(typename T::Command cmd, const int* addr)
-{
-    long next_clk = max(cur_clk, next[int(cmd)]);
-    auto node = this;
-    for (int l = int(level); l < int(spec->scope[int(cmd)]) && node->children.size() && addr[l + 1] >= 0; l++){
-        node = node->children[addr[l + 1]];
-        next_clk = max(next_clk, node->next[int(cmd)]);
-    }
-    return next_clk;
-}
-
-// Update
-template <typename T>
-void DRAM<T>::update(typename T::Command cmd, const int* addr, long clk)
-{
-    cur_clk = clk;
-    update_state(cmd, addr);
-    update_timing(cmd, addr, clk);
-}
-
-
-// Update (State)
-template <typename T>
-void DRAM<T>::update_state(typename T::Command cmd, const int* addr)
-{
-    int child_id = addr[int(level)+1];
-    if (lambda[int(cmd)])
-        lambda[int(cmd)](this, child_id); // update this level
-
-    if (level == spec->scope[int(cmd)] || !children.size())
-        return; // stop recursion: updated all levels
-
-    // recursively update my child
-    children[child_id]->update_state(cmd, addr);
-}
-
-
-// Update (Timing)
-template <typename T>
-void DRAM<T>::update_timing(typename T::Command cmd, const int* addr, long clk)
-{
-    // I am not a target node: I am merely one of its siblings
-    if (id != addr[int(level)]) {
-        for (auto& t : timing[int(cmd)]) {
-            if (!t.sibling)
-                continue; // not an applicable timing parameter
-
-            assert (t.dist == 1);
-
-            long future = clk + t.val;
-            next[int(t.cmd)] = max(next[int(t.cmd)], future); // update future
-        }
-
-        return; // stop recursion: only target nodes should be recursed
-    }
-
-    // I am a target node
-    if (prev[int(cmd)].size()) {
-        prev[int(cmd)].pop_back();  // FIXME TIANSHI why pop back?
-        prev[int(cmd)].push_front(clk); // update history
-    }
-
-    for (auto& t : timing[int(cmd)]) {
-        if (t.sibling)
-            continue; // not an applicable timing parameter
-
-        long past = prev[int(cmd)][t.dist-1];
-        if (past < 0)
-            continue; // not enough history
-
-        long future = past + t.val;
-        next[int(t.cmd)] = max(next[int(t.cmd)], future); // update future
-        // TIANSHI: for refresh statistics
-        if (spec->is_refreshing(cmd) && spec->is_opening(t.cmd)) {
-          assert(past == clk);
-          begin_of_refreshing = clk;
-          end_of_refreshing = max(end_of_refreshing, next[int(t.cmd)]);
-          refresh_cycles += end_of_refreshing - clk;
-          if (cur_serving_requests > 0) {
-            refresh_intervals.push_back(make_pair(begin_of_refreshing, end_of_refreshing));
-          }
-        }
-    }
-
-    // Some commands have timings that are higher that their scope levels, thus
-    // we do not stop at the cmd's scope level
-    if (!children.size())
-        return; // stop recursion: updated all levels
-
-    // recursively update *all* of my children
-    for (auto child : children)
-        child->update_timing(cmd, addr, clk);
-
-}
-
-template <typename T>
-void DRAM<T>::update_serving_requests(const int* addr, int delta, long clk) {
-  assert(id == addr[int(level)]);
-  assert(delta == 1 || delta == -1);
-  // update total serving requests
-  if (begin_of_cur_reqcnt != -1 && cur_serving_requests > 0) {
-    serving_requests += (clk - begin_of_cur_reqcnt) * cur_serving_requests;
-    active_cycles += clk - begin_of_cur_reqcnt;
-  }
-  // update begin of current request number
-  begin_of_cur_reqcnt = clk;
-  cur_serving_requests += delta;
-  assert(cur_serving_requests >= 0);
-
-  if (delta == 1 && cur_serving_requests == 1) {
-    // transform from inactive to active
-    begin_of_serving = clk;
-    if (end_of_refreshing > begin_of_serving) {
-      active_refresh_overlap_cycles += end_of_refreshing - begin_of_serving;
-    }
-  } else if (cur_serving_requests == 0) {
-    // transform from active to inactive
-    assert(begin_of_serving != -1);
-    assert(delta == -1);
-    active_cycles += clk - begin_of_cur_reqcnt;
-    end_of_serving = clk;
-
-    for (const auto& ref: refresh_intervals) {
-      active_refresh_overlap_cycles += min(end_of_serving, ref.second) - ref.first;
-    }
-    refresh_intervals.clear();
-  }
-
-  int child_id = addr[int(level) + 1];
-  // We only count the level bank or the level higher than bank
-  if (child_id < 0 || !children.size() || (int(level) > int(T::Level::Bank)) ) {
-    return;
-  }
-  children[child_id]->update_serving_requests(addr, delta, clk);
-}
-
-} /* namespace ramulator */
-
-#endif /* __DRAM_H */
diff --git a/ext/ramulator/Ramulator/src/DSARP.cpp b/ext/ramulator/Ramulator/src/DSARP.cpp
deleted file mode 100644
index 803f96a7a..000000000
--- a/ext/ramulator/Ramulator/src/DSARP.cpp
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * DSARP.cpp
- *
- * This a re-implementation of the refresh mechanisms proposed in Chang et al.,
- * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA
- * 2014.
- *
- *  Created on: Mar 16, 2015
- *      Author: kevincha
- */
-
-#include <vector>
-#include <functional>
-#include <cassert>
-#include <math.h>
-#include "DSARP.h"
-#include "DRAM.h"
-
-using namespace std;
-using namespace ramulator;
-
-string DSARP::standard_name = "DSARP";
-string DSARP::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Sa", "Ro", "Co"};
-
-map<string, enum DSARP::Org> DSARP::org_map = {
-  {"DSARP_8Gb_x8", DSARP::Org::DSARP_8Gb_x8},
-  {"DSARP_16Gb_x9", DSARP::Org::DSARP_16Gb_x8},
-  {"DSARP_32Gb_x8", DSARP::Org::DSARP_32Gb_x8},
-};
-
-map<string, enum DSARP::Speed> DSARP::speed_map = {
-  {"DSARP_1333", DSARP::Speed::DSARP_1333},
-};
-
-DSARP::DSARP(Org org, Speed speed, Type type, int n_sa) :
-  type(type),
-  org_entry(org_table[int(org)]),
-  speed_entry(speed_table[int(speed)]),
-  read_latency(speed_entry.nCL + speed_entry.nBL),
-  n_sa(n_sa)
-{
-  init_speed();
-  init_prereq();
-  init_rowhit(); // SAUGATA: added row hit function
-  init_rowopen();
-  init_lambda();
-  init_timing();
-
-  // All mechanisms are built on top of REFpb, except for REFab
-  b_ref_rank = false;
-  switch(int(type)){
-    case int(Type::REFAB):
-      standard_name = "REFAB";
-      b_ref_rank = true;
-      break;
-    case int(Type::REFPB): standard_name = "REFPB"; break;
-    case int(Type::DARP):  standard_name = "DARP"; break;
-    case int(Type::SARP):  standard_name = "SARP"; break;
-    case int(Type::DSARP): standard_name = "DSARP"; break;
-  }
-
-  // Update the SA count (is power of 2, within [1, 128]) and row count
-  assert(n_sa && n_sa <= 128 && (n_sa & (n_sa-1)) == 0);
-  org_entry.count[int(Level::SubArray)] = n_sa;
-  long tmp = long(org_entry.dq) * org_entry.count[int(Level::Bank)] *
-    n_sa * org_entry.count[int(Level::Column)];
-  org_entry.count[int(Level::Row)] = long(org_entry.size) * (1<<20) / tmp;
-
-  // Change the translation for refresh requests
-  if (!b_ref_rank)
-    translate[int(Request::Type::REFRESH)] = Command::REFPB;
-}
-
-DSARP::DSARP(const string& org_str, const string& speed_str, Type type, int n_sa) :
-  DSARP(org_map[org_str], speed_map[speed_str], type, n_sa) {}
-
-void DSARP::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void DSARP::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-
-void DSARP::init_speed()
-{
-  /* Numbers are in DRAM cycles */
-
-  // The numbers for RFCab are extrapolated based on past and current DRAM
-  // generation since they are not available yet. Details on the extrapolation
-  // are in the paper.
-  const static int RFCAB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-    {234}, {354}, {594},
-  };
-
-  // These are extrapolated using the RFCab/REFpb ratio from the LPDDR standard, which is 2.16.
-  const static int RFCPB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-    {109}, {164}, {275}
-  };
-
-  // High temperature mode (32ms retention time)
-  const static int REFI_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-    {2600},
-  };
-
-  const static int REFIPB_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-    {325},
-  };
-
-  int speed = 0, density = 0;
-  switch (speed_entry.rate) {
-    case 1333: speed = 0; break;
-    default: assert(false);
-  };
-  switch (org_entry.size >> 10){
-    case 8: density = 0; break;
-    case 16: density = 1; break;
-    case 32: density = 2; break;
-    default: assert(false && "Unknown density");
-  }
-
-  speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-  speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-  speed_entry.nREFI = REFI_TABLE[int(refresh_mode)][speed];
-  speed_entry.nREFIpb = REFIPB_TABLE[int(refresh_mode)][speed];
-}
-
-void DSARP::init_prereq()
-{
-  // RD
-  prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::PowerUp): return Command::MAX;
-      case int(State::ActPowerDown): return Command::PDX;
-      case int(State::PrePowerDown): return Command::PDX;
-      case int(State::SelfRefresh): return Command::SRX;
-      default: assert(false);
-    }};
-  // Rank transitions to Bank
-  prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::Closed): return Command::ACT;
-      case int(State::Opened):
-        // Really is the subarray state. If the subarray matches, check the row ID
-        if (node->row_state.find(id) != node->row_state.end())
-          return Command::MAX;
-        return Command::PRE;
-      default: assert(false);
-    }};
-  // Bank transitions to Subarray
-  prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::Closed): return Command::ACT;
-      case int(State::Opened):
-        // Actual row state
-        if (node->row_state.find(id) != node->row_state.end())
-          return cmd;
-        return Command::PRE;
-      default: assert(false);
-    }};
-
-  // WR
-  prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-  prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-  prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-
-  // REF -- on all banks
-  prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    for (auto bank : node->children) {
-      if (bank->state == State::Closed)
-        continue;
-      return Command::PREA;
-    }
-    return Command::REF;};
-
-  // REF -- per bank
-  prereq[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    if (node->state == State::Closed) return Command::REFPB;
-    else return Command::PRE;};
-
-  // PD
-  prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::PowerUp): return Command::PDE;
-      case int(State::ActPowerDown): return Command::PDE;
-      case int(State::PrePowerDown): return Command::PDE;
-      case int(State::SelfRefresh): return Command::SRX;
-      default: assert(false);
-    }};
-
-  // SR
-  prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-    switch (int(node->state)) {
-      case int(State::PowerUp): return Command::SRE;
-      case int(State::ActPowerDown): return Command::PDX;
-      case int(State::PrePowerDown): return Command::PDX;
-      case int(State::SelfRefresh): return Command::SRE;
-      default: assert(false);
-    }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void DSARP::init_rowhit()
-{
-  // RD
-  rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-      switch (int(node->state)){
-          case int(State::Closed): return false;
-          case int(State::Opened):
-              if (node->row_state.find(id) != node->row_state.end()) return true;
-              else return false;
-          default: assert(false);
-      }};
-  // WR
-  rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-}
-
-void DSARP::init_rowopen()
-{
-  // RD
-  rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-      switch (int(node->state)){
-          case int(State::Closed): return false;
-          case int(State::Opened): return true;
-          default: assert(false);
-      }};
-  // WR
-  rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-}
-
-void DSARP::init_lambda()
-{
-  // RANK
-  lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DSARP>* node, int id) {
-    node->row_state.clear();
-    for (auto bank : node->children) {
-      bank->state = State::Closed;
-      bank->row_state.clear();
-      for (auto sa : bank->children){
-        sa->state = State::Closed;
-        sa->row_state.clear();}}};
-  lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DSARP>* node, int id) {};
-
-  // Power down related commands
-  lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, int id) {
-    for (auto bank : node->children) {
-      if (bank->state == State::Closed)
-        continue;
-      node->state = State::ActPowerDown;
-      return;
-    }
-    node->state = State::PrePowerDown;};
-  lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::PowerUp;};
-  lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::SelfRefresh;};
-  lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::PowerUp;};
-
-  // Open a row
-  lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Opened;
-    node->row_state[id] = State::Opened;};
-  lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Opened;
-    node->row_state[id] = State::Opened;};
-
-  // Close a bank
-  lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();
-    for (auto sa : node->children){
-      sa->state = State::Closed;
-      sa->row_state.clear();}};
-
-  lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DSARP>* node, int id) {};
-  lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DSARP>* node, int id) {};
-
-  // Make sure the bank is closed after the column command
-  lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-
-  lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-
-  // Nothing much, just make sure the bank is closed
-  lambda[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<DSARP>* node, int id) {
-    assert(node->state == State::Closed);
-    node->row_state.clear();};
-
-  // COL
-  lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-  lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<DSARP>* node, int id) {
-    node->state = State::Closed;
-    node->row_state.clear();};
-
-  // PowerDown -- this has not been tested
-  lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, int id) {
-    for (auto bank : node->children)
-      for (auto sa : bank->children) {
-        if (sa->state == State::Closed)
-          continue;
-        node->state = State::ActPowerDown;
-        return;
-      }
-    node->state = State::PrePowerDown;};
-}
-
-void DSARP::init_timing()
-{
-  SpeedEntry& s = speed_entry;
-  vector<TimingEntry> *t;
-
-  /*** Channel ***/
-  t = timing[int(Level::Channel)];
-
-  // CAS <-> CAS
-  t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-  t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-  t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-  t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-  t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-  t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-  t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-  /*** Rank ***/
-  t = timing[int(Level::Rank)];
-
-  // CAS <-> CAS
-  t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-  t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-  t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-  t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-  t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-  t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-  t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-
-  // READ to WRITE
-  t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-  t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-  t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-
-  // WRITE to READ
-  t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-  t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-  t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-  t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-  // CAS <-> CAS (between sibling ranks)
-  t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-
-  t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-  t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-  t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-  t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-  t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-  // CAS <-> PREA
-  t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-  t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-  // CAS <-> PD
-  t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-  t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-  t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-  t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-  t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-  // RAS <-> RAS
-  t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-  t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-  t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-  t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRPab});
-
-  // RAS <-> REF
-  t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-  t[int(Command::PREA)].push_back({Command::REF, 1, s.nRPab});
-  t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-  // RAS <-> PD
-  t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-  t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-  // RAS <-> SR
-  t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRPpb});
-  t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRPab});
-  t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-  // REF <-> REF
-  t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-  t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-  t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-  // REF <-> PD
-  t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-  t[int(Command::REFPB)].push_back({Command::PDE, 1, 1});
-  t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-  t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-  // REF <-> SR
-  t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-  t[int(Command::SRX)].push_back({Command::REFPB, 1, s.nXS});
-
-  // PD <-> PD
-  t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-  t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-  // PD <-> SR
-  t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-  t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-  // SR <-> SR
-  t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-  t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-  // REFPB
-  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb });
-
-  /*** Bank ***/
-  t = timing[int(Level::Bank)];
-
-  // CAS <-> RAS
-  t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-  t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-  t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-  t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-  t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-  t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-  t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-  t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-
-  // RAS <-> RAS
-  t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-  t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-  t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-  t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-  // Cannot overlap REFPB
-  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb });
-
-  // B/w banks
-  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb, true});
-  t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-  t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-  // REFPB -- these are used when SARP is not enabled
-  if (!(type == Type::DSARP || type == Type::SARP)) {
-    t[int(Command::REFPB)].push_back( { Command::ACT, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::RD, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::RDA, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::WR, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::WRA, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::PRE, 1, s.nRFCpb });
-    t[int(Command::REFPB)].push_back( { Command::PREA, 1, s.nRFCpb });
-  }
-
-  /*** SubArray ***/
-  if (type == Type::DSARP || type == Type::SARP) {
-    t = timing[int(Level::SubArray)];
-
-    // between different subarrays -> Increase RRD
-    t[int(Command::ACT)].push_back({Command::REFPB, 1,
-        (int)ceil(((double)s.nRRD)*nRRD_factor), true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1,
-        (int)ceil(((double)s.nRRD)*nRRD_factor), true});
-
-    // Same subarray
-    t[int(Command::REF)].push_back( { Command::ACT, 1, s.nRFCab });
-    t[int(Command::REFPB)].push_back( { Command::ACT, 1, s.nRFCpb });
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back( { Command::RD, 1, s.nRCD });
-    t[int(Command::ACT)].push_back( { Command::RDA, 1, s.nRCD });
-    t[int(Command::ACT)].push_back( { Command::WR, 1, s.nRCD });
-    t[int(Command::ACT)].push_back( { Command::WRA, 1, s.nRCD });
-
-    t[int(Command::RD)].push_back( { Command::PRE, 1, s.nRTP });
-    t[int(Command::WR)].push_back(
-        { Command::PRE, 1, s.nCWL + s.nBL + s.nWR });
-
-    t[int(Command::RDA)].push_back( { Command::ACT, 1, s.nRTP + s.nRPpb });
-    t[int(Command::WRA)].push_back(
-        { Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb });
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back( { Command::ACT, 1, s.nRC });
-    t[int(Command::ACT)].push_back( { Command::PRE, 1, s.nRAS });
-    t[int(Command::PRE)].push_back( { Command::ACT, 1, s.nRPpb });
-    t[int(Command::PRE)].push_back( { Command::REFPB, 1, s.nRPpb });
-    t[int(Command::PRE)].push_back( { Command::REF, 1, s.nRPpb });
-
-    // Enforcing timings such that there's no subarray parallelism
-    // between sibling subarrays for demand requests
-    t[int(Command::ACT)].push_back( { Command::ACT, 1, s.nRC, true });
-    t[int(Command::PRE)].push_back( { Command::ACT, 1, s.nRPpb, true });
-    t[int(Command::RDA)].push_back( { Command::ACT, 1, s.nRTP + s.nRPpb,
-        true });
-    t[int(Command::WRA)].push_back(
-        { Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb, true });
-  }
-}
diff --git a/ext/ramulator/Ramulator/src/DSARP.h b/ext/ramulator/Ramulator/src/DSARP.h
deleted file mode 100644
index be02e71e3..000000000
--- a/ext/ramulator/Ramulator/src/DSARP.h
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * DSARP.h
- *
- * This a re-implementation of the refresh mechanisms proposed in Chang et al.,
- * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA
- * 2014.
- *
- * Note: the re-implementation of DSARP has not been widely tested across
- * different benchmarks and parameters. However, timing violations of
- * SARP/DSARP have been checked.
- *
- * Usage: The "type" determines the refresh mechanisms.
- * Examples:
- * DSARP::Org test_org = DSARP::Org::DSARP_8Gb_x8;
- *
- * DSARP* dsddr3_ab = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::REFAB, 8);
- *
- * DSARP* dsddr3_pb = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::REFPB, 8);
- *
- * DSARP* dsddr3_darp = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::DARP, 8);
- *
- * DSARP* dsddr3_sarp = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::SARP, 8);
- *
- * DSARP* dsddr3_dsarp = new DSARP(test_org,
- * DSARP::Speed::DSARP_1333, DSARP::Type::DSARP, 8);
- *
- *  Created on: Mar 16, 2015
- *      Author: kevincha
- */
-
-#ifndef DSARP_H_
-#define DSARP_H_
-
-#include <vector>
-#include <functional>
-#include "DRAM.h"
-#include "Request.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-class DSARP
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    enum class Type;
-    DSARP(Org org, Speed speed, Type type, int n_sa);
-    DSARP(const string& org_str, const string& speed_str, Type type, int n_sa);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    enum class Type : int
-    {
-        REFAB, REFPB, DARP, SARP, DSARP, MAX
-    } type;
-
-    /* Level */
-    // NOTE: Although there's subarray, there's no SALP at all. This is used
-    // for parallelizing REF and demand accesses.
-    enum class Level : int
-    {
-      Channel, Rank, Bank, SubArray, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, REFPB, PDE, PDX, SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "REFPB",
-        "PDE", "PDX", "SRE", "SRX"
-    };
-
-    // SubArray scope for REFPB to propagate the timings
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<DSARP>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<DSARP>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<DSARP>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<DSARP>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        // These are the configurations used in the original paper, essentially DDR3
-        DSARP_8Gb_x8,
-        DSARP_16Gb_x8,
-        DSARP_32Gb_x8,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        // IMPORTANT: Do not change the count for channel/rank, where is set to
-        // 0 now. 0 means that this a flexible configuration that is not part
-        // of the spec, but rather something to change at a higher level
-        // (main.cpp).
-        {8<<10, 8,  {0, 0, 8, 0, 1<<16, 1<<11}},
-        {16<<10, 8, {0, 0, 8, 0, 1<<17, 1<<11}},
-        {32<<10, 8, {0, 0, 8, 0, 1<<18, 1<<11}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        DSARP_1333,
-        MAX
-    };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 16; // 16n prefetch DDR
-    int channel_width = 32;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRPpb, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI, nREFIpb;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-        //int nCKE, nXP; // CKE value n/a
-        //int nSR, nXSR; // tXSR = tRFCab + 7.5ns
-    } speed_table[int(Speed::MAX)] = {
-      {1333,
-      (400.0/3)*5, (3/0.4)/5,
-       4, 4, 2,
-       9, 9, 8, 9, 7,
-       24, 33,
-       5, 5, 10,
-       5, 30,
-       0, 0, 0, 0, // set in DSARP.cpp
-       4, 4, 16,
-       5, 114, 512},
-    }, speed_entry;
-
-    int read_latency;
-
-    // Number of subarrays -- mainly for SARP. Doesn't affect others.
-    int n_sa;
-
-    // Refresh rank?
-    bool b_ref_rank;
-
-    // Increase RRD b/w REF and ACT when they go to the same bank (SARP)
-    double nRRD_factor = 1.138;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /* DSARP_H_ */
diff --git a/ext/ramulator/Ramulator/src/GDDR5.cpp b/ext/ramulator/Ramulator/src/GDDR5.cpp
deleted file mode 100644
index 45a17e99b..000000000
--- a/ext/ramulator/Ramulator/src/GDDR5.cpp
+++ /dev/null
@@ -1,357 +0,0 @@
-#include "GDDR5.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string GDDR5::standard_name = "GDDR5";
-string GDDR5::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-
-
-map<string, enum GDDR5::Org> GDDR5::org_map = {
-    {"GDDR5_512Mb_x16", GDDR5::Org::GDDR5_512Mb_x16}, {"GDDR5_512Mb_x32", GDDR5::Org::GDDR5_512Mb_x32},
-    {"GDDR5_1Gb_x16", GDDR5::Org::GDDR5_1Gb_x16}, {"GDDR5_1Gb_x32", GDDR5::Org::GDDR5_1Gb_x32},
-    {"GDDR5_2Gb_x16", GDDR5::Org::GDDR5_2Gb_x16}, {"GDDR5_2Gb_x32", GDDR5::Org::GDDR5_2Gb_x32},
-    {"GDDR5_4Gb_x16", GDDR5::Org::GDDR5_4Gb_x16}, {"GDDR5_4Gb_x32", GDDR5::Org::GDDR5_4Gb_x32},
-    {"GDDR5_8Gb_x16", GDDR5::Org::GDDR5_8Gb_x16}, {"GDDR5_8Gb_x32", GDDR5::Org::GDDR5_8Gb_x32},
-};
-
-map<string, enum GDDR5::Speed> GDDR5::speed_map = {
-    {"GDDR5_4000", GDDR5::Speed::GDDR5_4000}, {"GDDR5_4500", GDDR5::Speed::GDDR5_4500},
-    {"GDDR5_5000", GDDR5::Speed::GDDR5_5000}, {"GDDR5_5500", GDDR5::Speed::GDDR5_5500},
-    {"GDDR5_6000", GDDR5::Speed::GDDR5_6000}, {"GDDR5_6500", GDDR5::Speed::GDDR5_6500},
-    {"GDDR5_7000", GDDR5::Speed::GDDR5_7000},
-};
-
-GDDR5::GDDR5(Org org, Speed speed) : 
-    org_entry(org_table[int(org)]), 
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-GDDR5::GDDR5(const string& org_str, const string& speed_str) :
-    GDDR5(org_map[org_str], speed_map[speed_str]) 
-{
-}
-
-void GDDR5::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void GDDR5::set_rank_number(int rank) {
-  assert((rank == 1) && "GDDR5 rank number is fixed to 1.");
-}
-
-void GDDR5::init_speed()
-{
-    const int REFIL_TABLE[int(Speed::MAX)] = {3900, 4388, 4875, 5363, 5850, 6338, 6825};
-    const int REFIS_TABLE[int(Speed::MAX)] = {1900, 2138, 2375, 2613, 2850, 3088, 3325};
-    const int RFC_TABLE[5][int(Speed::MAX)] = {
-        // using DDR3 values
-        {90, 102, 113, 124, 135, 147, 158},
-        {110, 124, 138, 152, 165, 179, 193},
-        {160, 180, 200, 220, 240, 260, 280},
-        {260, 293, 325, 358, 390, 423, 455},
-        {350, 394, 438, 482, 525, 569, 613}
-    };
-    int speed = 0, density = 0;
-    switch (speed_entry.rate){
-        case 4000: speed = 0; break;
-        case 4500: speed = 1; break;
-        case 5000: speed = 2; break;
-        case 5500: speed = 3; break;
-        case 6000: speed = 4; break;
-        case 6500: speed = 5; break;
-        case 7000: speed = 6; break;
-        default: assert(0);
-    }
-    switch (org_entry.size >> 9){
-        case 1: density = 0; break;
-        case 2: density = 1; break;
-        case 4: density = 2; break;
-        case 8: density = 3; break;
-        case 16: density = 4; break;
-        default: assert(0);
-    }
-    if (org_entry.size <= 1024) speed_entry.nREFI = REFIL_TABLE[speed];
-    else speed_entry.nREFI = REFIS_TABLE[speed];
-    speed_entry.nRFC = RFC_TABLE[density][speed];
-}
-
-
-void GDDR5::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                return Command::PREA;
-            }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void GDDR5::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void GDDR5::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void GDDR5::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<GDDR5>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                bank->state = State::Closed;
-                bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<GDDR5>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<GDDR5>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<GDDR5>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                node->state = State::ActPowerDown;
-                return;
-            }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<GDDR5>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void GDDR5::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXPN});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::ACT, 32, s.n32AW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nPPD});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXPN});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXPN});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXPN});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-    
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXPN});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXPN});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-    
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    // Bank group level
-    t = timing[int(Level::BankGroup)];
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCDW});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCDW});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/GDDR5.h b/ext/ramulator/Ramulator/src/GDDR5.h
deleted file mode 100644
index 23e929d33..000000000
--- a/ext/ramulator/Ramulator/src/GDDR5.h
+++ /dev/null
@@ -1,213 +0,0 @@
-#ifndef __GDDR5_H
-#define __GDDR5_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class GDDR5
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    GDDR5(Org org, Speed speed);
-    GDDR5(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PDE, PDX,  SRE, SRX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<GDDR5>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<GDDR5>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<GDDR5>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<GDDR5>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        GDDR5_512Mb_x16, GDDR5_512Mb_x32,
-        GDDR5_1Gb_x16,   GDDR5_1Gb_x32,
-        GDDR5_2Gb_x16,   GDDR5_2Gb_x32,
-        GDDR5_4Gb_x16,   GDDR5_4Gb_x32,
-        GDDR5_8Gb_x16,   GDDR5_8Gb_x32,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        // fixed to have 1 rank
-        // in GDDR5 the column address is unique for a burst. e.g. 64 column addresses correspond with
-        // 256 column addresses actually. So we multiply 8 to the original address bit number in JEDEC standard
-        {  512, 16, {0, 1, 4, 2, 1<<12, 1<<(7+3)}}, {  512, 32, {0, 1, 4, 2, 1<<12, 1<<(6+3)}},
-        {1<<10, 16, {0, 1, 4, 4, 1<<12, 1<<(7+3)}}, {1<<10, 32, {0, 1, 4, 4, 1<<12, 1<<(6+3)}},
-        {2<<10, 16, {0, 1, 4, 4, 1<<13, 1<<(7+3)}}, {2<<10, 32, {0, 1, 4, 4, 1<<13, 1<<(6+3)}},
-        {4<<10, 16, {0, 1, 4, 4, 1<<14, 1<<(7+3)}}, {2<<10, 32, {0, 1, 4, 4, 1<<14, 1<<(6+3)}},
-        {8<<10, 16, {0, 1, 4, 4, 1<<14, 1<<(8+3)}}, {8<<10, 32, {0, 1, 4, 4, 1<<14, 1<<(7+3)}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        GDDR5_4000, GDDR5_4500,
-        GDDR5_5000, GDDR5_5500,
-        GDDR5_6000, GDDR5_6500,
-        GDDR5_7000,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch QDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL;
-        int nCL, nRCDR, nRCDW, nRP, nCWL;
-        int nRAS, nRC;
-        int nPPD, nRTP, nWTR, nWR;
-        int nRRD, nFAW, n32AW;
-        int nRFC, nREFI;
-        int nPD, nXPN, nLK;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-        {4000,  8*500/4,  8.0/8, 2, 2, 3, 12, 12, 10, 12, 3, 28, 40, 1, 2, 5, 12,  6, 23, 184, 0, 0, 10, 10, 0, 0, 0, 0},
-        {4500,  9*500/4,  8.0/9, 2, 2, 3, 14, 14, 12, 14, 4, 32, 46, 2, 2, 6, 14,  7, 26, 207, 0, 0, 10, 10, 0, 0, 0, 0},
-        {5000, 10*500/4, 8.0/10, 2, 2, 3, 15, 15, 13, 15, 4, 35, 50, 2, 2, 7, 15,  7, 29, 230, 0, 0, 10, 10, 0, 0, 0, 0},
-        {5500, 11*500/4, 8.0/11, 2, 2, 3, 17, 17, 14, 17, 5, 39, 56, 2, 2, 7, 17,  8, 32, 253, 0, 0, 10, 10, 0, 0, 0, 0},
-        {6000, 12*500/4, 8.0/12, 2, 2, 3, 18, 18, 15, 18, 5, 42, 60, 2, 2, 8, 18,  9, 35, 276, 0, 0, 10, 10, 0, 0, 0, 0},
-        {6500, 13*500/4, 8.0/13, 2, 2, 3, 20, 20, 17, 20, 5, 46, 66, 2, 2, 9, 20,  9, 38, 299, 0, 0, 10, 10, 0, 0, 0, 0},
-        {7000, 14*500/4, 8.0/14, 2, 2, 3, 21, 21, 18, 21, 6, 49, 70, 2, 2, 9, 21, 10, 41, 322, 0, 0, 10, 10, 0, 0, 0, 0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__GDDR5_H*/
diff --git a/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp b/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp
deleted file mode 100644
index 780c12ebd..000000000
--- a/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-#include <map>
-
-#include "Gem5Wrapper.h"
-#include "Config.h"
-#include "Request.h"
-#include "MemoryFactory.h"
-#include "Memory.h"
-#include "DDR3.h"
-#include "DDR4.h"
-#include "LPDDR3.h"
-#include "LPDDR4.h"
-#include "GDDR5.h"
-#include "WideIO.h"
-#include "WideIO2.h"
-#include "HBM.h"
-#include "SALP.h"
-
-using namespace ramulator;
-
-static map<string, function<MemoryBase *(const Config&, int, bool)> > name_to_func = {
-    {"DDR3", &MemoryFactory<DDR3>::create},
-    {"DDR4", &MemoryFactory<DDR4>::create},
-    {"LPDDR3", &MemoryFactory<LPDDR3>::create},
-    {"LPDDR4", &MemoryFactory<LPDDR4>::create},
-    {"GDDR5", &MemoryFactory<GDDR5>::create}, 
-    {"WideIO", &MemoryFactory<WideIO>::create},
-    {"WideIO2", &MemoryFactory<WideIO2>::create},
-    {"HBM", &MemoryFactory<HBM>::create},
-    {"SALP-1", &MemoryFactory<SALP>::create},
-    {"SALP-2", &MemoryFactory<SALP>::create},
-    {"SALP-MASA", &MemoryFactory<SALP>::create},
-};
-
-
-Gem5Wrapper::Gem5Wrapper(const Config& configs, int cacheline)
-{
-    const string& std_name = configs["standard"];
-    assert(name_to_func.find(std_name) != name_to_func.end() && "unrecognized standard name");
-    mem = name_to_func[std_name](configs, cacheline, false);
-    tCK = mem->clk_ns();
-    // daz3:  one wrapper
-    tickCount = 0;
-}
-
-
-Gem5Wrapper::~Gem5Wrapper() {
-    delete mem;
-}
-
-void Gem5Wrapper::tick()
-{
-    // mem->tick();
-    // daz3
-    if(tickCount % 2 == 0)
-    {
-        mem->tick();
-    }
-    tickCount++;
-}
-
-bool Gem5Wrapper::send(Request req)
-{
-  return mem->send(req);
-}
-
-void Gem5Wrapper::finish(void) {
-    mem->finish();
-}
diff --git a/ext/ramulator/Ramulator/src/Gem5Wrapper.h b/ext/ramulator/Ramulator/src/Gem5Wrapper.h
deleted file mode 100644
index 0745d38f3..000000000
--- a/ext/ramulator/Ramulator/src/Gem5Wrapper.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef __GEM5_WRAPPER_H
-#define __GEM5_WRAPPER_H
-
-#include <string>
-
-#include "Config.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-class Request;
-class MemoryBase;
-
-class Gem5Wrapper 
-{
-private:
-    MemoryBase *mem;
-// daz3: one wrapper
-    long tickCount;
-public:
-    double tCK;
-    Gem5Wrapper(const Config& configs, int cacheline);
-    ~Gem5Wrapper();
-    void tick();
-    bool send(Request req);
-    void finish(void);
-};
-
-} /*namespace ramulator*/
-
-#endif /*__GEM5_WRAPPER_H*/
diff --git a/ext/ramulator/Ramulator/src/HBM.cpp b/ext/ramulator/Ramulator/src/HBM.cpp
deleted file mode 100644
index 8ba7ef6af..000000000
--- a/ext/ramulator/Ramulator/src/HBM.cpp
+++ /dev/null
@@ -1,360 +0,0 @@
-#include "HBM.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string HBM::standard_name = "HBM";
-string HBM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-
-map<string, enum HBM::Org> HBM::org_map = {
-    {"HBM_1Gb", HBM::Org::HBM_1Gb},
-    {"HBM_2Gb", HBM::Org::HBM_2Gb},
-    {"HBM_4Gb", HBM::Org::HBM_4Gb},
-};
-
-map<string, enum HBM::Speed> HBM::speed_map = {
-    {"HBM_1Gbps", HBM::Speed::HBM_1Gbps},
-};
-
-HBM::HBM(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-HBM::HBM(const string& org_str, const string& speed_str) :
-    HBM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void HBM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void HBM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-
-void HBM::init_speed()
-{
-    const static int RFC_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {55, 80, 130}
-    };
-    const static int REFI1B_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {64, 128, 256}
-    };
-    const static int XS_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {60, 85, 135}
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1000: speed = 0; break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 1: density = 0; break;
-        case 2: density = 1; break;
-        case 4: density = 2; break;
-        default: assert(false);
-    }
-    speed_entry.nRFC = RFC_TABLE[speed][density];
-    speed_entry.nREFI1B = REFI1B_TABLE[speed][density];
-    speed_entry.nXS = XS_TABLE[speed][density];
-}
-
-
-void HBM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                else return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        for (auto bg : node->children)
-            for (auto bank: bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                return Command::PREA;
-            }
-        return Command::REF;};
-
-    // REFSB
-    prereq[int(Level::Bank)][int(Command::REFSB)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        if (node->state == State::Closed) return Command::REFSB;
-        return Command::PRE;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void HBM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void HBM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void HBM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<HBM>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                bank->state = State::Closed;
-                bank->row_state.clear();
-            }};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<HBM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<HBM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<HBM>* node, int id) {
-        for (auto bg : node->children)
-            for (auto bank : bg->children) {
-                if (bank->state == State::Closed)
-                    continue;
-                node->state = State::ActPowerDown;
-                return;
-            }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<HBM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void HBM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDS});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-    /*** Bank Group ***/
-    t = timing[int(Level::BankGroup)];
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDL});
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCDR});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCDW});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCDW});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-
-    // REFSB
-    t[int(Command::PRE)].push_back({Command::REFSB, 1, s.nRP});
-    t[int(Command::REFSB)].push_back({Command::REFSB, 1, s.nRFC});
-    t[int(Command::REFSB)].push_back({Command::ACT, 1, s.nRFC});
-}
diff --git a/ext/ramulator/Ramulator/src/HBM.h b/ext/ramulator/Ramulator/src/HBM.h
deleted file mode 100644
index 76501be43..000000000
--- a/ext/ramulator/Ramulator/src/HBM.h
+++ /dev/null
@@ -1,201 +0,0 @@
-#ifndef __HBM_H
-#define __HBM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class HBM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    HBM(Org org, Speed speed);
-    HBM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /* Level */
-    enum class Level : int
-    {
-        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    {
-        ACT, PRE,   PREA,
-        RD,  WR,    RDA, WRA,
-        REF, REFSB, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    // REFSB and REF is not compatible, choose one or the other.
-    // REFSB can be issued to banks in any order, as long as REFI1B
-    // is satisfied for all banks
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE",   "PREA",
-        "RD",  "WR",    "RDA",  "WRA",
-        "REF", "REFSB", "PDE",  "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFSB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prereq */
-    function<Command(DRAM<HBM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<HBM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<HBM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<HBM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    { // per channel density here. Each stack comes with 8 channels
-        HBM_1Gb,
-        HBM_2Gb,
-        HBM_4Gb,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {1<<10, 128, {0, 0, 4, 2, 1<<13, 1<<(6+1)}},
-        {2<<10, 128, {0, 0, 4, 2, 1<<14, 1<<(6+1)}},
-        {4<<10, 128, {0, 0, 4, 4, 1<<14, 1<<(6+1)}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        HBM_1Gbps,
-        MAX
-    };
-
-    int prefetch_size = 4; // burst length could be 2 and 4 (choose 4 here), 2n prefetch
-    int channel_width = 128;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCDS, nCCDL;
-        int nCL, nRCDR, nRCDW, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTRS, nWTRL, nWR;
-        int nRRDS, nRRDL, nFAW;
-        int nRFC, nREFI, nREFI1B;
-        int nPD, nXP;
-        int nCKESR, nXS;
-    } speed_table[int(Speed::MAX)] = {
-        {1000, 500, 2.0, 2, 2, 3, 7, 7, 6, 7, 4, 17, 24, 7, 2, 4, 8, 4, 5, 20, 0, 1950, 0, 5, 5, 5, 0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__HBM_H*/
diff --git a/ext/ramulator/Ramulator/src/LPDDR3.cpp b/ext/ramulator/Ramulator/src/LPDDR3.cpp
deleted file mode 100644
index 63f47a531..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR3.cpp
+++ /dev/null
@@ -1,378 +0,0 @@
-#include "LPDDR3.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string LPDDR3::standard_name = "LPDDR3";
-string LPDDR3::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum LPDDR3::Org> LPDDR3::org_map = {
-    {"LPDDR3_4Gb_x16", LPDDR3::Org::LPDDR3_4Gb_x16}, {"LPDDR3_4Gb_x32", LPDDR3::Org::LPDDR3_4Gb_x32},
-    {"LPDDR3_6Gb_x16", LPDDR3::Org::LPDDR3_6Gb_x16}, {"LPDDR3_6Gb_x32", LPDDR3::Org::LPDDR3_6Gb_x32},
-    {"LPDDR3_8Gb_x16", LPDDR3::Org::LPDDR3_8Gb_x16}, {"LPDDR3_8Gb_x32", LPDDR3::Org::LPDDR3_8Gb_x32},
-    {"LPDDR3_12Gb_x16", LPDDR3::Org::LPDDR3_12Gb_x16}, {"LPDDR3_12Gb_x32", LPDDR3::Org::LPDDR3_12Gb_x32},
-    {"LPDDR3_16Gb_x16", LPDDR3::Org::LPDDR3_16Gb_x16}, {"LPDDR3_16Gb_x32", LPDDR3::Org::LPDDR3_16Gb_x32},
-};
-
-map<string, enum LPDDR3::Speed> LPDDR3::speed_map = {
-    {"LPDDR3_1333", LPDDR3::Speed::LPDDR3_1333},
-    {"LPDDR3_1600", LPDDR3::Speed::LPDDR3_1600},
-    {"LPDDR3_1866", LPDDR3::Speed::LPDDR3_1866},
-    {"LPDDR3_2133", LPDDR3::Speed::LPDDR3_2133},
-};
-
-LPDDR3::LPDDR3(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-LPDDR3::LPDDR3(const string& org_str, const string& speed_str) :
-    LPDDR3(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void LPDDR3::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void LPDDR3::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void LPDDR3::init_speed()
-{
-    // 12Gb/16Gb RFCab/RFCpb TBD
-
-    const static int RFCPB_TABLE[3][4] = {
-        {40, 48, 56, 64},
-        {60, 72, 84, 96},
-        {60, 72, 84, 96}
-    };
-
-    const static int RFCAB_TABLE[3][4] = {
-        {87, 104, 122, 139},
-        {140, 168, 196, 224},
-        {140, 168, 196, 224}
-    };
-
-    const static int XSR_TABLE[3][4] = {
-        {94, 112, 131, 150},
-        {147, 176, 206, 235},
-        {147, 176, 206, 235}
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1333: speed = 0; break;
-        case 1600: speed = 1; break;
-        case 1866: speed = 2; break;
-        case 2133: speed = 3; break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 4: density = 0; break;
-        case 6: density = 1; break;
-        case 8: density = 2; break;
-        default: assert(false && "12Gb/16Gb is still TBD");
-    }
-    speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-    speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-    speed_entry.nXSR = XSR_TABLE[density][speed];
-}
-
-
-void LPDDR3::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PRA;
-        }
-        return Command::REF;};
-
-    // REFPB
-    prereq[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-      if (node->state == State::Closed) return Command::REFPB;
-        else return Command::PRE;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PD;
-            case int(State::ActPowerDown): return Command::PD;
-            case int(State::PrePowerDown): return Command::PD;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void LPDDR3::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR3::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR3::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<LPDDR3>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<LPDDR3>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<LPDDR3>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<LPDDR3>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void LPDDR3::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    // section 4.7.3 table 11
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PRA
-    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRPab});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRPab});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRPab});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-    t[int(Command::REFPB)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-
-    // PD <-> PD
-    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-    // between different banks
-    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-    // REFSB
-    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-}
diff --git a/ext/ramulator/Ramulator/src/LPDDR3.h b/ext/ramulator/Ramulator/src/LPDDR3.h
deleted file mode 100644
index 6f95a613d..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR3.h
+++ /dev/null
@@ -1,210 +0,0 @@
-#ifndef __LPDDR3_H
-#define __LPDDR3_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class LPDDR3
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    LPDDR3(Org org, Speed speed);
-    LPDDR3(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PRA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, REFPB, PD, PDX,  SREF, SREFX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PRA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "REFPB", "PD", "PDX",  "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PD, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<LPDDR3>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<LPDDR3>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<LPDDR3>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<LPDDR3>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        LPDDR3_4Gb_x16, LPDDR3_4Gb_x32,
-        LPDDR3_6Gb_x16, LPDDR3_6Gb_x32,
-        LPDDR3_8Gb_x16, LPDDR3_8Gb_x32,
-        LPDDR3_12Gb_x16, LPDDR3_12Gb_x32,
-        LPDDR3_16Gb_x16, LPDDR3_16Gb_x32,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {4<<10, 16, {0, 0, 8, 1<<14, 1<<11}}, {4<<10, 32, {0, 0, 8, 1<<14, 1<<10}},
-        {6<<10, 16, {0, 0, 8, 3<<13, 1<<11}}, {6<<10, 32, {0, 0, 8, 3<<13, 1<<10}},
-        {8<<10, 16, {0, 0, 8, 1<<15, 1<<11}}, {8<<10, 32, {0, 0, 8, 1<<15, 1<<10}},
-        {12<<10, 16, {0, 0, 8, 3<<13, 1<<12}}, {12<<10, 32, {0, 0, 8, 3<<13, 1<<11}},
-        {16<<10, 16, {0, 0, 8, 1<<15, 1<<12}}, {16<<10, 32, {0, 0, 8, 1<<15, 1<<11}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        LPDDR3_1333,
-        LPDDR3_1600,
-        LPDDR3_1866,
-        LPDDR3_2133,
-        MAX
-    };
-
-    int prefetch_size = 8; // 16n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS, nDQSCK;
-        int nCL, nRCD, nRPpb, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI;
-        int nCKE, nXP; // CKE is PD, LPDDR3 has no DLL
-        int nCKESR, nXSR; // tXSR = tRFCab + 10ns
-    } speed_table[int(Speed::MAX)] = {
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2, 2, 10, 12, 12, 14, 6, 28, 40, 5, 5, 10,  7, 34, 0, 0, 2600, 5, 5, 10, 0},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 2, 12, 15, 15, 17, 6, 34, 48, 6, 6, 12,  8, 40, 0, 0, 3120, 6, 6, 12, 0},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 3, 14, 17, 17, 20, 8, 40, 56, 7, 7, 14, 10, 47, 0, 0, 3640, 7, 7, 14, 0},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 3, 16, 20, 20, 23, 8, 45, 64, 8, 8, 16, 11, 54, 0, 0, 4160, 8, 8, 16, 0}
-    }, speed_entry;
-
-    // LPDDR3 defines {fast, typical, slow} timing for tRCD and tRP. (typ)
-    // WL as diff. values for set A/B (A)
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__LPDDR3_H*/
diff --git a/ext/ramulator/Ramulator/src/LPDDR4.cpp b/ext/ramulator/Ramulator/src/LPDDR4.cpp
deleted file mode 100644
index d0510c260..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR4.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-#include "LPDDR4.h"
-#include "DRAM.h"
-
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string LPDDR4::standard_name = "LPDDR4";
-string LPDDR4::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum LPDDR4::Org> LPDDR4::org_map = {
-    {"LPDDR4_4Gb_x16", LPDDR4::Org::LPDDR4_4Gb_x16},
-    {"LPDDR4_6Gb_x16", LPDDR4::Org::LPDDR4_6Gb_x16},
-    {"LPDDR4_8Gb_x16", LPDDR4::Org::LPDDR4_8Gb_x16},
-};
-
-map<string, enum LPDDR4::Speed> LPDDR4::speed_map = {
-    {"LPDDR4_1600", LPDDR4::Speed::LPDDR4_1600},
-    {"LPDDR4_2400", LPDDR4::Speed::LPDDR4_2400},
-    {"LPDDR4_3200", LPDDR4::Speed::LPDDR4_3200},
-};
-
-LPDDR4::LPDDR4(Org org, Speed speed)
-    : org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-LPDDR4::LPDDR4(const string& org_str, const string& speed_str) :
-    LPDDR4(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void LPDDR4::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void LPDDR4::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-
-void LPDDR4::init_speed()
-{
-    // 12Gb/16Gb RFCab/RFCpb TBD
-    // Numbers are in DRAM cycles
-    const static int RFCPB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-        {48,  72,  96},
-        {72, 108, 144},
-        {72, 108, 144}
-    };
-
-    const static int RFCAB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-        {104, 156, 208},
-        {144, 216, 288},
-        {144, 216, 288}
-    };
-
-    const static int REFI_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-        {3124, 4685, 6247},
-        {1563, 2344, 3125},
-        { 782, 1172, 1563}
-    };
-
-    const static int XSR_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-        {110, 165, 220},
-        {150, 225, 300},
-        {150, 225, 300},
-    };
-
-    int speed = 0, density = 0;
-    switch (speed_entry.rate) {
-        case 1600: speed = 0; break;
-        case 2400: speed = 1; break;
-        case 3200: speed = 2; break;
-        default: assert(false);
-    };
-    switch (org_entry.size >> 10){
-        case 2: density = 0; break;
-        case 3: density = 1; break;
-        case 4: density = 2; break;
-        default: assert(false && "12Gb/16Gb is still TBD");
-    }
-    speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-    speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-    speed_entry.nREFI = REFI_TABLE[int(refresh_mode)][speed];
-    speed_entry.nXSR = XSR_TABLE[density][speed];
-}
-
-
-void LPDDR4::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void LPDDR4::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR4::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void LPDDR4::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<LPDDR4>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<LPDDR4>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<LPDDR4>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<LPDDR4>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void LPDDR4::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PREA
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRPab});
-    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nPPD});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRPab});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-    t[int(Command::PREA)].push_back({Command::SREF, 1, s.nRPab});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::REFPB)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PDE, 1, s.nXSR});
-
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nSR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-    // between different banks
-    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-    // REFPB
-    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-}
diff --git a/ext/ramulator/Ramulator/src/LPDDR4.h b/ext/ramulator/Ramulator/src/LPDDR4.h
deleted file mode 100644
index d8b736bcd..000000000
--- a/ext/ramulator/Ramulator/src/LPDDR4.h
+++ /dev/null
@@ -1,224 +0,0 @@
-#ifndef __LPDDR4_H
-#define __LPDDR4_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class LPDDR4
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    LPDDR4(Org org, Speed speed);
-    LPDDR4(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /* Level */
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /* Command */
-    enum class Command : int
-    { 
-        ACT, PRE, PREA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, REFPB, PDE, PDX, SREF, SREFX, 
-        MAX
-    };
-    // Due to multiplexing on the cmd/addr bus:
-    //      ACT, RD, WR, RDA, WRA take 4 cycles
-    //      PRE, PREA, REF, REFPB, PDE, PDX, SREF, SREFX take 2 cycles
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "REFPB", "PDE", "PDX", "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<LPDDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<LPDDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<LPDDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<LPDDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        // this is per-die density, actual per-chan density is half
-        LPDDR4_4Gb_x16,
-        LPDDR4_6Gb_x16,
-        LPDDR4_8Gb_x16,
-        // LPDDR4_12Gb_x16, // tRFC TBD
-        // LPDDR4_16Gb_x16, // tRFC TBD
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {3<<10, 16, {0, 0, 8, 3<<13, 1<<10}},
-        {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-
-    /* Speed */
-    enum class Speed : int
-    {
-        LPDDR4_1600,
-        LPDDR4_2400,
-        LPDDR4_3200,
-        MAX
-    };
-
-    enum class RefreshMode : int
-    {
-        Refresh_1X,
-        Refresh_2X,
-        Refresh_4X,
-        MAX
-    } refresh_mode = RefreshMode::Refresh_1X;
-
-    int prefetch_size = 16; // 16n prefetch DDR
-    int channel_width = 32;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS, nDQSCK;
-        int nCL, nRCD, nRPpb, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nPPD, nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI;
-        int nCKE, nXP; // CKE value n/a
-        int nSR, nXSR; // tXSR = tRFCab + 7.5ns
-    } speed_table[int(Speed::MAX)] = {
-        // LPDDR4 is 16n prefetch. Latencies in JESD209-4 counts from and to 
-        // the end of each command, I've converted them as if all commands take
-        // only 1 cycle like other standards
-        // CL-RCD-RPpb are set to the same value althrough CL is not explicitly specified.
-        // CWL is made up, half of CL.
-        // calculated from 10.2 core timing table 89
-        {1600, 400.0*2, 2.5/2, 8, 8, 2, 1, 15+3, 15, 15-2, 17-2,  8+3, 34, 47,  8+2,  8, 15-1, 4,  8, 32, 0, 0, 0, 0,  6, 12, 0},
-        {2400, 400.0*3, 2.5/3, 8, 8, 2, 2, 22+3, 22, 22-2, 26-2, 11+3, 51, 71,  9+2, 12, 22-1, 4, 12, 48, 0, 0, 0, 0,  9, 18, 0},
-        {3200, 400.0*4, 2.5/4, 8, 8, 2, 3, 29+3, 29, 29-2, 34-2, 15+3, 68, 95, 12+2, 16, 29-1, 4, 16, 64, 0, 0, 0, 0, 12, 24, 0}
-    }, speed_entry;
-
-    // LPDDR4 defines {fast, typical, slow} timing for tRCD and tRP. (typ)
-    // WL as diff. values for set A/B (A)
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__LPDDR4_H*/
diff --git a/ext/ramulator/Ramulator/src/Main.cpp b/ext/ramulator/Ramulator/src/Main.cpp
deleted file mode 100644
index e46b49ed8..000000000
--- a/ext/ramulator/Ramulator/src/Main.cpp
+++ /dev/null
@@ -1,277 +0,0 @@
-#include "Processor.h"
-#include "Config.h"
-#include "Controller.h"
-#include "SpeedyController.h"
-#include "Memory.h"
-#include "DRAM.h"
-#include "Statistics.h"
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <stdlib.h>
-#include <functional>
-#include <map>
-
-/* Standards */
-#include "Gem5Wrapper.h"
-#include "DDR3.h"
-#include "DDR4.h"
-#include "DSARP.h"
-#include "GDDR5.h"
-#include "LPDDR3.h"
-#include "LPDDR4.h"
-#include "WideIO.h"
-#include "WideIO2.h"
-#include "HBM.h"
-#include "SALP.h"
-#include "ALDRAM.h"
-#include "TLDRAM.h"
-#include "STTMRAM.h"
-#include "PCM.h"
-
-using namespace std;
-using namespace ramulator;
-
-bool ramulator::warmup_complete = false;
-
-template<typename T>
-void run_dramtrace(const Config& configs, Memory<T, Controller>& memory, const char* tracename) {
-
-    /* initialize DRAM trace */
-    Trace trace(tracename);
-
-    /* run simulation */
-    bool stall = false, end = false;
-    int reads = 0, writes = 0, clks = 0;
-    long addr = 0;
-    Request::Type type = Request::Type::READ;
-    map<int, int> latencies;
-    auto read_complete = [&latencies](Request& r){latencies[r.depart - r.arrive]++;};
-
-    Request req(addr, type, read_complete);
-
-    while (!end || memory.pending_requests()){
-        if (!end && !stall){
-            end = !trace.get_dramtrace_request(addr, type);
-        }
-
-        if (!end){
-            req.addr = addr;
-            req.type = type;
-            stall = !memory.send(req);
-            if (!stall){
-                if (type == Request::Type::READ) reads++;
-                else if (type == Request::Type::WRITE) writes++;
-            }
-        }
-        else {
-            memory.set_high_writeq_watermark(0.0f); // make sure that all write requests in the
-                                                    // write queue are drained
-        }
-
-        memory.tick();
-        clks ++;
-        Stats::curTick++; // memory clock, global, for Statistics
-    }
-    // This a workaround for statistics set only initially lost in the end
-    memory.finish();
-    Stats::statlist.printall();
-
-}
-
-template <typename T>
-void run_cputrace(const Config& configs, Memory<T, Controller>& memory, const std::vector<const char *>& files)
-{
-    int cpu_tick = configs.get_cpu_tick();
-    int mem_tick = configs.get_mem_tick();
-    auto send = bind(&Memory<T, Controller>::send, &memory, placeholders::_1);
-    Processor proc(configs, files, send, memory);
-
-    long warmup_insts = configs.get_warmup_insts();
-    bool is_warming_up = (warmup_insts != 0);
-
-    for(long i = 0; is_warming_up; i++){
-        proc.tick();
-        Stats::curTick++;
-        if (i % cpu_tick == (cpu_tick - 1))
-            for (int j = 0; j < mem_tick; j++)
-                memory.tick();
-
-        is_warming_up = false;
-        for(int c = 0; c < proc.cores.size(); c++){
-            if(proc.cores[c]->get_insts() < warmup_insts)
-                is_warming_up = true;
-        }
-
-        if (is_warming_up && proc.has_reached_limit()) {
-            printf("WARNING: The end of the input trace file was reached during warmup. "
-                    "Consider changing warmup_insts in the config file. \n");
-            break;
-        }
-
-    }
-
-    warmup_complete = true;
-    printf("Warmup complete! Resetting stats...\n");
-    Stats::reset_stats();
-    proc.reset_stats();
-    assert(proc.get_insts() == 0);
-
-    printf("Starting the simulation...\n");
-
-    int tick_mult = cpu_tick * mem_tick;
-    for (long i = 0; ; i++) {
-        if (((i % tick_mult) % mem_tick) == 0) { // When the CPU is ticked cpu_tick times,
-                                                 // the memory controller should be ticked mem_tick times
-            proc.tick();
-            Stats::curTick++; // processor clock, global, for Statistics
-
-            if (configs.calc_weighted_speedup()) {
-                if (proc.has_reached_limit()) {
-                    break;
-                }
-            } else {
-                if (configs.is_early_exit()) {
-                    if (proc.finished())
-                    break;
-                } else {
-                if (proc.finished() && (memory.pending_requests() == 0))
-                    break;
-                }
-            }
-        }
-
-        if (((i % tick_mult) % cpu_tick) == 0) // TODO_hasan: Better if the processor ticks the memory controller
-            memory.tick();
-
-    }
-    // This a workaround for statistics set only initially lost in the end
-    memory.finish();
-    Stats::statlist.printall();
-}
-
-template<typename T>
-void start_run(const Config& configs, T* spec, const vector<const char*>& files) {
-  // initiate controller and memory
-  int C = configs.get_channels(), R = configs.get_ranks();
-  // Check and Set channel, rank number
-  spec->set_channel_number(C);
-  spec->set_rank_number(R);
-  std::vector<Controller<T>*> ctrls;
-  for (int c = 0 ; c < C ; c++) {
-    DRAM<T>* channel = new DRAM<T>(spec, T::Level::Channel);
-    channel->id = c;
-    channel->regStats("");
-    Controller<T>* ctrl = new Controller<T>(configs, channel, false); // gagan : enable_debug set to false
-    ctrls.push_back(ctrl);
-  }
-  Memory<T, Controller> memory(configs, ctrls);
-
-  assert(files.size() != 0);
-  if (configs["trace_type"] == "CPU") {
-    run_cputrace(configs, memory, files);
-  } else if (configs["trace_type"] == "DRAM") {
-    run_dramtrace(configs, memory, files[0]);
-  }
-}
-
-int main(int argc, const char *argv[])
-{
-    if (argc < 2) {
-        printf("Usage: %s <configs-file> --mode=cpu,dram [--stats <filename>] <trace-filename1> <trace-filename2>\n"
-            "Example: %s ramulator-configs.cfg --mode=cpu cpu.trace cpu.trace\n", argv[0], argv[0]);
-        return 0;
-    }
-
-    Config configs(argv[1]);
-
-    const std::string& standard = configs["standard"];
-    assert(standard != "" || "DRAM standard should be specified.");
-
-    const char *trace_type = strstr(argv[2], "=");
-    trace_type++;
-    if (strcmp(trace_type, "cpu") == 0) {
-      configs.add("trace_type", "CPU");
-    } else if (strcmp(trace_type, "dram") == 0) {
-      configs.add("trace_type", "DRAM");
-    } else {
-      printf("invalid trace type: %s\n", trace_type);
-      assert(false);
-    }
-
-    int trace_start = 3;
-    string stats_out;
-    if (strcmp(argv[trace_start], "--stats") == 0) {
-      Stats::statlist.output(argv[trace_start+1]);
-      stats_out = argv[trace_start+1];
-      trace_start += 2;
-    } else {
-      Stats::statlist.output(standard+".stats");
-      stats_out = standard + string(".stats");
-    }
-
-    // A separate file defines mapping for easy config.
-    if (strcmp(argv[trace_start], "--mapping") == 0) {
-      configs.add("mapping", argv[trace_start+1]);
-      trace_start += 2;
-    } else {
-      configs.add("mapping", "defaultmapping");
-    }
-
-    std::vector<const char*> files(&argv[trace_start], &argv[argc]);
-    configs.set_core_num(argc - trace_start);
-
-    if (standard == "DDR3") {
-      DDR3* ddr3 = new DDR3(configs["org"], configs["speed"]);
-      start_run(configs, ddr3, files);
-    } else if (standard == "DDR4") {
-      DDR4* ddr4 = new DDR4(configs["org"], configs["speed"]);
-      start_run(configs, ddr4, files);
-    } else if (standard == "SALP-MASA") {
-      SALP* salp8 = new SALP(configs["org"], configs["speed"], "SALP-MASA", configs.get_subarrays());
-      start_run(configs, salp8, files);
-    } else if (standard == "LPDDR3") {
-      LPDDR3* lpddr3 = new LPDDR3(configs["org"], configs["speed"]);
-      start_run(configs, lpddr3, files);
-    } else if (standard == "LPDDR4") {
-      // total cap: 2GB, 1/2 of others
-      LPDDR4* lpddr4 = new LPDDR4(configs["org"], configs["speed"]);
-      start_run(configs, lpddr4, files);
-    } else if (standard == "GDDR5") {
-      GDDR5* gddr5 = new GDDR5(configs["org"], configs["speed"]);
-      start_run(configs, gddr5, files);
-    } else if (standard == "HBM") {
-      HBM* hbm = new HBM(configs["org"], configs["speed"]);
-      start_run(configs, hbm, files);
-    } else if (standard == "WideIO") {
-      // total cap: 1GB, 1/4 of others
-      WideIO* wio = new WideIO(configs["org"], configs["speed"]);
-      start_run(configs, wio, files);
-    } else if (standard == "WideIO2") {
-      // total cap: 2GB, 1/2 of others
-      WideIO2* wio2 = new WideIO2(configs["org"], configs["speed"], configs.get_channels());
-      wio2->channel_width *= 2;
-      start_run(configs, wio2, files);
-    } else if (standard == "STTMRAM") {
-      STTMRAM* sttmram = new STTMRAM(configs["org"], configs["speed"]);
-      start_run(configs, sttmram, files);
-    } else if (standard == "PCM") {
-      PCM* pcm = new PCM(configs["org"], configs["speed"]);
-      start_run(configs, pcm, files);
-    }
-    // Various refresh mechanisms
-      else if (standard == "DSARP") {
-      DSARP* dsddr3_dsarp = new DSARP(configs["org"], configs["speed"], DSARP::Type::DSARP, configs.get_subarrays());
-      start_run(configs, dsddr3_dsarp, files);
-    } else if (standard == "ALDRAM") {
-      ALDRAM* aldram = new ALDRAM(configs["org"], configs["speed"]);
-      start_run(configs, aldram, files);
-    } else if (standard == "TLDRAM") {
-      TLDRAM* tldram = new TLDRAM(configs["org"], configs["speed"], configs.get_subarrays());
-      start_run(configs, tldram, files);
-    }
-
-    printf("Simulation done. Statistics written to %s\n", stats_out.c_str());
-
-    return 0;
-}
diff --git a/ext/ramulator/Ramulator/src/Memory.h b/ext/ramulator/Ramulator/src/Memory.h
deleted file mode 100644
index 9fefa0345..000000000
--- a/ext/ramulator/Ramulator/src/Memory.h
+++ /dev/null
@@ -1,870 +0,0 @@
-#ifndef __MEMORY_H
-#define __MEMORY_H
-
-#include "Config.h"
-#include "DRAM.h"
-#include "Request.h"
-#include "Controller.h"
-#include "SpeedyController.h"
-#include "Statistics.h"
-#include "GDDR5.h"
-#include "HBM.h"
-#include "LPDDR3.h"
-#include "LPDDR4.h"
-#include "WideIO2.h"
-#include "DSARP.h"
-#include <vector>
-#include <functional>
-#include <cmath>
-#include <cassert>
-#include <tuple>
-
-using namespace std;
-
-typedef vector<unsigned int> MapSrcVector;
-typedef map<unsigned int, MapSrcVector > MapSchemeEntry;
-typedef map<unsigned int, MapSchemeEntry> MapScheme;
-
-namespace ramulator
-{
-
-class MemoryBase{
-public:
-    MemoryBase() {}
-    virtual ~MemoryBase() {}
-    virtual double clk_ns() = 0;
-    virtual void tick() = 0;
-    virtual bool send(Request req) = 0;
-    virtual int pending_requests() = 0;
-    virtual void finish(void) = 0;
-    virtual long page_allocator(long addr, int coreid) = 0;
-    virtual void record_core(int coreid) = 0;
-    virtual void set_high_writeq_watermark(const float watermark) = 0;
-    virtual void set_low_writeq_watermark(const float watermark) = 0;
-};
-
-template <class T, template<typename> class Controller = Controller >
-class Memory : public MemoryBase
-{
-protected:
-  ScalarStat dram_capacity;
-  ScalarStat num_dram_cycles;
-  ScalarStat num_incoming_requests;
-  VectorStat num_read_requests;
-  VectorStat num_write_requests;
-  ScalarStat ramulator_active_cycles;
-  VectorStat incoming_requests_per_channel;
-  VectorStat incoming_read_reqs_per_channel;
-  // gagan : demand and prefetch read reqs
-  VectorStat incoming_demand_read_reqs_per_channel;
-  VectorStat incoming_prefetch_read_reqs_per_channel;
-  VectorStat prefetch_to_demand_read_promotion;
-
-  ScalarStat physical_page_replacement;
-  ScalarStat maximum_bandwidth;
-  ScalarStat in_queue_req_num_sum;
-  ScalarStat in_queue_read_req_num_sum;
-  ScalarStat in_queue_write_req_num_sum;
-  ScalarStat in_queue_req_num_avg;
-  ScalarStat in_queue_read_req_num_avg;
-  ScalarStat in_queue_write_req_num_avg;
-
-#ifndef INTEGRATED_WITH_GEM5
-  VectorStat record_read_requests;
-  VectorStat record_write_requests;
-#endif
-
-  long max_address;
-  MapScheme mapping_scheme;
-  
-public:
-    enum class Type {
-        ChRaBaRoCo,
-        RoBaRaCoCh,
-        RoRaBaChCo,//daz3
-        RoRaBaChCo_XOR,
-        RoRaBaChCo_XOR_chint,
-	intel_quad_chan,
-        RoRaBaChCo_XOR_new,	  
-        MAX,
-	  } type = Type::RoRaBaChCo;
-    //daz3
-    // } type = Type::RoBaRaCoCh;
-
-    enum class Translation {
-      None,
-      Random,
-      MAX,
-    } translation = Translation::None;
-
-    std::map<string, Translation> name_to_translation = {
-      {"None", Translation::None},
-      {"Random", Translation::Random},
-    };
-
-    vector<int> free_physical_pages;
-    long free_physical_pages_remaining;
-    map<pair<int, long>, long> page_translation;
-
-    vector<Controller<T>*> ctrls;
-    T * spec;
-    vector<int> addr_bits;
-    string mapping_file;
-    bool use_mapping_file;
-    bool dump_mapping;
-    
-    int tx_bits;
-
-    Memory(const Config& configs, vector<Controller<T>*> ctrls)
-        : ctrls(ctrls),
-          spec(ctrls[0]->channel->spec),
-          addr_bits(int(T::Level::MAX))
-    {
-        // make sure 2^N channels/ranks
-        // TODO support channel number that is not powers of 2
-        int *sz = spec->org_entry.count;
-        assert((sz[0] & (sz[0] - 1)) == 0);
-        assert((sz[1] & (sz[1] - 1)) == 0);
-        // validate size of one transaction
-        int tx = (spec->prefetch_size * spec->channel_width / 8);
-        tx_bits = calc_log2(tx);
-        assert((1<<tx_bits) == tx);
-        
-        // Parsing mapping file and initialize mapping table
-        use_mapping_file = false;
-        dump_mapping = false;
-        if (spec->standard_name.substr(0, 4) == "DDR3"){
-            if (configs["mapping"] != "defaultmapping"){
-              init_mapping_with_file(configs["mapping"]);
-              // dump_mapping = true;
-              use_mapping_file = true;
-            }
-        }
-        // If hi address bits will not be assigned to Rows
-        // then the chips must not be LPDDRx 6Gb, 12Gb etc.
-        if (type != Type::RoBaRaCoCh && spec->standard_name.substr(0, 5) == "LPDDR")
-            assert((sz[int(T::Level::Row)] & (sz[int(T::Level::Row)] - 1)) == 0);
-
-        max_address = spec->channel_width / 8;
-
-        for (unsigned int lev = 0; lev < addr_bits.size(); lev++) {
-          addr_bits[lev] = calc_log2(sz[lev]);
-            max_address *= sz[lev];
-        }
-
-        addr_bits[int(T::Level::MAX) - 1] -= calc_log2(spec->prefetch_size);
-
-        // Initiating translation
-        if (configs.contains("translation")) {
-          translation = name_to_translation[configs["translation"]];
-        }
-        if (translation != Translation::None) {
-          // construct a list of available pages
-          // TODO: this should not assume a 4KB page!
-          free_physical_pages_remaining = max_address >> 12;
-
-          free_physical_pages.resize(free_physical_pages_remaining, -1);
-        }
-
-        dram_capacity
-            .name("dram_capacity")
-            .desc("Number of bytes in simulated DRAM")
-            .precision(0)
-            ;
-        dram_capacity = max_address;
-
-        num_dram_cycles
-            .name("dram_cycles")
-            .desc("Number of DRAM cycles simulated")
-            .precision(0)
-            ;
-        num_incoming_requests
-            .name("incoming_requests")
-            .desc("Number of incoming requests to DRAM")
-            .precision(0)
-            ;
-        num_read_requests
-            .init(configs.get_core_num())
-            .name("read_requests")
-            .desc("Number of incoming read requests to DRAM per core")
-            .precision(0)
-            ;
-        num_write_requests
-            .init(configs.get_core_num())
-            .name("write_requests")
-            .desc("Number of incoming write requests to DRAM per core")
-            .precision(0)
-            ;
-        incoming_requests_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_requests_per_channel")
-            .desc("Number of incoming requests to each DRAM channel")
-            ;
-        incoming_read_reqs_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_read_reqs_per_channel")
-            .desc("Number of incoming read requests to each DRAM channel")
-            ;
-	// gagan : demand read reqs
-	incoming_demand_read_reqs_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_demand_read_reqs_per_channel")
-            .desc("Number of incoming demand read requests to each DRAM channel")
-            ;
-	// gagan : prefetch read reqs
-	incoming_prefetch_read_reqs_per_channel
-            .init(sz[int(T::Level::Channel)])
-            .name("incoming_prefetch_read_reqs_per_channel")
-            .desc("Number of incoming prefetch read requests to each DRAM channel")
-            ;
-	// gagab : prefecth req to demand req promotion
-	prefetch_to_demand_read_promotion
-            .init(sz[int(T::Level::Channel)])
-            .name("prefetch_to_demand_read_promotion")
-            .desc("Number of incoming prefetch read requests promoted to demand request")
-            ;
-        ramulator_active_cycles
-            .name("ramulator_active_cycles")
-            .desc("The total number of cycles that the DRAM part is active (serving R/W)")
-            .precision(0)
-            ;
-        physical_page_replacement
-            .name("physical_page_replacement")
-            .desc("The number of times that physical page replacement happens.")
-            .precision(0)
-            ;
-        maximum_bandwidth
-            .name("maximum_bandwidth")
-            .desc("The theoretical maximum bandwidth (Bps)")
-            .precision(0)
-            ;
-        in_queue_req_num_sum
-            .name("in_queue_req_num_sum")
-            .desc("Sum of read/write queue length")
-            .precision(0)
-            ;
-        in_queue_read_req_num_sum
-            .name("in_queue_read_req_num_sum")
-            .desc("Sum of read queue length")
-            .precision(0)
-            ;
-        in_queue_write_req_num_sum
-            .name("in_queue_write_req_num_sum")
-            .desc("Sum of write queue length")
-            .precision(0)
-            ;
-        in_queue_req_num_avg
-            .name("in_queue_req_num_avg")
-            .desc("Average of read/write queue length per memory cycle")
-            .precision(6)
-            ;
-        in_queue_read_req_num_avg
-            .name("in_queue_read_req_num_avg")
-            .desc("Average of read queue length per memory cycle")
-            .precision(6)
-            ;
-        in_queue_write_req_num_avg
-            .name("in_queue_write_req_num_avg")
-            .desc("Average of write queue length per memory cycle")
-            .precision(6)
-            ;
-#ifndef INTEGRATED_WITH_GEM5
-        record_read_requests
-            .init(configs.get_core_num())
-            .name("record_read_requests")
-            .desc("record read requests for this core when it reaches request limit or to the end")
-            ;
-
-        record_write_requests
-            .init(configs.get_core_num())
-            .name("record_write_requests")
-            .desc("record write requests for this core when it reaches request limit or to the end")
-            ;
-#endif
-
-    }
-
-    ~Memory()
-    {
-        for (auto ctrl: ctrls)
-            delete ctrl;
-        delete spec;
-    }
-
-    double clk_ns()
-    {
-        return spec->speed_entry.tCK;
-    }
-
-    void record_core(int coreid) {
-#ifndef INTEGRATED_WITH_GEM5
-      record_read_requests[coreid] = num_read_requests[coreid];
-      record_write_requests[coreid] = num_write_requests[coreid];
-#endif
-      for (auto ctrl : ctrls) {
-        ctrl->record_core(coreid);
-      }
-    }
-
-    void tick()
-    {
-        ++num_dram_cycles;
-        int cur_que_req_num = 0;
-        int cur_que_readreq_num = 0;
-        int cur_que_writereq_num = 0;
-        for (auto ctrl : ctrls) {
-          cur_que_req_num += ctrl->readq.size() + ctrl->writeq.size() + ctrl->pending.size();
-          cur_que_readreq_num += ctrl->readq.size() + ctrl->pending.size();
-          cur_que_writereq_num += ctrl->writeq.size();
-        }
-        in_queue_req_num_sum += cur_que_req_num;
-        in_queue_read_req_num_sum += cur_que_readreq_num;
-        in_queue_write_req_num_sum += cur_que_writereq_num;
-
-        bool is_active = false;
-        for (auto ctrl : ctrls) {
-          is_active = is_active || ctrl->is_active();
-          ctrl->tick();
-        }
-        if (is_active) {
-          ramulator_active_cycles++;
-        }
-    }
-
-bool send(Request req)
-    {
-      bool promote = false;
-        req.addr_vec.resize(addr_bits.size());
-        long addr = req.addr;
-        int coreid = req.coreid;
-
-	int column, channel, bank, bankgroup, rank, row, tempA, tempB, channel_mask, channel_mask_temp;
-	long addr_copy;
-
-        // Each transaction size is 2^tx_bits, so first clear the lowest tx_bits bits
-        clear_lower_bits(addr, tx_bits);
-
-        if (use_mapping_file){
-            apply_mapping(addr, req.addr_vec);
-        }
-        else {
-            switch(int(type)){
-                case int(Type::ChRaBaRoCo):
-                    for (int i = addr_bits.size() - 1; i >= 0; i--)
-                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-                    break;
-                case int(Type::RoBaRaCoCh):
-                    req.addr_vec[0] = slice_lower_bits(addr, addr_bits[0]);
-                    req.addr_vec[addr_bits.size() - 1] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-                    for (int i = 1; i <= int(T::Level::Row); i++)
-                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-                    break;
-                // daz3
-                case int(Type::RoRaBaChCo):
-                    req.addr_vec[addr_bits.size() - 1] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-                    req.addr_vec[0] = slice_lower_bits(addr, addr_bits[0]);
-                    for (int i = 2; i < int(T::Level::Row); i++)
-                    {
-                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-                    }
-                    req.addr_vec[1] = slice_lower_bits(addr, addr_bits[1]);
-                    req.addr_vec[addr_bits.size() - 2] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 2]);
-                    break;
-	    case int(Type::RoRaBaChCo_XOR):
-		//std::cout << std::hex << "Addr: " << addr << "\n";
-		//std::cout << "bitwidths: ";
-		//for(int i = 0; i < addr_bits.size(); ++i)
-		//  std::cout << std::dec << addr_bits[i] << " ";
-
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = slice_lower_bits(addr, addr_bits[0]);
-		bank = slice_lower_bits(addr, addr_bits[3]);
-		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-		rank = slice_lower_bits(addr, addr_bits[1]);
-		row = slice_lower_bits(addr, addr_bits[4]);
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		tempA = row & ((1 << addr_bits[2]) - 1);
-		tempB = (row >> 2) & ((1 << addr_bits[3]) - 1);
-
-		bankgroup = bankgroup ^ tempA;
-		bank = bank ^ tempB;
-
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		//std::cout << "address mapping:\n";
-		//for(int i = 0; i < 6; ++i)
-		//  std::cout << std::dec << req.addr_vec[i] << "\n";
-		//std::cout << "\n";
-		break;
-	    case int(Type::RoRaBaChCo_XOR_chint):
-		/*
-		std::cout << std::hex << "Addr: " << addr << "\n";
-		std::cout << "bitwidths: ";
-		for(int i = 0; i < addr_bits.size(); ++i)
-		  std::cout << std::dec << addr_bits[i] << " ";
-		std::cout << "\n";
-		*/
-		
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = slice_lower_bits(addr, addr_bits[0]);
-		bank = slice_lower_bits(addr, addr_bits[3]);
-		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-		rank = slice_lower_bits(addr, addr_bits[1]);
-		row = slice_lower_bits(addr, addr_bits[4]);
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		tempA = row & ((1 << addr_bits[2]) - 1);
-		tempB = (row >> 2) & ((1 << addr_bits[3]) - 1);
-
-		bankgroup = bankgroup ^ tempA;
-		bank = bank ^ tempB;
-
-		channel_mask_temp = column;
-		//std::cout << "channel_mask_temp: " << channel_mask_temp << "\n";
-		channel_mask_temp >>= (addr_bits[addr_bits.size() - 1] - addr_bits[0]);
-		//std::cout << "channel_mask_temp: " << channel_mask_temp << "\n";
-		channel_mask = channel_mask_temp & ((1 << addr_bits[0]) - 1);
-		//std::cout << "channel_mask: " << channel_mask << "\n";
-
-		channel = channel_mask;
-
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		/*
-		std::cout << "address mapping:\n";
-		for(int i = 0; i < 6; ++i)
-		  std::cout << std::dec << req.addr_vec[i] << "\n";
-		std::cout << "\n";
-		*/
-		break;
-	    case int(Type::intel_quad_chan):
-		
-		/*
-		std::cout << std::hex << "Addr: " << addr << "\n";
-		std::cout << "bitwidths: ";
-		for(int i = 0; i < addr_bits.size(); ++i)
-		  std::cout << std::dec << addr_bits[i] << " ";
-		std::cout << "\n";
-		*/
-		
-		addr_copy = addr;
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = get_bit_at(addr_copy, 8) ^ get_bit_at(addr_copy, 13) ^ get_bit_at(addr_copy, 15) ^ get_bit_at(addr_copy, 17) ^ get_bit_at(addr_copy, 19) ^ get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 23) ^ get_bit_at(addr_copy, 25)  ^ get_bit_at(addr_copy, 27);
-		channel = (channel << 1) | (get_bit_at(addr_copy, 7) ^ get_bit_at(addr_copy, 12) ^ get_bit_at(addr_copy, 14) ^ get_bit_at(addr_copy, 16) ^ get_bit_at(addr_copy, 18) ^ get_bit_at(addr_copy, 20) ^ get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 24)  ^ get_bit_at(addr_copy, 26));
-		// row = [+23][19 to 17]
-		slice_lower_bits(addr, 10);
-		// tempA : [19 to 17]
-		tempA = slice_lower_bits(addr, 3);
-		// tempB : use 2 bits for banks and 1 bit for ranks
-		tempB = slice_lower_bits(addr, 3);
-		row = slice_lower_bits(addr, addr_bits[4] - 3);
-		row = (row << 3) | tempA;
-
-		// rank
-		if(addr_bits[1] == 1)
-		  {
-		    rank = get_bit_at(addr_copy, 15);
-		  }
-		else if(addr_bits[1] == 2)
-		  {
-		    rank = (get_bit_at(tempB, 0) << 1) | get_bit_at(addr_copy, 15);
-		  }
-		else
-		  {
-		    std::cout << "Rank bits > 2. Not supported.\n";
-		    exit(0);
-		  }
-
-		// bank
-		if(addr_bits[3] == 2)
-		  {
-		    bank = ((get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 26)) << 1) | (get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 25));
-		  }
-		else if(addr_bits[3] == 4)
-		  {
-		    bank = get_bit_at(tempB, 1);
-		    bank = (bank << 1) | get_bit_at(tempB, 2);
-		    bank = (bank << 2) | ((get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 26)) << 1) | (get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 25));
-		  }
-		else
-		  {
-		    std::cout << "Bank bits != {2, 4}. Not supported.\n";
-		    exit(0);
-		  }
-
-		// bankgroup
-		if(addr_bits[2] == 2)
-		  {
-		    bankgroup = ((get_bit_at(addr_copy, 24) ^ get_bit_at(addr_copy, 20)) << 1) | (get_bit_at(addr_copy, 23) ^ get_bit_at(addr_copy, 26));
-		  }
-		else
-		  {
-		    std::cout << "Bankgroup bits != 2. Not supported.\n";
-		    exit(0);
-		  }
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		/*
-		std::cout << "address mapping:\n";
-		for(int i = 0; i < 6; ++i)
-		  std::cout << std::dec << req.addr_vec[i] << "\n";
-		std::cout << "\n";
-		*/
-		
-		break;
-
-	    case int(Type::RoRaBaChCo_XOR_new):
-		/*
-		std::cout << std::hex << "Addr: " << addr << "\n";
-		std::cout << "bitwidths: ";
-		for(int i = 0; i < addr_bits.size(); ++i)
-		  std::cout << std::dec << addr_bits[i] << " ";
-		*/
-
-		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-		channel = slice_lower_bits(addr, addr_bits[0]);
-		rank = slice_lower_bits(addr, addr_bits[1]);
-		bank = slice_lower_bits(addr, addr_bits[3]);
-		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-		row = slice_lower_bits(addr, addr_bits[4]);
-
-		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-		
-		tempA = row & ((1 << addr_bits[3]) - 1);
-		tempB = (row >> addr_bits[3]) & ((1 << addr_bits[2]) - 1);
-
-		bank = bank ^ tempA;
-		bankgroup = bankgroup ^ tempB;
-
-		req.addr_vec[0] = channel;
-		req.addr_vec[1] = rank;
-		req.addr_vec[2] = bankgroup;
-		req.addr_vec[3] = bank;
-		req.addr_vec[4] = row;
-		req.addr_vec[5] = column;
-
-		/*
-		std::cout << "address mapping:\n";
-		for(int i = 0; i < 6; ++i)
-		  std::cout << std::dec << req.addr_vec[i] << "\n";
-		std::cout << "\n";
-		*/
-		break;
-                default:
-                    assert(false);
-            }
-        }
-
-	if(promote == false)
-	  {
-	    if(ctrls[req.addr_vec[0]]->enqueue(req)) {
-	      // tally stats here to avoid double counting for requests that aren't enqueued
-	      ++num_incoming_requests;
-	      if (req.type == Request::Type::READ) {
-		++num_read_requests[coreid];
-		++incoming_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-		if(req.is_prefetch)
-		  ++incoming_prefetch_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-		else
-		  ++incoming_demand_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	      }
-	      if (req.type == Request::Type::WRITE) {
-		++num_write_requests[coreid];
-	      }
-	      ++incoming_requests_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	      return true;
-	    }
-	  }
-	else
-	  {
-	    ctrls[req.addr_vec[0]]->promote(req);
-	    --incoming_prefetch_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	    ++incoming_demand_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-	    ++prefetch_to_demand_read_promotion[req.addr_vec[int(T::Level::Channel)]];
-	    return true;
-	  }
-
-        return false;
-    }
-    
-    void init_mapping_with_file(string filename){
-        ifstream file(filename);
-        assert(file.good() && "Bad mapping file");
-        // possible line types are:
-        // 0. Empty line
-        // 1. Direct bit assignment   : component N   = x
-        // 2. Direct range assignment : component N:M = x:y
-        // 3. XOR bit assignment      : component N   = x y z ...
-        // 4. Comment line            : # comment here
-        string line;
-        char delim[] = " \t";
-        while (getline(file, line)) {
-            short capture_flags = 0;
-            int level = -1;
-            int target_bit = -1, target_bit2 = -1;
-            int source_bit = -1, source_bit2 = -1;
-            // cout << "Processing: " << line << endl;
-            bool is_range = false;
-            while (true) { // process next word
-                size_t start = line.find_first_not_of(delim);
-                if (start == string::npos) // no more words
-                    break;
-                size_t end = line.find_first_of(delim, start);
-                string word = line.substr(start, end - start);
-                
-                if (word.at(0) == '#')// starting a comment
-                    break;
-                
-                size_t col_index;
-                int source_min, target_min, target_max;
-                switch (capture_flags){
-                    case 0: // capturing the component name
-                        // fetch component level from channel spec
-                        for (int i = 0; i < int(T::Level::MAX); i++)
-                            if (word.find(T::level_str[i]) != string::npos) {
-                                level = i;
-                                capture_flags ++;
-                            }
-                        break;
-
-                    case 1: // capturing target bit(s)
-                        col_index = word.find(":");
-                        if ( col_index != string::npos ){
-                            target_bit2 = stoi(word.substr(col_index+1));
-                            word = word.substr(0,col_index);
-                            is_range = true;
-                        }
-                        target_bit = stoi(word);
-                        capture_flags ++;
-                        break;
-
-                    case 2: //this should be the delimiter
-                        assert(word.find("=") != string::npos);
-                        capture_flags ++;
-                        break;
-
-                    case 3:
-                        if (is_range){
-                            col_index = word.find(":");
-                            source_bit  = stoi(word.substr(0,col_index));
-                            source_bit2 = stoi(word.substr(col_index+1));
-                            assert(source_bit2 - source_bit == target_bit2 - target_bit);
-                            source_min = min(source_bit, source_bit2);
-                            target_min = min(target_bit, target_bit2);
-                            target_max = max(target_bit, target_bit2);
-                            while (target_min <= target_max){
-                                mapping_scheme[level][target_min].push_back(source_min);
-                                // cout << target_min << " <- " << source_min << endl;
-                                source_min ++;
-                                target_min ++;
-                            }
-                        }
-                        else {
-                            source_bit = stoi(word);
-                            mapping_scheme[level][target_bit].push_back(source_bit);
-                        }
-                }
-                if (end == string::npos) { // this is the last word
-                    break;
-                }
-                line = line.substr(end);
-            }
-        }
-        if (dump_mapping)
-            dump_mapping_scheme();
-    }
-    
-    void dump_mapping_scheme(){
-        cout << "Mapping Scheme: " << endl;
-        for (MapScheme::iterator mapit = mapping_scheme.begin(); mapit != mapping_scheme.end(); mapit++)
-        {
-            int level = mapit->first;
-            for (MapSchemeEntry::iterator entit = mapit->second.begin(); entit != mapit->second.end(); entit++){
-                cout << T::level_str[level] << "[" << entit->first << "] := ";
-                cout << "PhysicalAddress[" << *(entit->second.begin()) << "]";
-                entit->second.erase(entit->second.begin());
-                for (MapSrcVector::iterator it = entit->second.begin() ; it != entit->second.end(); it ++)
-                    cout << " xor PhysicalAddress[" << *it << "]";
-                cout << endl;
-            }
-        }
-    }
-    
-    void apply_mapping(long addr, std::vector<int>& addr_vec){
-        int *sz = spec->org_entry.count;
-        int addr_total_bits = sizeof(addr_vec)*8;
-        int addr_bits [int(T::Level::MAX)];
-        for (int i = 0 ; i < int(T::Level::MAX) ; i ++)
-        {
-            if ( i != int(T::Level::Row))
-            {
-                addr_bits[i] = calc_log2(sz[i]);
-                addr_total_bits -= addr_bits[i];
-            }
-        }
-        // Row address is an integer.
-        addr_bits[int(T::Level::Row)] = min((int)sizeof(int)*8, max(addr_total_bits, calc_log2(sz[int(T::Level::Row)])));
-
-        // printf("Address: %lx => ",addr);
-        for (unsigned int lvl = 0; lvl < int(T::Level::MAX); lvl++)
-        {
-            unsigned int lvl_bits = addr_bits[lvl];
-            addr_vec[lvl] = 0;
-            for (unsigned int bitindex = 0 ; bitindex < lvl_bits ; bitindex++){
-                bool bitvalue = false;
-                for (MapSrcVector::iterator it = mapping_scheme[lvl][bitindex].begin() ;
-                    it != mapping_scheme[lvl][bitindex].end(); it ++)
-                {
-                    bitvalue = bitvalue xor get_bit_at(addr, *it);
-                }
-                addr_vec[lvl] |= (bitvalue << bitindex);
-            }
-            // printf("%s: %x, ",T::level_str[lvl].c_str(),addr_vec[lvl]);
-        }
-        // printf("\n");
-    }
-
-    int pending_requests()
-    {
-        int reqs = 0;
-        for (auto ctrl: ctrls)
-            reqs += ctrl->readq.size() + ctrl->writeq.size() + ctrl->otherq.size() + ctrl->actq.size() + ctrl->pending.size();
-        return reqs;
-    }
-
-    void set_high_writeq_watermark(const float watermark) {
-        for (auto ctrl: ctrls)
-            ctrl->set_high_writeq_watermark(watermark);
-    }
-
-    void set_low_writeq_watermark(const float watermark) {
-    for (auto ctrl: ctrls)
-        ctrl->set_low_writeq_watermark(watermark);
-    }
-
-    void finish(void) {
-      dram_capacity = max_address;
-      int *sz = spec->org_entry.count;
-      maximum_bandwidth = spec->speed_entry.rate * 1e6 * spec->channel_width * sz[int(T::Level::Channel)] / 8;
-      long dram_cycles = num_dram_cycles.value();
-      for (auto ctrl : ctrls) {
-        long read_req = long(incoming_read_reqs_per_channel[ctrl->channel->id].value());
-	long demand_read_req = long(incoming_demand_read_reqs_per_channel[ctrl->channel->id].value());
-	long prefetch_read_req = long(incoming_prefetch_read_reqs_per_channel[ctrl->channel->id].value());
-        ctrl->finish(read_req, demand_read_req, prefetch_read_req, dram_cycles);
-      }
-
-      // finalize average queueing requests
-      in_queue_req_num_avg = in_queue_req_num_sum.value() / dram_cycles;
-      in_queue_read_req_num_avg = in_queue_read_req_num_sum.value() / dram_cycles;
-      in_queue_write_req_num_avg = in_queue_write_req_num_sum.value() / dram_cycles;
-    }
-
-    long page_allocator(long addr, int coreid) {
-        long virtual_page_number = addr >> 12;
-
-        switch(int(translation)) {
-            case int(Translation::None): {
-              return addr;
-            }
-            case int(Translation::Random): {
-                auto target = make_pair(coreid, virtual_page_number);
-                if(page_translation.find(target) == page_translation.end()) {
-                    // page doesn't exist, so assign a new page
-                    // make sure there are physical pages left to be assigned
-
-                    // if physical page doesn't remain, replace a previous assigned
-                    // physical page.
-                    if (!free_physical_pages_remaining) {
-                      physical_page_replacement++;
-                      long phys_page_to_read = lrand() % free_physical_pages.size();
-                      assert(free_physical_pages[phys_page_to_read] != -1);
-                      page_translation[target] = phys_page_to_read;
-                    } else {
-                        // assign a new page
-                        long phys_page_to_read = lrand() % free_physical_pages.size();
-                        // if the randomly-selected page was already assigned
-                        if(free_physical_pages[phys_page_to_read] != -1) {
-                            long starting_page_of_search = phys_page_to_read;
-
-                            do {
-                                // iterate through the list until we find a free page
-                                // TODO: does this introduce serious non-randomness?
-                                ++phys_page_to_read;
-                                phys_page_to_read %= free_physical_pages.size();
-                            }
-                            while((phys_page_to_read != starting_page_of_search) && free_physical_pages[phys_page_to_read] != -1);
-                        }
-
-                        assert(free_physical_pages[phys_page_to_read] == -1);
-
-                        page_translation[target] = phys_page_to_read;
-                        free_physical_pages[phys_page_to_read] = coreid;
-                        --free_physical_pages_remaining;
-                    }
-                }
-
-                // SAUGATA TODO: page size should not always be fixed to 4KB
-                return (page_translation[target] << 12) | (addr & ((1 << 12) - 1));
-            }
-            default:
-                assert(false);
-        }
-
-    }
-
-private:
-
-    int calc_log2(int val){
-        int n = 0;
-        while ((val >>= 1))
-            n ++;
-        return n;
-    }
-    int slice_lower_bits(long& addr, int bits)
-    {
-        int lbits = addr & ((1<<bits) - 1);
-        addr >>= bits;
-        return lbits;
-    }
-    bool get_bit_at(long addr, int bit)
-    {
-        return (((addr >> bit) & 1) == 1);
-    }
-    void clear_lower_bits(long& addr, int bits)
-    {
-        addr >>= bits;
-    }
-    long lrand(void) {
-        if(sizeof(int) < sizeof(long)) {
-            return static_cast<long>(rand()) << (sizeof(int) * 8) | rand();
-        }
-
-        return rand();
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__MEMORY_H*/
diff --git a/ext/ramulator/Ramulator/src/MemoryFactory.cpp b/ext/ramulator/Ramulator/src/MemoryFactory.cpp
deleted file mode 100644
index 2d2f77406..000000000
--- a/ext/ramulator/Ramulator/src/MemoryFactory.cpp
+++ /dev/null
@@ -1,80 +0,0 @@
-#include "MemoryFactory.h"
-#include "LPDDR4.h"
-#include "WideIO.h"
-#include "WideIO2.h"
-#include "HBM.h"
-#include "SALP.h"
-
-using namespace ramulator;
-
-namespace ramulator
-{
-
-template <>
-void MemoryFactory<LPDDR4>::validate(int channels, int ranks, const Config& configs) {
-    assert(channels >= 2 && "LPDDR4 requires 2, 4, 8 ... channels");
-}
-
-template <>
-void MemoryFactory<WideIO>::validate(int channels, int ranks, const Config& configs) {
-    assert(channels == 4 && "WideIO comes with 4 channels");
-}
-
-template <>
-void MemoryFactory<WideIO2>::validate(int channels, int ranks, const Config& configs) {
-    assert((channels == 4 || channels == 8) && "WideIO2 comes with 4 or 8 channels");
-    assert((ranks == 1 || ranks == 2) && "WideIO2 comes with 1 or 2 ranks");
-}
-
-template <>
-void MemoryFactory<HBM>::validate(int channels, int ranks, const Config& configs) {
-    assert(channels == 8 && "HBM comes with 8 channels");
-}
-
-template <>
-MemoryBase *MemoryFactory<WideIO2>::create(const Config& configs, int cacheline, bool enable_debug) {
-    int channels = stoi(configs["channels"], NULL, 0);
-    int ranks = stoi(configs["ranks"], NULL, 0);
-    validate(channels, ranks, configs);
-
-    const string& org_name = configs["org"];
-    const string& speed_name = configs["speed"];
-
-    WideIO2 *spec = new WideIO2(org_name, speed_name, channels);
-
-    extend_channel_width(spec, cacheline);
-
-    return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-}
-
-
-template <>
-MemoryBase *MemoryFactory<SALP>::create(const Config& configs, int cacheline, bool enable_debug) {
-    int channels = stoi(configs["channels"], NULL, 0);
-    int ranks = stoi(configs["ranks"], NULL, 0);
-    int subarrays = stoi(configs["subarrays"], NULL, 0);
-    validate(channels, ranks, configs);
-
-    const string& std_name = configs["standard"];
-    const string& org_name = configs["org"];
-    const string& speed_name = configs["speed"];
-
-    SALP *spec = new SALP(org_name, speed_name, std_name, subarrays);
-
-    extend_channel_width(spec, cacheline);
-
-    return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-}
-
-}
-
-// This function can be used by autoconf AC_CHECK_LIB since
-// apparently it can't detect C++ functions.
-// Basically just an entry in the symbol table
-extern "C"
-{
-    void libramulator_is_present(void)
-    {
-        ;
-    }
-}
diff --git a/ext/ramulator/Ramulator/src/MemoryFactory.h b/ext/ramulator/Ramulator/src/MemoryFactory.h
deleted file mode 100644
index f85d773b3..000000000
--- a/ext/ramulator/Ramulator/src/MemoryFactory.h
+++ /dev/null
@@ -1,86 +0,0 @@
-#ifndef __MEMORY_FACTORY_H
-#define __MEMORY_FACTORY_H
-
-#include <map>
-#include <string>
-#include <cassert>
-
-#include "Config.h"
-#include "Memory.h"
-
-#include "WideIO2.h"
-#include "SALP.h"
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class MemoryFactory {
-public:
-    static void extend_channel_width(T* spec, int cacheline)
-    {
-        int channel_unit = spec->prefetch_size * spec->channel_width / 8;
-        int gang_number = cacheline / channel_unit;
-        
-        assert(gang_number >= 1 && 
-            "cacheline size must be greater or equal to minimum channel width");
-        
-        assert(cacheline == gang_number * channel_unit &&
-            "cacheline size must be a multiple of minimum channel width");
-        
-        spec->channel_width *= gang_number;
-    }
-
-    static Memory<T> *populate_memory(const Config& configs, T *spec, int channels, int ranks, bool enable_debug) {
-        int& default_ranks = spec->org_entry.count[int(T::Level::Rank)];
-        int& default_channels = spec->org_entry.count[int(T::Level::Channel)];
-
-        if (default_channels == 0) default_channels = channels;
-        if (default_ranks == 0) default_ranks = ranks;
-
-        vector<Controller<T> *> ctrls;
-        for (int c = 0; c < channels; c++){
-            DRAM<T>* channel = new DRAM<T>(spec, T::Level::Channel);
-            channel->id = c;
-            channel->regStats("");
-            ctrls.push_back(new Controller<T>(configs, channel, enable_debug));
-        }
-        
-        // daz3
-        std::cout << "Ramulator::channels " << channels << ", ::ranks " << ranks << ", ::enable_debug" << enable_debug << std::endl;
-
-        return new Memory<T>(configs, ctrls);
-    }
-
-    static void validate(int channels, int ranks, const Config& configs) {
-        assert(channels > 0 && ranks > 0);
-    }
-
-    static MemoryBase *create(const Config& configs, int cacheline, bool enable_debug)
-    {
-        int channels = stoi(configs["channels"], NULL, 0);
-        int ranks = stoi(configs["ranks"], NULL, 0);
-        
-        validate(channels, ranks, configs);
-
-        const string& org_name = configs["org"];
-        const string& speed_name = configs["speed"];
-
-        T *spec = new T(org_name, speed_name);
-
-        extend_channel_width(spec, cacheline);
-
-        return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-    }
-};
-
-template <>
-  MemoryBase *MemoryFactory<WideIO2>::create(const Config& configs, int cacheline, bool enable_debug);
-template <>
-  MemoryBase *MemoryFactory<SALP>::create(const Config& configs, int cacheline, bool enable_debug);
-
-} /*namespace ramulator*/
-
-#endif /*__MEMORY_FACTORY_H*/
diff --git a/ext/ramulator/Ramulator/src/PCM.cpp b/ext/ramulator/Ramulator/src/PCM.cpp
deleted file mode 100644
index 309ace8a1..000000000
--- a/ext/ramulator/Ramulator/src/PCM.cpp
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Benjamin C. Lee, Engin Ipek, Onur Mutlu, and Doug Burger. 2009.
-* Architecting phase change memory as a scalable dram alternative.
-* In Proceedings of the 36th annual international symposium on Computer architecture (ISCA '09).
-* ACM, New York, NY, USA, 2-13.
-* DOI: https://doi.org/10.1145/1555754.1555758
-*
-*/
-#include "PCM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string PCM::standard_name = "PCM";
-string PCM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum PCM::Org> PCM::org_map = {
-    {"PCM_512Mb_x4", PCM::Org::PCM_512Mb_x4}, {"PCM_512Mb_x8", PCM::Org::PCM_512Mb_x8}, {"PCM_512Mb_x16", PCM::Org::PCM_512Mb_x16},
-    {"PCM_1Gb_x4", PCM::Org::PCM_1Gb_x4}, {"PCM_1Gb_x8", PCM::Org::PCM_1Gb_x8}, {"PCM_1Gb_x16", PCM::Org::PCM_1Gb_x16},
-    {"PCM_2Gb_x4", PCM::Org::PCM_2Gb_x4}, {"PCM_2Gb_x8", PCM::Org::PCM_2Gb_x8}, {"PCM_2Gb_x16", PCM::Org::PCM_2Gb_x16},
-    {"PCM_4Gb_x4", PCM::Org::PCM_4Gb_x4}, {"PCM_4Gb_x8", PCM::Org::PCM_4Gb_x8}, {"PCM_4Gb_x16", PCM::Org::PCM_4Gb_x16},
-    {"PCM_8Gb_x4", PCM::Org::PCM_8Gb_x4}, {"PCM_8Gb_x8", PCM::Org::PCM_8Gb_x8}, {"PCM_8Gb_x16", PCM::Org::PCM_8Gb_x16},
-};
-
-map<string, enum PCM::Speed> PCM::speed_map = {
-    {"PCM_800D", PCM::Speed::PCM_800D}
-};
-
-
-PCM::PCM(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-PCM::PCM(const string& org_str, const string& speed_str) :
-    PCM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void PCM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void PCM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void PCM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = 0; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        default: assert(false);
-    }
-}
-
-
-void PCM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void PCM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void PCM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void PCM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<PCM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<PCM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<PCM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<PCM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<PCM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void PCM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDact});
-    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nRRDact});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/PCM.h b/ext/ramulator/Ramulator/src/PCM.h
deleted file mode 100644
index 785d07d73..000000000
--- a/ext/ramulator/Ramulator/src/PCM.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Benjamin C. Lee, Engin Ipek, Onur Mutlu, and Doug Burger. 2009.
-* Architecting phase change memory as a scalable dram alternative.
-* In Proceedings of the 36th annual international symposium on Computer architecture (ISCA '09).
-* ACM, New York, NY, USA, 2-13.
-* DOI: https://doi.org/10.1145/1555754.1555758
-*
-*/
-#ifndef __PCM_H
-#define __PCM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class PCM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    PCM(Org org, Speed speed);
-    PCM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<PCM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<PCM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<PCM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<PCM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        PCM_512Mb_x4, PCM_512Mb_x8, PCM_512Mb_x16,
-        PCM_1Gb_x4,   PCM_1Gb_x8,   PCM_1Gb_x16,
-        PCM_2Gb_x4,   PCM_2Gb_x8,   PCM_2Gb_x16,
-        PCM_4Gb_x4,   PCM_4Gb_x8,   PCM_4Gb_x16,
-        PCM_8Gb_x4,   PCM_8Gb_x8,   PCM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        PCM_800D,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRDact, nRRDpre, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, 2.5, 4, 4, 2,  5,  22,  60,  5, 22, 60, 3, 3,  6, 2, 11, 0, 0, 3900, 0, 3, 10, 4, 0, 512},
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__PCM_H*/
diff --git a/ext/ramulator/Ramulator/src/Processor.cpp b/ext/ramulator/Ramulator/src/Processor.cpp
deleted file mode 100644
index bd94e5581..000000000
--- a/ext/ramulator/Ramulator/src/Processor.cpp
+++ /dev/null
@@ -1,473 +0,0 @@
-#include "Processor.h"
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-Processor::Processor(const Config& configs,
-    vector<const char*> trace_list,
-    function<bool(Request)> send_memory,
-    MemoryBase& memory)
-    : ipcs(trace_list.size(), -1),
-    early_exit(configs.is_early_exit()),
-    no_core_caches(!configs.has_core_caches()),
-    no_shared_cache(!configs.has_l3_cache()),
-    cachesys(new CacheSystem(configs, send_memory)),
-    llc(l3_size, l3_assoc, l3_blocksz,
-         mshr_per_bank * trace_list.size(),
-         Cache::Level::L3, cachesys) {
-
-  assert(cachesys != nullptr);
-  int tracenum = trace_list.size();
-  assert(tracenum > 0);
-  printf("tracenum: %d\n", tracenum);
-  for (int i = 0 ; i < tracenum ; ++i) {
-    printf("trace_list[%d]: %s\n", i, trace_list[i]);
-  }
-  if (no_shared_cache) {
-    for (int i = 0 ; i < tracenum ; ++i) {
-      cores.emplace_back(new Core(
-          configs, i, trace_list[i], send_memory, nullptr,
-          cachesys, memory));
-    }
-  } else {
-    for (int i = 0 ; i < tracenum ; ++i) {
-      cores.emplace_back(new Core(configs, i, trace_list[i],
-          std::bind(&Cache::send, &llc, std::placeholders::_1),
-          &llc, cachesys, memory));
-    }
-  }
-  for (int i = 0 ; i < tracenum ; ++i) {
-    cores[i]->callback = std::bind(&Processor::receive, this,
-        placeholders::_1);
-  }
-
-  // regStats
-  cpu_cycles.name("cpu_cycles")
-            .desc("cpu cycle number")
-            .precision(0)
-            ;
-  cpu_cycles = 0;
-}
-
-void Processor::tick() {
-  cpu_cycles++;
-
-  if((int(cpu_cycles.value()) % 50000000) == 0)
-      printf("CPU heartbeat, cycles: %d \n", (int(cpu_cycles.value())));
-
-  if (!(no_core_caches && no_shared_cache)) {
-    cachesys->tick();
-  }
-  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-    Core* core = cores[i].get();
-    core->tick();
-  }
-}
-
-void Processor::receive(Request& req) {
-  if (!no_shared_cache) {
-    llc.callback(req);
-  } else if (!cores[0]->no_core_caches) {
-    // Assume all cores have caches or don't have caches
-    // at the same time.
-    for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-      Core* core = cores[i].get();
-      core->caches[0]->callback(req);
-    }
-  }
-  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-    Core* core = cores[i].get();
-    core->receive(req);
-  }
-}
-
-bool Processor::finished() {
-  if (early_exit) {
-    for (unsigned int i = 0 ; i < cores.size(); ++i) {
-      if (cores[i]->finished()) {
-        for (unsigned int j = 0 ; j < cores.size() ; ++j) {
-          ipc += cores[j]->calc_ipc();
-        }
-        return true;
-      }
-    }
-    return false;
-  } else {
-    for (unsigned int i = 0 ; i < cores.size(); ++i) {
-      if (!cores[i]->finished()) {
-        return false;
-      }
-      if (ipcs[i] < 0) {
-        ipcs[i] = cores[i]->calc_ipc();
-        ipc += ipcs[i];
-      }
-    }
-    return true;
-  }
-}
-
-bool Processor::has_reached_limit() {
-  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-    if (!cores[i]->has_reached_limit()) {
-      return false;
-    }
-  }
-  return true;
-}
-
-long Processor::get_insts() {
-    long insts_total = 0;
-    for (unsigned int i = 0 ; i < cores.size(); i++) {
-        insts_total += cores[i]->get_insts();
-    }
-
-    return insts_total;
-}
-
-void Processor::reset_stats() {
-    for (unsigned int i = 0 ; i < cores.size(); i++) {
-        cores[i]->reset_stats();
-    }
-
-    ipc = 0;
-
-    for (unsigned int i = 0; i < ipcs.size(); i++)
-        ipcs[i] = -1;
-}
-
-Core::Core(const Config& configs, int coreid,
-    const char* trace_fname, function<bool(Request)> send_next,
-    Cache* llc, std::shared_ptr<CacheSystem> cachesys, MemoryBase& memory)
-    : id(coreid), no_core_caches(!configs.has_core_caches()),
-    no_shared_cache(!configs.has_l3_cache()),
-    llc(llc), trace(trace_fname), memory(memory)
-{
-  // set expected limit instruction for calculating weighted speedup
-  expected_limit_insts = configs.get_expected_limit_insts();
-  trace.expected_limit_insts = expected_limit_insts;
-
-  // Build cache hierarchy
-  if (no_core_caches) {
-    send = send_next;
-  } else {
-    // L2 caches[0]
-    caches.emplace_back(new Cache(
-        l2_size, l2_assoc, l2_blocksz, l2_mshr_num,
-        Cache::Level::L2, cachesys));
-    // L1 caches[1]
-    caches.emplace_back(new Cache(
-        l1_size, l1_assoc, l1_blocksz, l1_mshr_num,
-        Cache::Level::L1, cachesys));
-    send = bind(&Cache::send, caches[1].get(), placeholders::_1);
-    if (llc != nullptr) {
-      caches[0]->concatlower(llc);
-    }
-    caches[1]->concatlower(caches[0].get());
-
-    first_level_cache = caches[1].get();
-  }
-  if (no_core_caches) {
-    more_reqs = trace.get_filtered_request(
-        bubble_cnt, req_addr, req_type);
-    req_addr = memory.page_allocator(req_addr, id);
-  } else {
-    more_reqs = trace.get_unfiltered_request(
-        bubble_cnt, req_addr, req_type);
-    req_addr = memory.page_allocator(req_addr, id);
-  }
-
-  
-  // regStats
-  record_cycs.name("record_cycs_core_" + to_string(id))
-             .desc("Record cycle number for calculating weighted speedup. (Only valid when expected limit instruction number is non zero in config file.)")
-             .precision(0)
-             ;
-
-  record_insts.name("record_insts_core_" + to_string(id))
-              .desc("Retired instruction number when record cycle number. (Only valid when expected limit instruction number is non zero in config file.)")
-              .precision(0)
-              ;
-
-  memory_access_cycles.name("memory_access_cycles_core_" + to_string(id))
-                      .desc("memory access cycles in memory time domain")
-                      .precision(0)
-                      ;
-  memory_access_cycles = 0;
-  cpu_inst.name("cpu_instructions_core_" + to_string(id))
-          .desc("cpu instruction number")
-          .precision(0)
-          ;
-  cpu_inst = 0;
-}
-
-
-double Core::calc_ipc()
-{
-    printf("[%d]retired: %ld, clk, %ld\n", id, retired, clk);
-    return (double) retired / clk;
-}
-
-void Core::tick()
-{
-    clk++;
-
-    if(first_level_cache != nullptr)
-        first_level_cache->tick();
-
-    retired += window.retire();
-
-    if (expected_limit_insts == 0 && !more_reqs) return;
-
-    // bubbles (non-memory operations)
-    int inserted = 0;
-    while (bubble_cnt > 0) {
-        if (inserted == window.ipc) return;
-        if (window.is_full()) return;
-
-        window.insert(true, -1);
-        inserted++;
-        bubble_cnt--;
-        cpu_inst++;
-        if (long(cpu_inst.value()) == expected_limit_insts && !reached_limit) {
-          record_cycs = clk;
-          record_insts = long(cpu_inst.value());
-          memory.record_core(id);
-          reached_limit = true;
-        }
-    }
-
-    if (req_type == Request::Type::READ) {
-        // read request
-        if (inserted == window.ipc) return;
-        if (window.is_full()) return;
-
-        Request req(req_addr, req_type, callback, id);
-        if (!send(req)) return;
-
-        window.insert(false, req_addr);
-        cpu_inst++;
-    }
-    else {
-        // write request
-        assert(req_type == Request::Type::WRITE);
-        Request req(req_addr, req_type, callback, id);
-        if (!send(req)) return;
-        cpu_inst++;
-    }
-    if (long(cpu_inst.value()) == expected_limit_insts && !reached_limit) {
-      record_cycs = clk;
-      record_insts = long(cpu_inst.value());
-      memory.record_core(id);
-      reached_limit = true;
-    }
-
-    if (no_core_caches) {
-      more_reqs = trace.get_filtered_request(
-          bubble_cnt, req_addr, req_type);
-      if (req_addr != -1) {
-        req_addr = memory.page_allocator(req_addr, id);
-      }
-    } else {
-      more_reqs = trace.get_unfiltered_request(
-          bubble_cnt, req_addr, req_type);
-      if (req_addr != -1) {
-        req_addr = memory.page_allocator(req_addr, id);
-      }
-    }
-    if (!more_reqs) {
-      if (!reached_limit) { // if the length of this trace is shorter than expected length, then record it when the whole trace finishes, and set reached_limit to true.
-        // Hasan: overriding this behavior. We start the trace from the
-        // beginning until the requested amount of instructions are
-        // simulated. This should never be reached now.
-        assert((expected_limit_insts == 0) && "Shouldn't be reached when expected_limit_insts > 0 since we start over the trace");
-        record_cycs = clk;
-        record_insts = long(cpu_inst.value());
-        memory.record_core(id);
-        reached_limit = true;
-      }
-    }
-}
-
-bool Core::finished()
-{
-    return !more_reqs && window.is_empty();
-}
-
-bool Core::has_reached_limit() {
-  return reached_limit;
-}
-
-long Core::get_insts() {
-    return long(cpu_inst.value());
-}
-
-void Core::receive(Request& req)
-{
-    window.set_ready(req.addr, ~(l1_blocksz - 1l));
-    if (req.arrive != -1 && req.depart > last) {
-      memory_access_cycles += (req.depart - max(last, req.arrive));
-      last = req.depart;
-    }
-}
-
-void Core::reset_stats() {
-    clk = 0;
-    retired = 0;
-    cpu_inst = 0;
-}
-
-bool Window::is_full()
-{
-    return load == depth;
-}
-
-bool Window::is_empty()
-{
-    return load == 0;
-}
-
-
-void Window::insert(bool ready, long addr)
-{
-    assert(load <= depth);
-
-    ready_list.at(head) = ready;
-    addr_list.at(head) = addr;
-
-    head = (head + 1) % depth;
-    load++;
-}
-
-
-long Window::retire()
-{
-    assert(load <= depth);
-
-    if (load == 0) return 0;
-
-    int retired = 0;
-    while (load > 0 && retired < ipc) {
-        if (!ready_list.at(tail))
-            break;
-
-        tail = (tail + 1) % depth;
-        load--;
-        retired++;
-    }
-
-    return retired;
-}
-
-
-void Window::set_ready(long addr, int mask)
-{
-    if (load == 0) return;
-
-    for (int i = 0; i < load; i++) {
-        int index = (tail + i) % depth;
-        if ((addr_list.at(index) & mask) != (addr & mask))
-            continue;
-        ready_list.at(index) = true;
-    }
-}
-
-
-
-Trace::Trace(const char* trace_fname) : file(trace_fname), trace_name(trace_fname)
-{
-    if (!file.good()) {
-        std::cerr << "Bad trace file: " << trace_fname << std::endl;
-        exit(1);
-    }
-}
-
-bool Trace::get_unfiltered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type)
-{
-    string line;
-    getline(file, line);
-    if (file.eof()) {
-      file.clear();
-      file.seekg(0, file.beg);
-      getline(file, line);
-      //return false;
-    }
-    size_t pos, end;
-    bubble_cnt = std::stoul(line, &pos, 10);
-    pos = line.find_first_not_of(' ', pos+1);
-    req_addr = std::stoul(line.substr(pos), &end, 0);
-
-    pos = line.find_first_not_of(' ', pos+end);
-
-    if (pos == string::npos || line.substr(pos)[0] == 'R')
-        req_type = Request::Type::READ;
-    else if (line.substr(pos)[0] == 'W')
-        req_type = Request::Type::WRITE;
-    else assert(false);
-    return true;
-}
-
-bool Trace::get_filtered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type)
-{
-    static bool has_write = false;
-    static long write_addr;
-    static int line_num = 0;
-    if (has_write){
-        bubble_cnt = 0;
-        req_addr = write_addr;
-        req_type = Request::Type::WRITE;
-        has_write = false;
-        return true;
-    }
-    string line;
-    getline(file, line);
-    line_num ++;
-    if (file.eof() || line.size() == 0) {
-        file.clear();
-        file.seekg(0, file.beg);
-        line_num = 0;
-
-        if(expected_limit_insts == 0) {
-            has_write = false;
-            return false;
-        }
-        else { // starting over the input trace file
-            getline(file, line);
-            line_num++;
-        }
-    }
-
-    size_t pos, end;
-    bubble_cnt = std::stoul(line, &pos, 10);
-
-    pos = line.find_first_not_of(' ', pos+1);
-    req_addr = stoul(line.substr(pos), &end, 0);
-    req_type = Request::Type::READ;
-
-    pos = line.find_first_not_of(' ', pos+end);
-    if (pos != string::npos){
-        has_write = true;
-        write_addr = stoul(line.substr(pos), NULL, 0);
-    }
-    return true;
-}
-
-bool Trace::get_dramtrace_request(long& req_addr, Request::Type& req_type)
-{
-    string line;
-    getline(file, line);
-    if (file.eof()) {
-        return false;
-    }
-    size_t pos;
-    req_addr = std::stoul(line, &pos, 16);
-
-    pos = line.find_first_not_of(' ', pos+1);
-
-    if (pos == string::npos || line.substr(pos)[0] == 'R')
-        req_type = Request::Type::READ;
-    else if (line.substr(pos)[0] == 'W')
-        req_type = Request::Type::WRITE;
-    else assert(false);
-    return true;
-}
diff --git a/ext/ramulator/Ramulator/src/Processor.h b/ext/ramulator/Ramulator/src/Processor.h
deleted file mode 100644
index 0cdc46427..000000000
--- a/ext/ramulator/Ramulator/src/Processor.h
+++ /dev/null
@@ -1,149 +0,0 @@
-#ifndef __PROCESSOR_H
-#define __PROCESSOR_H
-
-#include "Cache.h"
-#include "Config.h"
-#include "Memory.h"
-#include "Request.h"
-#include "Statistics.h"
-#include <iostream>
-#include <vector>
-#include <fstream>
-#include <string>
-#include <ctype.h>
-#include <functional>
-
-namespace ramulator 
-{
-
-class Trace {
-public:
-    Trace(const char* trace_fname);
-    // trace file format 1:
-    // [# of bubbles(non-mem instructions)] [read address(dec or hex)] <optional: write address(evicted cacheline)>
-    bool get_unfiltered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type);
-    bool get_filtered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type);
-    // trace file format 2:
-    // [address(hex)] [R/W]
-    bool get_dramtrace_request(long& req_addr, Request::Type& req_type);
-
-    long expected_limit_insts = 0;
-
-private:
-    std::ifstream file;
-    std::string trace_name;
-};
-
-
-class Window {
-public:
-    int ipc = 4;
-    int depth = 128;
-
-    Window() : ready_list(depth), addr_list(depth, -1) {}
-    bool is_full();
-    bool is_empty();
-    void insert(bool ready, long addr);
-    long retire();
-    void set_ready(long addr, int mask);
-
-private:
-    int load = 0;
-    int head = 0;
-    int tail = 0;
-    std::vector<bool> ready_list;
-    std::vector<long> addr_list;
-};
-
-
-class Core {
-public:
-    long clk = 0;
-    long retired = 0;
-    int id = 0;
-    function<bool(Request)> send;
-
-    Core(const Config& configs, int coreid,
-        const char* trace_fname,
-        function<bool(Request)> send_next, Cache* llc,
-        std::shared_ptr<CacheSystem> cachesys, MemoryBase& memory);
-    void tick();
-    void receive(Request& req);
-    void reset_stats();
-    double calc_ipc();
-    bool finished();
-    bool has_reached_limit();
-    long get_insts(); // the number of the instructions issued to the core
-    function<void(Request&)> callback;
-
-    bool no_core_caches = true;
-    bool no_shared_cache = true;
-    int l1_size = 1 << 15;
-    int l1_assoc = 1 << 3;
-    int l1_blocksz = 1 << 6;
-    int l1_mshr_num = 16;
-
-    int l2_size = 1 << 18;
-    int l2_assoc = 1 << 3;
-    int l2_blocksz = 1 << 6;
-    int l2_mshr_num = 16;
-    std::vector<std::shared_ptr<Cache>> caches;
-    Cache* llc;
-
-    ScalarStat record_cycs;
-    ScalarStat record_insts;
-    long expected_limit_insts;
-    // This is set true iff expected number of instructions has been executed or all instructions are executed.
-    bool reached_limit = false;
-
-private:
-    Trace trace;
-    Window window;
-
-    long bubble_cnt;
-    long req_addr = -1;
-    Request::Type req_type;
-    bool more_reqs;
-    long last = 0;
-
-    Cache* first_level_cache = nullptr;
-
-    ScalarStat memory_access_cycles;
-    ScalarStat cpu_inst;
-    MemoryBase& memory;
-};
-
-class Processor {
-public:
-    Processor(const Config& configs, vector<const char*> trace_list,
-        function<bool(Request)> send, MemoryBase& memory);
-    void tick();
-    void receive(Request& req);
-    void reset_stats();
-    bool finished();
-    bool has_reached_limit();
-    long get_insts(); // the total number of instructions issued to all cores
-
-    std::vector<std::unique_ptr<Core>> cores;
-    std::vector<double> ipcs;
-    double ipc = 0;
-
-    // When early_exit is true, the simulation exits when the earliest trace finishes.
-    bool early_exit;
-
-    bool no_core_caches = true;
-    bool no_shared_cache = true;
-
-    int l3_size = 1 << 23;
-    int l3_assoc = 1 << 3;
-    int l3_blocksz = 1 << 6;
-    int mshr_per_bank = 16;
-
-    std::shared_ptr<CacheSystem> cachesys;
-    Cache llc;
-
-    ScalarStat cpu_cycles;
-};
-
-}
-#endif /* __PROCESSOR_H */
diff --git a/ext/ramulator/Ramulator/src/Refresh.cpp b/ext/ramulator/Ramulator/src/Refresh.cpp
deleted file mode 100644
index b3b59ce7f..000000000
--- a/ext/ramulator/Ramulator/src/Refresh.cpp
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Refresh.cpp
- *
- * Mainly DSARP specialization at the moment.
- *
- *  Created on: Mar 17, 2015
- *      Author: kevincha
- */
-
-#include <stdlib.h>
-
-#include "Refresh.h"
-#include "Controller.h"
-#include "DRAM.h"
-#include "DSARP.h"
-
-using namespace std;
-using namespace ramulator;
-
-namespace ramulator {
-
-/**** DSARP specialization ****/
-template<>
-Refresh<DSARP>::Refresh(Controller<DSARP>* ctrl) : ctrl(ctrl) {
-  clk = refreshed = 0;
-  max_rank_count = ctrl->channel->children.size();
-  max_bank_count = ctrl->channel->spec->org_entry.count[(int)DSARP::Level::Bank];
-  max_sa_count = ctrl->channel->spec->org_entry.count[(int)DSARP::Level::SubArray];
-
-  // Init refresh counters
-  for (int r = 0; r < max_rank_count; r++) {
-    bank_ref_counters.push_back(0);
-    bank_refresh_backlog.push_back(new vector<int>(max_bank_count, 0));
-    vector<int> sa_counters(ctrl->channel->spec->org_entry.count[(int)DSARP::Level::SubArray], 0);
-    subarray_ref_counters.push_back(sa_counters);
-  }
-
-  level_chan = (int)DSARP::Level::Channel;
-  level_rank = (int)DSARP::Level::Rank;
-  level_bank = (int)DSARP::Level::Bank;
-  level_sa   = (int)DSARP::Level::SubArray;
-}
-
-template<>
-void Refresh<DSARP>::early_inject_refresh() {
-  // Only enabled during reads
-  if (ctrl->write_mode)
-    return;
-
-  // OoO bank-level refresh
-  vector<bool> is_bank_occupied(max_rank_count * max_bank_count, false);
-  Controller<DSARP>::Queue& rdq = ctrl->readq;
-
-  // Figure out which banks are idle in order to refresh one of them
-  for (auto req: rdq.q)
-  {
-    assert(req.addr_vec[level_chan] == ctrl->channel->id);
-    int ridx = req.addr_vec[level_rank] * max_bank_count;
-    int bidx = req.addr_vec[level_bank];
-    is_bank_occupied[ridx+bidx] = true;
-  }
-
-  // Try to pick an idle bank to refresh per rank
-  for (int r = 0; r < max_rank_count; r++) {
-    // Randomly pick a bank to examine
-    int bidx_start = rand() % max_bank_count;
-
-    for (int b = 0; b < max_bank_count; b++)
-    {
-      int bidx = (bidx_start + b) % max_bank_count;
-      // Idle cycle only
-      if (is_bank_occupied[(r * max_bank_count) + bidx])
-        continue;
-
-      // Pending refresh
-      bool pending_ref = false;
-      for (Request req : ctrl->otherq.q)
-        if (req.type == Request::Type::REFRESH
-            && req.addr_vec[level_chan] == ctrl->channel->id
-            && req.addr_vec[level_rank] == r && req.addr_vec[level_bank] == bidx)
-          pending_ref = true;
-      if (pending_ref)
-        continue;
-
-      // Only pull in refreshes when we are almost running out of credits
-      if ((*(bank_refresh_backlog[r]))[bidx] >= backlog_early_pull_threshold ||
-          ctrl->otherq.q.size() >= ctrl->otherq.max)
-        continue;
-
-      // Refresh now
-      refresh_target(ctrl, r, bidx, subarray_ref_counters[r][bidx]);
-      // One credit for delaying a future ref
-      (*(bank_refresh_backlog[r]))[bidx]++;
-      subarray_ref_counters[r][bidx] = (subarray_ref_counters[r][bidx]+1) % max_sa_count;
-      break;
-    }
-  }
-}
-
-template<>
-void Refresh<DSARP>::inject_refresh(bool b_ref_rank) {
-  // Rank-level refresh
-  if (b_ref_rank)
-    for (auto rank : ctrl->channel->children)
-      refresh_target(ctrl, rank->id, -1, -1);
-  // Bank-level refresh. Simultaneously issue to all ranks (better performance than staggered refreshes).
-  else {
-    for (auto rank : ctrl->channel->children) {
-      int rid = rank->id;
-      int bid = bank_ref_counters[rid];
-
-      // Behind refresh schedule by 1 ref
-      (*(bank_refresh_backlog[rid]))[bid]--;
-
-      // Next time, refresh the next bank in the same bank
-      bank_ref_counters[rid] = (bank_ref_counters[rid] + 1) % max_bank_count;
-
-      // Check to see if we can skip a refresh
-      if (ctrl->channel->spec->type == DSARP::Type::DARP ||
-        ctrl->channel->spec->type == DSARP::Type::DSARP) {
-
-        bool ref_now = false;
-        // 1. Any pending refrehes?
-        bool pending_ref = false;
-        for (Request req : ctrl->otherq.q) {
-          if (req.type == Request::Type::REFRESH) {
-            pending_ref = true;
-            break;
-          }
-        }
-
-        // 2. Track readq
-        if (!pending_ref && ctrl->readq.size() == 0)
-          ref_now = true;
-
-        // 3. Track log status. If we are too behind the schedule, then we need to refresh now.
-        if ((*(bank_refresh_backlog[rid]))[bid] <= backlog_min)
-          ref_now = true;
-
-        // Otherwise skip refresh
-        if (!ref_now)
-          continue;
-      }
-
-      refresh_target(ctrl, rid, bid, subarray_ref_counters[rid][bid]);
-      // Get 1 ref credit
-      (*(bank_refresh_backlog[rid]))[bid]++;
-      // Next time, refresh the next sa in the same bank
-      subarray_ref_counters[rid][bid] = (subarray_ref_counters[rid][bid]+1) % max_sa_count;
-    }
-  }
-  refreshed = clk;
-}
-
-// first = wrq.count; second = bank idx
-typedef pair<int, int> wrq_idx;
-bool wrq_comp (wrq_idx l, wrq_idx r)
-{
-  return l.first < r.first;
-}
-
-// WRP
-template<>
-void Refresh<DSARP>::wrp() {
-  for (int ref_rid = 0; ref_rid < max_rank_count; ref_rid++)
-  {
-    // Pending refresh in the rank?
-    bool pending_ref = false;
-    for (Request req : ctrl->otherq.q) {
-      if (req.type == Request::Type::REFRESH && req.addr_vec[level_rank] == ref_rid) {
-        pending_ref = true;
-        break;
-      }
-    }
-    if (pending_ref)
-      continue;
-
-    // Find the bank with the lowest number of writes+reads
-    vector<wrq_idx> sorted_bank_demand;
-    for (int b = 0; b < max_bank_count; b++)
-      sorted_bank_demand.push_back(wrq_idx(0,b));
-    // Filter out all the writes to this rank
-    int total_wr = 0;
-    for (auto req : ctrl->writeq.q) {
-      if (req.addr_vec[level_rank] == ref_rid) {
-        sorted_bank_demand[req.addr_vec[level_bank]].first++;
-        total_wr++;
-      }
-    }
-    // If there's no write, just skip.
-    if (total_wr == 0)
-      continue;
-
-    // Add read
-    for (auto req : ctrl->readq.q)
-      if (req.addr_vec[level_rank] == ref_rid)
-        sorted_bank_demand[req.addr_vec[level_bank]].first++;
-
-    // Sort based on the entries
-    std::sort(sorted_bank_demand.begin(), sorted_bank_demand.end(), wrq_comp);
-
-    // Randomly select an idle bank to refresh
-    int top_idle_idx = 0;
-    for (int i = 0; i < max_bank_count; i++) {
-      if (sorted_bank_demand[i].second != 0) {
-        top_idle_idx = i;
-        break;
-      }
-    }
-
-    // Select a bank to ref
-    int ref_bid_idx = (top_idle_idx == 0) ? 0 : rand() % top_idle_idx;
-    int ref_bid = sorted_bank_demand[ref_bid_idx].second;
-
-    // Make sure we don't exceed the credit
-    if ((*(bank_refresh_backlog[ref_rid]))[ref_bid] < backlog_max
-        && ctrl->otherq.q.size() < ctrl->otherq.max) {
-      refresh_target(ctrl, ref_rid, ref_bid, subarray_ref_counters[ref_rid][ref_bid]);
-      // Get 1 ref credit
-      (*(bank_refresh_backlog[ref_rid]))[ref_bid]++;
-      subarray_ref_counters[ref_rid][ref_bid] = (subarray_ref_counters[ref_rid][ref_bid]+1) % max_sa_count;
-    }
-  }
-}
-
-// OoO refresh of DSARP
-template<>
-void Refresh<DSARP>::tick_ref() {
-  clk++;
-
-  bool b_ref_rank = ctrl->channel->spec->b_ref_rank;
-  int refresh_interval =
-      (b_ref_rank) ?
-          ctrl->channel->spec->speed_entry.nREFI :
-          ctrl->channel->spec->speed_entry.nREFIpb;
-
-  // DARP
-  if (ctrl->channel->spec->type == DSARP::Type::DARP ||
-    ctrl->channel->spec->type == DSARP::Type::DSARP) {
-    // Write-Refresh Parallelization. Issue refreshes when the controller enters writeback mode
-    if (!ctrl_write_mode && ctrl->write_mode)
-      wrp();
-    // Record write mode
-    ctrl_write_mode = ctrl->write_mode;
-    // Inject early to pull in some refreshes during read mode
-    early_inject_refresh();
-  }
-
-  // Time to schedule a refresh and also try to skip some refreshes
-  if ((clk - refreshed) >= refresh_interval)
-    inject_refresh(b_ref_rank);
-}
-/**** End DSARP specialization ****/
-
-} /* namespace ramulator */
diff --git a/ext/ramulator/Ramulator/src/Refresh.h b/ext/ramulator/Ramulator/src/Refresh.h
deleted file mode 100644
index 66d03040b..000000000
--- a/ext/ramulator/Ramulator/src/Refresh.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Refresh.h
- *
- * This is a refresh scheduler. A list of refresh policies implemented:
- *
- * 1. All-bank refresh
- * 2. Per-bank refresh (only DSARP memory module has been completed to work with REFpb).
- *     The other modules (LPDDRx) have not been updated to pass a knob to turn on/off REFpb.
- * 3. A re-implementation of DSARP from the refresh mechanisms proposed in Chang et al.,
- * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA 2014.
- *
- *  Created on: Mar 17, 2015
- *      Author: kevincha
- */
-
-#ifndef __REFRESH_H_
-#define __REFRESH_H_
-
-#include <stddef.h>
-#include <cassert>
-#include <iostream>
-#include <vector>
-
-#include "Request.h"
-#include "DSARP.h"
-#include "ALDRAM.h"
-
-using namespace std;
-using namespace ramulator;
-
-namespace ramulator {
-
-template <typename T>
-class Controller;
-
-template <typename T>
-class Refresh {
-public:
-  Controller<T>* ctrl;
-  long clk, refreshed;
-  // daz3
-  typedef struct _ref_cnt {
-      int rank_id;
-      long refreshed;
-      _ref_cnt(int _id, long _refreshed) {
-          rank_id = _id;
-          refreshed = _refreshed;
-      }
-  }RefCounter;
-  vector<RefCounter> refreshed_counters;
-
-  // Per-bank refresh counter to track the refresh progress for each rank
-  vector<int> bank_ref_counters;
-  int max_rank_count, max_bank_count;
-  int level_chan, level_rank, level_bank, level_sa;
-
-  // ctor
-  Refresh(Controller<T>* ctrl) : ctrl(ctrl) {
-    clk = refreshed = 0;
-    max_rank_count = ctrl->channel->children.size();
-    max_bank_count = ctrl->channel->spec->org_entry.count[(int)T::Level::Bank];
-
-    // Init refresh counters
-    for (int r = 0; r < max_rank_count; r++) {
-      bank_ref_counters.push_back(0);
-      bank_refresh_backlog.push_back(new vector<int>(max_bank_count, 0));
-    }
-
-    level_chan = (int)T::Level::Channel;
-    level_rank = (int)T::Level::Rank;
-    level_bank = (int)T::Level::Bank;
-    level_sa   = -1; // Most DRAM doesn't have subarray level
-
-    // daz3
-    int i = 0;
-    for (auto rank : ctrl->channel->children)
-    {
-        refreshed_counters.push_back(RefCounter(rank->id, (long)((ctrl->channel->spec->speed_entry.nREFI/ctrl->channel->spec->speed_entry.tCK)/max_rank_count) * (i+1) - ctrl->channel->spec->speed_entry.nREFI));
-        i++;
-    }
-  }
-
-  // dtor
-  virtual ~Refresh() {
-    // Clean up backlog
-    for (unsigned int i = 0; i < bank_refresh_backlog.size(); i++)
-      delete bank_refresh_backlog[i];
-  }
-
-  // Basic refresh scheduling for all bank refresh that is applicable to all DRAM types
-  // void tick_ref() {
-  //   clk++;
-  //
-  //   int refresh_interval = ctrl->channel->spec->speed_entry.nREFI;
-  //
-  //   // Time to schedule a refresh
-  //   if ((clk - refreshed) >= refresh_interval) {
-  //     inject_refresh(true);
-  //     // ALDRAM: update timing parameters based on temperatures
-  //     ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-  //     ctrl->update_temp(current_temperature);
-  //   }
-  // }
-  // daz3: stackle refresh
-  void tick_ref() {
-    clk++;
-    int refresh_interval = ctrl->channel->spec->speed_entry.nREFI;
-    // Time to schedule a refresh
-    for(int i = 0; i < max_rank_count; i++)
-    {
-        if ((clk - refreshed_counters[i].refreshed) >= refresh_interval) {
-            refresh_target(ctrl, refreshed_counters[i].rank_id, -1, -1);
-            // ALDRAM: update timing parameters based on temperatures
-            ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-            ctrl->update_temp(current_temperature);
-            refreshed_counters[i].refreshed = clk;
-        }
-    }
-  }
-
-private:
-  // Keeping track of refresh status of every bank: + means ahead of schedule, - means behind schedule
-  vector<vector<int>*> bank_refresh_backlog;
-  // Keeping track of which subarray to refresh next
-  vector<vector<int>> subarray_ref_counters;
-  int max_sa_count = 0;
-  // As defined in the standards
-  int backlog_max = 8;
-  int backlog_min = -8;
-  int backlog_early_pull_threshold = -6;
-  bool ctrl_write_mode = false;
-
-  // Refresh based on the specified address
-  void refresh_target(Controller<T>* ctrl, int rank, int bank, int sa)
-  {
-    vector<int> addr_vec(int(T::Level::MAX), -1);
-    addr_vec[0] = ctrl->channel->id;
-    addr_vec[1] = rank;
-    addr_vec[2] = bank;
-    addr_vec[3] = sa;
-    Request req(addr_vec, Request::Type::REFRESH, NULL);
-    bool res = ctrl->enqueue(req);
-    assert(res);
-  }
-
-  // Inject refresh at either rank or bank level
-  void inject_refresh(bool b_ref_rank) {
-    // Rank-level refresh
-    if (b_ref_rank) {
-      for (auto rank : ctrl->channel->children)
-        refresh_target(ctrl, rank->id, -1, -1);
-    }
-    // Bank-level refresh. Simultaneously issue to all ranks (better performance than staggered refreshes).
-    else {
-      for (auto rank : ctrl->channel->children)
-        refresh_target(ctrl, rank->id, bank_ref_counters[rank->id], -1);
-    }
-    refreshed = clk;
-  }
-
-  // DSARP
-  void early_inject_refresh();
-  void wrp();
-};
-
-// Declaration of specialized constructor and tick_ref, so the compiler knows
-// where to look for these definitions when controller calls them!
-template<> Refresh<DSARP>::Refresh(Controller<DSARP>* ctrl);
-template<> void Refresh<DSARP>::tick_ref();
-
-} /* namespace ramulator */
-
-#endif /* SRC_REFRESH_H_ */
diff --git a/ext/ramulator/Ramulator/src/Request.h b/ext/ramulator/Ramulator/src/Request.h
deleted file mode 100644
index da733961b..000000000
--- a/ext/ramulator/Ramulator/src/Request.h
+++ /dev/null
@@ -1,103 +0,0 @@
-#ifndef __REQUEST_H
-#define __REQUEST_H
-
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class Request
-{
-public:
-    bool is_first_command;
-    long addr;
-    // long addr_row;
-    vector<int> addr_vec;
-    // specify which core this request sent from, for virtual address translation
-    int coreid;
-
-    enum class Type
-    {
-        READ,
-        WRITE,
-        REFRESH,
-        POWERDOWN,
-        SELFREFRESH,
-        EXTENSION,
-        MAX
-    } type;
-
-    long arrive = -1;
-    long depart;
-    function<void(Request&)> callback; // call back with more info
-    // gagan : is prefetch
-    bool is_prefetch;
-
- Request(long addr, Type type, int coreid = 0)
-      : is_first_command(true), addr(addr), coreid(coreid), type(type), callback([](Request& req){}), is_prefetch(false) {}
-
- Request(long addr, Type type, function<void(Request&)> callback,  bool is_prefetch, int coreid = 0)
-   : is_first_command(true), addr(addr), coreid(coreid), type(type), callback(callback), is_prefetch(is_prefetch) {}
-
- Request(vector<int>& addr_vec, Type type, function<void(Request&)> callback, bool is_prefetch = false, int coreid = 0)
-      : is_first_command(true), addr_vec(addr_vec), coreid(coreid), type(type), callback(callback) {}
-
-    Request()
-        : is_first_command(true), coreid(0) {}
-
-    void print()
-    {
-      switch(type)
-	{
-	case Request::Type::READ:
-	  std::cout << "[READ] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::WRITE:
-	  assert(is_prefetch == false);
-	  std::cout << "[WRITE] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::REFRESH:
-	  assert(is_prefetch == false);
-	  std::cout << "[REFRESH] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::POWERDOWN:
-	  assert(is_prefetch == false);
-	  std::cout << "[POWERDOWN] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::SELFREFRESH:
-	  assert(is_prefetch == false);
-	  std::cout << "[SELFREFRESH] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::EXTENSION:
-	  assert(is_prefetch == false);
-	  std::cout << "[EXTENSION] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	case Request::Type::MAX:
-	  assert(is_prefetch == false);
-	  std::cout << "[MAX] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-	  break;
-	default:
-	  std::cout << "Invalid Request" << std::endl;
-	}
-    }
-
-    int getRank()
-    {
-      return addr_vec[1];
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__REQUEST_H*/
-
diff --git a/ext/ramulator/Ramulator/src/SALP.cpp b/ext/ramulator/Ramulator/src/SALP.cpp
deleted file mode 100644
index 843e5f6d8..000000000
--- a/ext/ramulator/Ramulator/src/SALP.cpp
+++ /dev/null
@@ -1,648 +0,0 @@
-#include "SALP.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace ramulator;
-
-string SALP::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Sa", "Ro", "Co"};
-
-map<string, enum SALP::Org> SALP::org_map = {
-    {"SALP_512Mb_x4", SALP::Org::SALP_512Mb_x4}, {"SALP_512Mb_x8", SALP::Org::SALP_512Mb_x8}, {"SALP_512Mb_x16", SALP::Org::SALP_512Mb_x16},
-    {"SALP_1Gb_x4", SALP::Org::SALP_1Gb_x4}, {"SALP_1Gb_x8", SALP::Org::SALP_1Gb_x8}, {"SALP_1Gb_x16", SALP::Org::SALP_1Gb_x16},
-    {"SALP_2Gb_x4", SALP::Org::SALP_2Gb_x4}, {"SALP_2Gb_x8", SALP::Org::SALP_2Gb_x8}, {"SALP_2Gb_x16", SALP::Org::SALP_2Gb_x16},
-    {"SALP_4Gb_x4", SALP::Org::SALP_4Gb_x4}, {"SALP_4Gb_x8", SALP::Org::SALP_4Gb_x8}, {"SALP_4Gb_x16", SALP::Org::SALP_4Gb_x16},
-    {"SALP_8Gb_x4", SALP::Org::SALP_8Gb_x4}, {"SALP_8Gb_x8", SALP::Org::SALP_8Gb_x8}, {"SALP_8Gb_x16", SALP::Org::SALP_8Gb_x16},
-};
-
-map<string, enum SALP::Speed> SALP::speed_map = {
-    {"SALP_800D", SALP::Speed::SALP_800D}, {"SALP_800E", SALP::Speed::SALP_800E},
-    {"SALP_1066E", SALP::Speed::SALP_1066E}, {"SALP_1066F", SALP::Speed::SALP_1066F}, {"SALP_1066G", SALP::Speed::SALP_1066G},
-    {"SALP_1333G", SALP::Speed::SALP_1333G}, {"SALP_1333H", SALP::Speed::SALP_1333H},
-    {"SALP_1600H", SALP::Speed::SALP_1600H}, {"SALP_1600J", SALP::Speed::SALP_1600J}, {"SALP_1600K", SALP::Speed::SALP_1600K},
-    {"SALP_1866K", SALP::Speed::SALP_1866K}, {"SALP_1866L", SALP::Speed::SALP_1866L},
-    {"SALP_2133L", SALP::Speed::SALP_2133L}, {"SALP_2133M", SALP::Speed::SALP_2133M},
-};
-
-map<string, enum SALP::Type> SALP::type_map = {
-    {"SALP-1", SALP::Type::SALP_1},
-    {"SALP-2", SALP::Type::SALP_2},
-    {"SALP-MASA", SALP::Type::MASA},
-};
-
-SALP::SALP(Org org, Speed speed, Type type, int n_sa) :
-    type(type),
-    n_sa(n_sa),
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    switch(int(type)){
-        case int(Type::SALP_1): standard_name = "SALP-1"; break;
-        case int(Type::SALP_2): standard_name = "SALP-2"; break;
-        case int(Type::MASA):   standard_name = "SALP-MASA"; break;
-    }
-    if (type == Type::SALP_1) {
-      scope[int(Command::PRE)] = Level::Bank;
-    }
-    assert(n_sa && n_sa <= 128 && (n_sa & (n_sa-1)) == 0); // is power of 2, within [1, 128]
-    org_entry.count[int(Level::SubArray)] = n_sa;
-    long tmp = long(org_entry.dq) * org_entry.count[int(Level::Bank)] * n_sa * org_entry.count[int(Level::Column)];
-    org_entry.count[int(Level::Row)] = long(org_entry.size) * (1<<20) / tmp;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-SALP::SALP(const string& org_str, const string& speed_str, const string& type_str, int n_sa) :
-    SALP(org_map[org_str], speed_map[speed_str], type_map[type_str], n_sa)
-{
-}
-
-void SALP::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void SALP::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void SALP::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void SALP::init_prereq()
-{
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-
-    switch(int(type)){
-        case int(Type::SALP_1):
-            prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return Command::ACT;
-                    case int(State::Opened):
-                        return Command::MAX;
-                    default: assert(false);}};
-            prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-              if (node->row_state.find(id) != node->row_state.end()) {
-                return cmd;
-              } else if (node->row_state.size()) {
-                return Command::PRE;
-              } else {
-                return Command::PRE_OTHER;
-              }
-            };
-            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                for (auto bank : node->children) {
-                    if (bank->state == State::Closed)
-                        continue;
-                    return Command::PRER;
-                }
-                return Command::REF;};
-            break;
-        case int(Type::SALP_2):
-            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return Command::ACT;
-                    case int(State::Opened):
-                        if (node->row_state.find(id) != node->row_state.end()) {
-                          for (auto sa : node->parent->children) {
-                              if (sa != node && sa->state == State::Opened) {
-                                  return Command::PRE_OTHER;
-                              }
-                          }
-                          return cmd;
-                        } else {
-                          // if this subarray has another row open, close it
-                          // first
-                          return Command::PRE;
-                        }
-                    default: assert(false);}};
-            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        if (sa->state == State::Closed)
-                            continue;
-                        return Command::PRER;
-                    }
-                return Command::REF;};
-            break;
-        case int(Type::MASA):
-            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return Command::ACT;
-                    case int(State::Opened):
-                        if (node->row_state.find(id) != node->row_state.end()) return Command::SASEL;
-                        else return Command::PRE;
-                    case int(State::Selected):
-                        if (node->row_state.find(id) != node->row_state.end()) return cmd;
-                        else return Command::PRE;
-                    default: assert(false);
-                }};
-            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children){
-                        if (sa->state == State::Closed)
-                            continue;
-                        return Command::PRER;
-                    }
-                return Command::REF;};
-            break;
-        default: assert(false);
-    }
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void SALP::init_rowhit()
-{
-    switch(int(type)) {
-        case int(Type::SALP_1):
-            // RD
-            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-              switch (int(node->state)) {
-                case int(State::Closed): return false;
-                case int(State::Opened):
-                  if (node->row_state.find(id) != node->row_state.end())  return true;
-                  else return false;
-                default: assert(false);
-              }
-            };
-            // WR
-            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-            break;
-        case int(Type::SALP_2):
-            // RD
-            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened):
-                        if (node->row_state.find(id) != node->row_state.end()) return true;
-                        else return false;
-                    default: assert(false);
-                }};
-            // WR
-            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-            break;
-        case int(Type::MASA):
-            // RD
-            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened):
-                        // opened but not selected still counts as a row hit
-                        if (node->row_state.find(id) != node->row_state.end()) return true;
-                        else return false;
-                    case int(State::Selected):
-                        if (node->row_state.find(id) != node->row_state.end()) return true;
-                        else return false;
-                    default: assert(false);
-                }};
-            // WR
-            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-            break;
-        default: assert(false);
-    }
-}
-
-void SALP::init_rowopen()
-{
-    switch(int(type)) {
-        case int(Type::SALP_1):
-            // RD
-            rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened): return true;
-                    default: assert(false);
-                }};
-            // WR
-            rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-            break;
-        case int(Type::SALP_2):
-            // RD
-            rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened): return true;
-                    default: assert(false);
-                }};
-            // WR
-            rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-            break;
-        case int(Type::MASA):
-            // RD
-            rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-                switch (int(node->state)){
-                    case int(State::Closed): return false;
-                    case int(State::Opened): return true;
-                    case int(State::Selected): return true;
-                    default: assert(false);
-                }};
-            // WR
-            rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-            break;
-        default: assert(false);
-    }
-}
-
-void SALP::init_lambda()
-{
-    switch(int(type)){
-        case int(Type::SALP_1):
-            lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Opened;
-            };
-            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-              node->state = State::Opened;
-              node->row_state[id] = State::Opened;
-            };
-            lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                // For SALP_1, we stick to original design that allows
-                // only one row in a bank open, so here close subarray id
-                // is equivalent to close the whole bank
-                node->children[id]->state = State::Closed;
-                node->children[id]->row_state.clear();
-                };
-            lambda[int(Level::Bank)][int(Command::PRE_OTHER)] = lambda[int(Level::Bank)][int(Command::PRE)];
-            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children) {
-                    bank->state = State::Closed;
-                    for (auto sa : bank->children){
-                        sa->state = State::Closed;
-                        sa->row_state.clear();}}};
-            lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->children[id]->state = State::Closed;
-                node->children[id]->row_state.clear();};
-            lambda[int(Level::Bank)][int(Command::WRA)] = lambda[int(Level::Bank)][int(Command::RDA)];
-            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children) {
-                    if (bank->state == State::Closed)
-                        continue;
-                    node->state = State::ActPowerDown;
-                    return;
-                }
-                node->state = State::PrePowerDown;};
-            break;
-        case int(Type::SALP_2):
-            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Opened;
-                node->row_state[id] = State::Opened;};
-            lambda[int(Level::SubArray)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::SubArray)][int(Command::PRE_OTHER)] = lambda[int(Level::SubArray)][int(Command::PRE)];
-            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        sa->state = State::Closed;
-                        sa->row_state.clear();}};
-            lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        if (sa->state == State::Closed)
-                            continue;
-                        node->state = State::ActPowerDown;
-                        return;
-                    }
-                node->state = State::PrePowerDown;};
-            break;
-        case int(Type::MASA):
-            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Selected;
-                node->row_state[id] = State::Opened;
-                for (auto sa : node->parent->children)
-                    if (sa != node && sa->state == State::Selected) {
-                        sa->state = State::Opened;
-                        break;}};
-            lambda[int(Level::SubArray)][int(Command::SASEL)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Selected;
-                for (auto sa : node->parent->children)
-                    if (sa != node && sa->state == State::Selected) {
-                        sa->state = State::Opened;
-                        break;}};
-            lambda[int(Level::SubArray)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-
-            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        sa->state = State::Closed;
-                        sa->row_state.clear();}};
-            lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<SALP>* node, int id) {
-                node->state = State::Closed;
-                node->row_state.clear();};
-            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-                for (auto bank : node->children)
-                    for (auto sa : bank->children) {
-                        if (sa->state == State::Closed)
-                            continue;
-                        node->state = State::ActPowerDown;
-                        return;
-                    }
-                node->state = State::PrePowerDown;};
-            break;
-        default: assert(false);
-    }
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<SALP>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<SALP>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<SALP>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-void SALP::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PRER
-    t[int(Command::RD)].push_back({Command::PRER, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRER, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> REF: none (all banks have to be precharged)
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-
-    t[int(Command::ACT)].push_back({Command::PRER, 1, s.nRAS});
-    t[int(Command::PRER)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PRER)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PRE_OTHER)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRER, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PRER)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PRE_OTHER)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    switch(int(type)) {
-        case int(Type::SALP_1):
-          // memory controller doesn't specify a row to precharge,
-          // all subarrays are precharged together, so we should check
-          // whether other activation/column access are still ongoing.
-          t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-          t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-          t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR,});
-          t[int(Command::ACT)].push_back({Command::PRE_OTHER, 1, s.nRAS});
-          t[int(Command::RD)].push_back({Command::PRE_OTHER, 1, s.nRTP});
-          t[int(Command::WR)].push_back({Command::PRE_OTHER, 1, s.nCWL + s.nBL + s.nWR,});
-        case int(Type::SALP_2):
-        case int(Type::MASA):
-        break;
-        default: assert(false);
-    }
-
-    /*** SubArray ***/
-    t = timing[int(Level::SubArray)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-
-    switch(int(type)) {
-        case int(Type::SALP_1):
-        case int(Type::SALP_2):
-        break;
-        case int(Type::MASA):
-          t[int(Command::SASEL)].push_back({Command::RD, 1, s.nSCD});
-          t[int(Command::SASEL)].push_back({Command::RDA, 1, s.nSCD});
-          t[int(Command::SASEL)].push_back({Command::WR, 1, s.nSCD});
-          t[int(Command::SASEL)].push_back({Command::WRA, 1, s.nSCD});
-        break;
-        default: assert(false);
-    }
-
-    // sibling subarray constraints
-    switch(int(type)) {
-        case int(Type::SALP_1):
-          t[int(Command::PRE)].push_back({Command::ACT, 1, s.nPA, true});
-          t[int(Command::PRE_OTHER)].push_back({Command::ACT, 1, s.nPA, true});
-          // for auto precharge command
-          t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC - s.nRP + s.nPA, true});
-          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nPA, true});
-          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nPA, true});
-        break;
-
-        case int(Type::SALP_2):
-          t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRCD + s.nRA, true});
-          t[int(Command::RD)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::ACT, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nWA, true});
-        break;
-        case int(Type::MASA):
-          t[int(Command::RD)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::ACT, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nWA, true});
-
-          t[int(Command::RD)].push_back({Command::SASEL, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::SASEL, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::SASEL, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::SASEL, 1, s.nWA, true});
-
-          t[int(Command::RD)].push_back({Command::RD, 1, s.nRA, true});
-          t[int(Command::RDA)].push_back({Command::RDA, 1, s.nRA, true});
-          t[int(Command::WR)].push_back({Command::WR, 1, s.nWA, true});
-          t[int(Command::WRA)].push_back({Command::WRA, 1, s.nWA, true});
-        break;
-        default: assert(false);
-    }
-    // between sibling subarrays
-}
diff --git a/ext/ramulator/Ramulator/src/SALP.h b/ext/ramulator/Ramulator/src/SALP.h
deleted file mode 100644
index 8eceb5a94..000000000
--- a/ext/ramulator/Ramulator/src/SALP.h
+++ /dev/null
@@ -1,231 +0,0 @@
-#ifndef __SALP_H
-#define __SALP_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class SALP
-{
-public:
-    string standard_name;
-    enum class Org;
-    enum class Speed;
-    enum class Type;
-    SALP(Org org, Speed speed, Type type = Type::MASA, int n_sa = 8);
-    SALP(const string& org_str, const string& speed_str, const string& type_str = "SALP-MASA", int n_sa = 8);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    static map<string, enum Type> type_map;
-
-    enum class Type : int
-    {
-        SALP_1, SALP_2, MASA, MAX
-    } type;
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, SubArray, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, SASEL, PRE, PRER, // precharge bank/bank/rank(SALP-1), subarray/bank/rank(SALP-2, MASA)
-        RD,  WR,    RDA, WRA, // auto-precharge: bank(SALP-1), subarray(SALP-2, MASA)
-        REF, PDE,   PDX, SRE, SRX, 
-        PRE_OTHER,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "SASEL", "PRE", "PRER",
-        "RD",  "WR",    "RDA", "WRA",
-        "REF", "PDE",   "PDX", "SRE", "SRX", "PRE_OTHER"
-    };
-
-    // The scope of each command
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::SubArray, Level::SubArray, Level::Rank,
-        Level::Column, Level::Column,   Level::Column,   Level::Column,
-        Level::Rank,   Level::Rank,     Level::Rank,     Level::Rank,   Level::Rank, Level::SubArray
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRER):
-            case int(Command::PRE_OTHER):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, Selected, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<SALP>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<SALP>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<SALP>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<SALP>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        SALP_512Mb_x4, SALP_512Mb_x8, SALP_512Mb_x16,
-        SALP_1Gb_x4,   SALP_1Gb_x8,   SALP_1Gb_x16,
-        SALP_2Gb_x4,   SALP_2Gb_x8,   SALP_2Gb_x16,
-        SALP_4Gb_x4,   SALP_4Gb_x8,   SALP_4Gb_x16,
-        SALP_8Gb_x4,   SALP_8Gb_x8,   SALP_8Gb_x16,
-        MAX
-    };
-
-    int n_sa; // number of subarrays per bank
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 0, 0, 1<<11}}, {  512,  8, {0, 0, 8, 0, 0, 1<<10}}, {  512, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {1<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {1<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {2<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {2<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {4<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {4<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 0, 0, 1<<12}}, {8<<10,  8, {0, 0, 8, 0, 0, 1<<11}}, {8<<10, 16, {0, 0, 8, 0, 0, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        SALP_800D,  SALP_800E,
-        SALP_1066E, SALP_1066F, SALP_1066G,
-        SALP_1333G, SALP_1333H,
-        SALP_1600H, SALP_1600J, SALP_1600K,
-        SALP_1866K, SALP_1866L,
-        SALP_2133L, SALP_2133M,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nPA, nCWL; // nRP for pre2act same sa, nPA for pre2act diff sa (1 cycle)
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR, nRA, nWA; // nRA = nCL/2, nWA = nCWL + nBL + nWR/2
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-        int nSCD;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5, 1,  5, 15, 20, 4, 4,  6, 3, 12, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512, 1},
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6, 1,  5, 15, 21, 4, 4,  6, 3, 12, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512, 1},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6, 1,  6, 20, 26, 4, 4,  8, 3, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7, 1,  6, 20, 27, 4, 4,  8, 4, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8, 1,  6, 20, 28, 4, 4,  8, 4, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8, 1,  7, 24, 32, 5, 5, 10, 4, 16, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512, 1},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9, 1,  7, 24, 33, 5, 5, 10, 5, 16, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512, 1},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9, 1,  8, 28, 37, 6, 6, 12, 5, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10, 1,  8, 28, 38, 6, 6, 12, 5, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11, 1,  8, 28, 39, 6, 6, 12, 6, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11, 1,  9, 32, 43, 7, 7, 14, 6, 20, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512, 1},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12, 1,  9, 32, 44, 7, 7, 14, 6, 20, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512, 1},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 1, 10, 36, 48, 8, 8, 16, 6, 22, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512, 1},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 1, 10, 36, 49, 8, 8, 16, 7, 22, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512, 1}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__SALP_H*/
diff --git a/ext/ramulator/Ramulator/src/STTMRAM.cpp b/ext/ramulator/Ramulator/src/STTMRAM.cpp
deleted file mode 100644
index 830867cfd..000000000
--- a/ext/ramulator/Ramulator/src/STTMRAM.cpp
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Kazi Asifuzzaman, Rommel Sanchez Verdejo, and Petar Radojkovic.2017.
-* Enabling a reliable STT-MRAM main memory simulation.
-* In Proceedings of the International Symposium on Memory Systems (MEMSYS '17).
-* Washington DC, USA, 283-292. DOI: https://doi.org/10.1145/3132402.3132416
-*
-*/
-#include "STTMRAM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-#include <math.h>
-
-using namespace std;
-using namespace ramulator;
-
-string STTMRAM::standard_name = "STTMRAM";
-string STTMRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum STTMRAM::Org> STTMRAM::org_map = {
-    {"STTMRAM_512Mb_x4", STTMRAM::Org::STTMRAM_512Mb_x4}, {"STTMRAM_512Mb_x8", STTMRAM::Org::STTMRAM_512Mb_x8}, {"STTMRAM_512Mb_x16", STTMRAM::Org::STTMRAM_512Mb_x16},
-    {"STTMRAM_1Gb_x4", STTMRAM::Org::STTMRAM_1Gb_x4}, {"STTMRAM_1Gb_x8", STTMRAM::Org::STTMRAM_1Gb_x8}, {"STTMRAM_1Gb_x16", STTMRAM::Org::STTMRAM_1Gb_x16},
-    {"STTMRAM_2Gb_x4", STTMRAM::Org::STTMRAM_2Gb_x4}, {"STTMRAM_2Gb_x8", STTMRAM::Org::STTMRAM_2Gb_x8}, {"STTMRAM_2Gb_x16", STTMRAM::Org::STTMRAM_2Gb_x16},
-    {"STTMRAM_4Gb_x4", STTMRAM::Org::STTMRAM_4Gb_x4}, {"STTMRAM_4Gb_x8", STTMRAM::Org::STTMRAM_4Gb_x8}, {"STTMRAM_4Gb_x16", STTMRAM::Org::STTMRAM_4Gb_x16},
-    {"STTMRAM_8Gb_x4", STTMRAM::Org::STTMRAM_8Gb_x4}, {"STTMRAM_8Gb_x8", STTMRAM::Org::STTMRAM_8Gb_x8}, {"STTMRAM_8Gb_x16", STTMRAM::Org::STTMRAM_8Gb_x16},
-};
-
-map<string, enum STTMRAM::Speed> STTMRAM::speed_map = {
-    {"STT_1600_1_2", STTMRAM::Speed::STT_1600_1_2}, {"STT_1600_1_5", STTMRAM::Speed::STT_1600_1_5}, {"STT_1600_2_0", STTMRAM::Speed::STT_1600_2_0},
-};
-
-
-STTMRAM::STTMRAM(Org org, Speed speed) :
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-STTMRAM::STTMRAM(const string& org_str, const string& speed_str) :
-    STTMRAM(org_map[org_str], speed_map[speed_str])
-{
-}
-
-void STTMRAM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void STTMRAM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void STTMRAM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-          case 1600: speed_entry.nRRD = ceil(speed_entry.nRRD  * ((page==1) ? 5 : 6) /10.0); speed_entry.nFAW = ceil(speed_entry.nFAW *((page==1) ? 24 : 32)/10.0); break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 1600: speed_entry.nRFC = 1; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-          case 1600: speed_entry.nXS  = ceil(speed_entry.nXS * ((chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288) /10.0); break;
-        default: assert(false);
-    }
-}
-
-
-void STTMRAM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PREA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }};
-}
-
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void STTMRAM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void STTMRAM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void STTMRAM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<STTMRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<STTMRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<STTMRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<STTMRAM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<STTMRAM>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void STTMRAM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/STTMRAM.h b/ext/ramulator/Ramulator/src/STTMRAM.h
deleted file mode 100644
index 1698b1a52..000000000
--- a/ext/ramulator/Ramulator/src/STTMRAM.h
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
-*
-* The timing parameters used in this file are provided by the following study:
-* Kazi Asifuzzaman, Rommel Sanchez Verdejo, and Petar Radojkovic.2017.
-* Enabling a reliable STT-MRAM main memory simulation.
-* In Proceedings of the International Symposium on Memory Systems (MEMSYS '17).
-* Washington DC, USA, 283-292. DOI: https://doi.org/10.1145/3132402.3132416
-*
-*/
-#ifndef __STTMRAM_H
-#define __STTMRAM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class STTMRAM
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    STTMRAM(Org org, Speed speed);
-    STTMRAM(const string& org_str, const string& speed_str);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD,  WR,  RDA,  WRA,
-        REF, PDE, PDX,  SRE, SRX,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD",  "WR",  "RDA",  "WRA",
-        "REF", "PDE", "PDX",  "SRE", "SRX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PREA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<STTMRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<STTMRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<STTMRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<STTMRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        STTMRAM_512Mb_x4, STTMRAM_512Mb_x8, STTMRAM_512Mb_x16,
-        STTMRAM_1Gb_x4,   STTMRAM_1Gb_x8,   STTMRAM_1Gb_x16,
-        STTMRAM_2Gb_x4,   STTMRAM_2Gb_x8,   STTMRAM_2Gb_x16,
-        STTMRAM_4Gb_x4,   STTMRAM_4Gb_x8,   STTMRAM_4Gb_x16,
-        STTMRAM_8Gb_x4,   STTMRAM_8Gb_x8,   STTMRAM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        STT_1600_1_2, STT_1600_1_5, STT_1600_2_0,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-    } speed_table[int(Speed::MAX)] = {
-          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 14,  14,  8,   20,   34,  6,    6,   12,  12,   12,   1,    6240, 4, 5, 20,        5,     0,   512}, //1.2x
-          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 17,  17,  8,   23,   40,  6,    6,   12,  15,   15,   1,    6240, 4, 5, 20,        5,     0,   512}, //1.5x
-          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 22,  22,  8,   28,   50,  6,    6,   12,  20,   20,   1,    6240, 4, 5, 20,        5,     0,   512}, //2.0x
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__STTMRAM_H*/
diff --git a/ext/ramulator/Ramulator/src/Scheduler.h b/ext/ramulator/Ramulator/src/Scheduler.h
deleted file mode 100644
index 0a328c3d9..000000000
--- a/ext/ramulator/Ramulator/src/Scheduler.h
+++ /dev/null
@@ -1,357 +0,0 @@
-#ifndef __SCHEDULER_H
-#define __SCHEDULER_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include "Controller.h"
-#include <vector>
-#include <map>
-#include <list>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class Controller;
-
-template <typename T>
-class Scheduler
-{
-public:
-    Controller<T>* ctrl;
-
-    enum class Type {
-      FCFS, FRFCFS, FRFCFS_Cap, FRFCFS_PriorHit, FRFCFS_DepPre, MAX
-    } type = Type::FRFCFS_PriorHit;
-    //} type = Type::FCFS;
-
-    long cap = 16;
-
-    Scheduler(Controller<T>* ctrl) : ctrl(ctrl) {}
-
-    list<Request>::iterator get_head(list<Request>& q)
-    {
-      // TODO make the decision at compile time
-      if (type != Type::FRFCFS_PriorHit) {
-        if (!q.size())
-            return q.end();
-
-        auto head = q.begin();
-        for (auto itr = next(q.begin(), 1); itr != q.end(); itr++)
-            head = compare[int(type)](head, itr);
-
-        return head;
-      } else {
-        if (!q.size())
-            return q.end();
-
-        auto head = q.begin();
-        for (auto itr = next(q.begin(), 1); itr != q.end(); itr++) {
-            head = compare[int(Type::FRFCFS_PriorHit)](head, itr);
-        }
-
-        if (this->ctrl->is_ready(head) && this->ctrl->is_row_hit(head)) {
-          return head;
-        }
-
-        // prepare a list of hit request
-        vector<vector<int>> hit_reqs;
-        for (auto itr = q.begin() ; itr != q.end() ; ++itr) {
-          if (this->ctrl->is_row_hit(itr)) {
-            auto begin = itr->addr_vec.begin();
-            // TODO Here it assumes all DRAM standards use PRE to close a row
-            // It's better to make it more general.
-            auto end = begin + int(ctrl->channel->spec->scope[int(T::Command::PRE)]) + 1;
-            vector<int> rowgroup(begin, end); // bank or subarray
-            hit_reqs.push_back(rowgroup);
-          }
-        }
-        // if we can't find proper request, we need to return q.end(),
-        // so that no command will be scheduled
-        head = q.end();
-        for (auto itr = q.begin(); itr != q.end(); itr++) {
-          bool violate_hit = false;
-          if ((!this->ctrl->is_row_hit(itr)) && this->ctrl->is_row_open(itr)) {
-            // so the next instruction to be scheduled is PRE, might violate hit
-            auto begin = itr->addr_vec.begin();
-            // TODO Here it assumes all DRAM standards use PRE to close a row
-            // It's better to make it more general.
-            auto end = begin + int(ctrl->channel->spec->scope[int(T::Command::PRE)]) + 1;
-            vector<int> rowgroup(begin, end); // bank or subarray
-            for (const auto& hit_req_rowgroup : hit_reqs) {
-              if (rowgroup == hit_req_rowgroup) {
-                  violate_hit = true;
-                  break;
-              }
-            }
-          }
-          if (violate_hit) {
-            continue;
-          }
-          // If it comes here, that means it won't violate any hit request
-          if (head == q.end()) {
-            head = itr;
-          } else {
-            head = compare[int(Type::FRFCFS)](head, itr);
-          }
-        }
-
-        return head;
-      }
-    }
-
-private:
-    typedef list<Request>::iterator ReqIter;
-    function<ReqIter(ReqIter, ReqIter)> compare[int(Type::MAX)] = {
-        // FCFS
-        [this] (ReqIter req1, ReqIter req2) {
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-        // FRFCFS
-        [this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1);
-            bool ready2 = this->ctrl->is_ready(req2);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-        // FRFCFS_CAP
-        [this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1);
-            bool ready2 = this->ctrl->is_ready(req2);
-
-            ready1 = ready1 && (this->ctrl->rowtable->get_hits(req1->addr_vec) <= this->cap);
-            ready2 = ready2 && (this->ctrl->rowtable->get_hits(req2->addr_vec) <= this->cap);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-	
-        // FRFCFS_PriorHit
-        [this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1) && this->ctrl->is_row_hit(req1);
-            bool ready2 = this->ctrl->is_ready(req2) && this->ctrl->is_row_hit(req2);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-	// gagan : FRFCFS_DepPre
-	[this] (ReqIter req1, ReqIter req2) {
-            bool ready1 = this->ctrl->is_ready(req1);
-            bool ready2 = this->ctrl->is_ready(req2);
-
-            if (ready1 ^ ready2) {
-                if (ready1) return req1;
-                return req2;
-            }
-
-	    if (req1->is_prefetch ^ req2->is_prefetch) {
-	      if (req1->is_prefetch) return req2;
-	      return req1;
-	    }
-
-            if (req1->arrive <= req2->arrive) return req1;
-            return req2;},
-
-    };
-};
-
-
-template <typename T>
-class RowPolicy
-{
-public:
-    Controller<T>* ctrl;
-
-    enum class Type {
-        Closed, ClosedAP, Opened, Timeout, MAX
-    } type = Type::Timeout;
-    // } type = Type::Closed;
-    // } type = Type::Opened;
-
-    int timeout = 200;
-
-    RowPolicy(Controller<T>* ctrl) : ctrl(ctrl) {}
-
-    vector<int> get_victim(typename T::Command cmd)
-    {
-        return policy[int(type)](cmd);
-    }
-
-private:
-    function<vector<int>(typename T::Command)> policy[int(Type::MAX)] = {
-        // Closed
-        [this] (typename T::Command cmd) -> vector<int> {
-            for (auto& kv : this->ctrl->rowtable->table) {
-                if (!this->ctrl->is_ready(cmd, kv.first))
-                    continue;
-                return kv.first;
-            }
-            return vector<int>();},
-
-        // ClosedAP
-        [this] (typename T::Command cmd) -> vector<int> {
-            for (auto& kv : this->ctrl->rowtable->table) {
-                if (!this->ctrl->is_ready(cmd, kv.first))
-                    continue;
-                return kv.first;
-            }
-            return vector<int>();},
-
-        // Opened
-        [this] (typename T::Command cmd) {
-            return vector<int>();},
-
-        // Timeout
-        [this] (typename T::Command cmd) -> vector<int> {
-            for (auto& kv : this->ctrl->rowtable->table) {
-                auto& entry = kv.second;
-                if (this->ctrl->clk - entry.timestamp < timeout)
-                    continue;
-                if (!this->ctrl->is_ready(cmd, kv.first))
-                    continue;
-                return kv.first;
-            }
-            return vector<int>();}
-    };
-
-};
-
-
-template <typename T>
-class RowTable
-{
-public:
-    Controller<T>* ctrl;
-
-    struct Entry {
-        int row;
-        int hits;
-        long timestamp;
-    };
-
-    map<vector<int>, Entry> table;
-
-    RowTable(Controller<T>* ctrl) : ctrl(ctrl) {}
-
-    // gagan : rowtable print
-    void print()
-    {
-      int ch = ctrl->channel->id;
-      std::cout << "Channel: " << ch << std::endl;
-      for(int ra = 0; ra < ctrl->channel->children.size(); ra++)
-	{
-	  for(int bg = 0; bg < 4; bg++)
-	    for(int ba = 0; ba < 4; ba++)
-	      {
-		auto found = table.find({ch, ra, bg, ba});
-		if(found != table.end())
-		  {
-		    std::cout << "[" << found->second.row << "] ";
-		  }
-		else
-		  {
-		    std::cout << "[Closed] ";
-		  }
-	      }
-	  std::cout << std::endl;
-	}
-    }
-
-    void update(typename T::Command cmd, const vector<int>& addr_vec, long clk)
-    {
-        auto begin = addr_vec.begin();
-        auto end = begin + int(T::Level::Row);
-        vector<int> rowgroup(begin, end); // bank or subarray
-        int row = *end;
-
-        T* spec = ctrl->channel->spec;
-
-        if (spec->is_opening(cmd))
-            table.insert({rowgroup, {row, 0, clk}});
-
-        if (spec->is_accessing(cmd)) {
-            // we are accessing a row -- update its entry
-            auto match = table.find(rowgroup);
-            assert(match != table.end());
-            assert(match->second.row == row);
-            match->second.hits++;
-            match->second.timestamp = clk;
-        } /* accessing */
-
-        if (spec->is_closing(cmd)) {
-          // we are closing one or more rows -- remove their entries
-          int n_rm = 0;
-          int scope;
-          if (spec->is_accessing(cmd))
-            scope = int(T::Level::Row) - 1; //special condition for RDA and WRA
-          else
-            scope = int(spec->scope[int(cmd)]);
-
-          for (auto it = table.begin(); it != table.end();) {
-            if (equal(begin, begin + scope + 1, it->first.begin())) {
-              n_rm++;
-              it = table.erase(it);
-            }
-            else
-              it++;
-          }
-
-          assert(n_rm > 0);
-        } /* closing */
-    }
-
-    int get_hits(const vector<int>& addr_vec, const bool to_opened_row = false)
-    {
-        auto begin = addr_vec.begin();
-        auto end = begin + int(T::Level::Row);
-
-        vector<int> rowgroup(begin, end);
-        int row = *end;
-
-        auto itr = table.find(rowgroup);
-        if (itr == table.end())
-            return 0;
-
-        if(!to_opened_row && (itr->second.row != row))
-            return 0;
-
-        return itr->second.hits;
-    }
-
-    int get_open_row(const vector<int>& addr_vec) {
-        auto begin = addr_vec.begin();
-        auto end = begin + int(T::Level::Row);
-
-        vector<int> rowgroup(begin, end);
-
-        auto itr = table.find(rowgroup);
-        if(itr == table.end())
-            return -1;
-
-        return itr->second.row;
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__SCHEDULER_H*/
diff --git a/ext/ramulator/Ramulator/src/SpeedyController.h b/ext/ramulator/Ramulator/src/SpeedyController.h
deleted file mode 100644
index f234633ff..000000000
--- a/ext/ramulator/Ramulator/src/SpeedyController.h
+++ /dev/null
@@ -1,304 +0,0 @@
-#ifndef __SPEEDYCONTROLLER_H
-#define __SPEEDYCONTROLLER_H
-
-#include "Config.h"
-#include "DRAM.h"
-#include "Request.h"
-#include "Statistics.h"
-#include <iostream>
-#include <fstream>
-#include <vector>
-#include <string>
-#include <algorithm>
-#include <cassert>
-#include <utility>
-#include <queue>
-
-using namespace std;
-
-namespace ramulator
-{
-
-template <typename T>
-class SpeedyController
-// A FR-FCFS Open Row Controller, optimized for simulation speed.
-// Not For SALP-2
-{
-protected:
-  ScalarStat row_hits;
-  ScalarStat row_misses;
-private:
-    class compair_depart_clk{
-    public:
-        bool operator()(const Request& lhs, const Request& rhs) {
-            return lhs.depart > rhs.depart;
-        }
-    };
-public:
-    /* Command trace for DRAMPower 3.1 */
-    string cmd_trace_prefix = "cmd-trace-";
-    vector<ofstream> cmd_trace_files;
-    bool record_cmd_trace = false;
-    /* Commands to stdout */
-    bool print_cmd_trace = false;
-    /* Member Variables */
-    const unsigned int queue_capacity = 32;
-    long clk = 0;
-    DRAM<T>* channel;
-
-    double write_hi = 0.875;
-    double write_low = 0.5;
-
-    // request, first command, earliest clk
-    typedef tuple<Request, typename T::Command, long> request_info;
-    typedef vector<request_info> request_queue;
-    request_queue readq;   // queue for read requests
-    request_queue writeq;  // queue for write requests
-    request_queue otherq;  // queue for all "other" requests (e.g., refresh)
-
-    // read requests that are about to receive data from DRAM
-    priority_queue<Request, vector<Request>, compair_depart_clk> pending;
-
-    bool write_mode = false;  // whether write requests should be prioritized over reads
-    long refreshed = 0;  // last time refresh requests were generated
-
-    /* Constructor */
-    SpeedyController(const Config& configs, DRAM<T>* channel) :
-        channel(channel)
-    {
-        record_cmd_trace = configs.record_cmd_trace();
-        print_cmd_trace = configs.print_cmd_trace();
-        if (record_cmd_trace){
-            string prefix = cmd_trace_prefix + "chan-" + to_string(channel->id) + "-rank-";
-            string suffix = ".cmdtrace";
-            for (unsigned int i = 0; i < channel->children.size(); i++)
-                cmd_trace_files.emplace_back(prefix + to_string(i) + suffix);
-        }
-        readq.reserve(queue_capacity);
-        writeq.reserve(queue_capacity);
-        otherq.reserve(queue_capacity);
-
-        // regStats
-
-        row_hits
-            .name("row_hits_channel_"+to_string(channel->id))
-            .desc("Number of row hits")
-            .precision(0)
-            ;
-        row_misses
-            .name("row_misses_channel_"+to_string(channel->id))
-            .desc("Number of row misses")
-            .precision(0)
-            ;
-    }
-
-    ~SpeedyController(){
-        delete channel;
-        for (auto& file : cmd_trace_files)
-            file.close();
-    }
-
-    /* Member Functions */
-
-    void finish(int read_req, int write_req, int dram_cycles) {
-      // call finish function of each channel
-      channel->finish(dram_cycles);
-    }
-
-    bool enqueue(Request& req)
-    {
-        request_queue& q =
-            req.type == Request::Type::READ? readq:
-            req.type == Request::Type::WRITE? writeq:
-                                             otherq;
-        if (queue_capacity == q.size())
-            return false;
-
-        req.arrive = clk;
-        if (req.type == Request::Type::READ){
-            for (auto& info : writeq)
-                if (req.addr == get<0>(info).addr){
-                    req.depart = clk + 1;
-                    pending.push(req);
-                    return true;
-                }
-        }
-        typename T::Command first_cmd = get_first_cmd(req);
-        long first_clk = channel->get_next(first_cmd, req.addr_vec.data());
-        q.emplace_back(req, first_cmd, first_clk);
-        push_heap(q.begin(), q.end(), compair_first_clk);;
-        return true;
-    }
-
-    void tick()
-    {
-        clk++;
-
-        /*** 1. Serve completed reads ***/
-        if (pending.size()) {
-            Request req = pending.top();
-            if (req.depart <= clk) {
-                req.depart = clk; // actual depart clk
-                req.callback(req);
-                pending.pop();
-            }
-        }
-
-        /*** 2. Should we schedule refreshes? ***/
-        int refresh_interval = channel->spec->speed_entry.nREFI;
-        if (clk - refreshed >= refresh_interval) {
-            auto req_type = Request::Type::REFRESH;
-            vector<int> addr_vec(int(T::Level::MAX), -1);
-            addr_vec[0] = channel->id;
-            for (auto child : channel->children) {
-                addr_vec[1] = child->id;
-                Request req(addr_vec, req_type, NULL);
-                bool res = enqueue(req);
-                assert(res);
-            }
-
-            refreshed = clk;
-        }
-
-        /*** 3. Should we schedule writes? ***/
-        if (!write_mode) {
-            // yes -- write queue is almost full or read queue is empty
-            if (writeq.size() >= (unsigned int)(write_hi * queue_capacity) || readq.size() == 0)
-                write_mode = true;
-        }
-        else {
-            // no -- write queue is almost empty and read queue is not empty
-            if (writeq.size() <= (unsigned int)(write_low * queue_capacity) && readq.size() != 0)
-                write_mode = false;
-        }
-
-        /*** 4. Find the best command to schedule, if any ***/
-        request_queue& q = otherq.size()? otherq: write_mode ? writeq : readq;
-
-        schedule(q);
-    }
-
-    bool is_row_hit(Request& req)
-    {
-        typename T::Command cmd = get_first_cmd(req);
-        return channel->check_row_hit(cmd, req.addr_vec.data());
-    }
-
-private:
-
-    static bool compair_first_clk(const request_info& lhs, const request_info& rhs) {
-        return (get<2>(lhs) > get<2>(rhs));
-    }
-
-    typename T::Command get_first_cmd(Request& req)
-    {
-        typename T::Command cmd = channel->spec->translate[int(req.type)];
-        switch (int(req.type)){
-            case int(Request::Type::READ):
-            case int(Request::Type::WRITE):{
-                auto node = channel;
-                for (int i = 1; i < int(T::Level::Row); i++)
-                    node = node->children[req.addr_vec[i]];
-                assert(int(node->level) == int(T::Level::Row) - 1);
-                if (node->state == T::State::Closed) return T::Command::ACT;
-                else if (node->row_state.find(req.addr_vec[int(T::Level::Row)]) != node->row_state.end()) return cmd;
-                else return T::Command::PRE;
-            }
-            case int(Request::Type::REFRESH):
-                return channel->decode(cmd, req.addr_vec.data());
-            default:
-                assert(false);
-        }
-        // return channel->decode(cmd, req.addr_vec.data());
-    }
-    void update(typename T::Command cmd, bool state_change, vector<int>::iterator& begin, vector<int>::iterator& end, request_queue& q){
-        if (q.empty()) return;
-
-        for (auto& info : q) {
-            bool addr_eq = equal(begin, end, get<0>(info).addr_vec.begin());
-            if (state_change && addr_eq)
-                get<1>(info) = get_first_cmd(get<0>(info));
-            if ((cmd == T::Command::RD || cmd == T::Command::WR)
-                && get<1>(info) == T::Command::ACT)
-                continue;
-            get<2>(info) = channel->get_next(get<1>(info), get<0>(info).addr_vec.data());
-        }
-        make_heap(q.begin(), q.end(), compair_first_clk);
-    }
-
-    void schedule(request_queue& q){
-        if (q.empty()) return;
-
-        Request& req = get<0>(q[0]);
-        typename T::Command& first_cmd = get<1>(q[0]);
-        long first_clk = get<2>(q[0]);
-
-        if (first_clk > clk) return;
-
-        if (req.is_first_command) {
-            req.is_first_command = false;
-            if (req.type == Request::Type::READ || req.type == Request::Type::WRITE) {
-                if (is_row_hit(req))
-                    ++row_hits;
-                else
-                    ++row_misses;
-            }
-        }
-
-        issue_cmd(first_cmd, req.addr_vec.data());
-
-        if (first_cmd == channel->spec->translate[int(req.type)]){
-            if (req.type == Request::Type::READ) {
-                req.depart = clk + channel->spec->read_latency;
-                pending.push(req);
-            }
-            pop_heap(q.begin(), q.end(), compair_first_clk);
-            q.pop_back();
-        }
-
-        bool state_change = channel->spec->is_opening(first_cmd)
-                        || channel->spec->is_closing(first_cmd)
-                        || channel->spec->is_refreshing(first_cmd);
-
-        auto begin = req.addr_vec.begin();
-        auto end = begin + 1;
-        for (; end < begin + int(T::Level::Row) && *end >= 0; end++);
-
-        update(first_cmd, state_change, begin, end, readq);
-        update(first_cmd, state_change, begin, end, writeq);
-        update(first_cmd, state_change, begin, end, otherq);
-    }
-
-    void issue_cmd(typename T::Command cmd, int* addr_vec)
-    {
-        // assert(channel->check(cmd, addr_vec, clk));
-        channel->update(cmd, addr_vec, clk);
-
-        if (record_cmd_trace){
-            // select rank
-            auto& file = cmd_trace_files[addr_vec[1]];
-            string& cmd_name = channel->spec->command_name[int(cmd)];
-            file<<clk<<','<<cmd_name;
-            // TODO bad coding here
-            if (cmd_name == "PREA" || cmd_name == "REF")
-                file<<endl;
-            else {
-                int bank_id = addr_vec[int(T::Level::Bank)];
-                if (channel->spec->standard_name == "DDR4" || channel->spec->standard_name == "GDDR5")
-                    bank_id += addr_vec[int(T::Level::Bank) - 1] *
-                        channel->spec->org_entry.count[int(T::Level::Bank)];
-                file<<','<<bank_id<<endl;
-            }
-        }
-        if (print_cmd_trace){
-            printf("%5s %10ld:", channel->spec->command_name[int(cmd)].c_str(), clk);
-            for (int lev = 0; lev < int(T::Level::MAX); lev++)
-                printf(" %5d", addr_vec[lev]);
-            printf("\n");
-        }
-    }
-};
-
-} /*namespace ramulator*/
-
-#endif /*__SPEEDYCONTROLLER_H*/
diff --git a/ext/ramulator/Ramulator/src/StatType.cpp b/ext/ramulator/Ramulator/src/StatType.cpp
deleted file mode 100644
index 17b25357f..000000000
--- a/ext/ramulator/Ramulator/src/StatType.cpp
+++ /dev/null
@@ -1,153 +0,0 @@
-#include "StatType.h"
-
-namespace Stats {
-
-// Statistics list
-StatList statlist;
-
-// The smallest timing granularity.
-Tick curTick = 0;
-
-std::vector<StatBase*> all_stats;
-void reset_stats() {
-    for(auto s : all_stats)
-        s->reset();
-}
-
-void
-Histogram::grow_out()
-{
-    int size = cvec.size();
-    int zero = size / 2; // round down!
-    int top_half = zero + (size - zero + 1) / 2; // round up!
-    int bottom_half = (size - zero) / 2; // round down!
-
-    // grow down
-    int low_pair = zero - 1;
-    for (int i = zero - 1; i >= bottom_half; i--) {
-        cvec[i] = cvec[low_pair];
-        if (low_pair - 1 >= 0)
-            cvec[i] += cvec[low_pair - 1];
-        low_pair -= 2;
-    }
-    assert(low_pair == 0 || low_pair == -1 || low_pair == -2);
-
-    for (int i = bottom_half - 1; i >= 0; i--)
-        cvec[i] = Counter();
-
-    // grow up
-    int high_pair = zero;
-    for (int i = zero; i < top_half; i++) {
-        cvec[i] = cvec[high_pair];
-        if (high_pair + 1 < size)
-            cvec[i] += cvec[high_pair + 1];
-        high_pair += 2;
-    }
-    assert(high_pair == size || high_pair == size + 1);
-
-    for (int i = top_half; i < size; i++)
-        cvec[i] = Counter();
-
-    max_bucket *= 2;
-    min_bucket *= 2;
-    bucket_size *= 2;
-}
-
-void
-Histogram::grow_convert()
-{
-    int size = cvec.size();
-    int half = (size + 1) / 2; // round up!
-    //bool even = (size & 1) == 0;
-
-    int pair = size - 1;
-    for (int i = size - 1; i >= half; --i) {
-        cvec[i] = cvec[pair];
-        if (pair - 1 >= 0)
-            cvec[i] += cvec[pair - 1];
-        pair -= 2;
-    }
-
-    for (int i = half - 1; i >= 0; i--)
-        cvec[i] = Counter();
-
-    min_bucket = -max_bucket;// - (even ? bucket_size : 0);
-    bucket_size *= 2;
-}
-
-void
-Histogram::grow_up()
-{
-    int size = cvec.size();
-    int half = (size + 1) / 2; // round up!
-
-    int pair = 0;
-    for (int i = 0; i < half; i++) {
-        cvec[i] = cvec[pair];
-        if (pair + 1 < size)
-            cvec[i] += cvec[pair + 1];
-        pair += 2;
-    }
-    assert(pair == size || pair == size + 1);
-
-    for (int i = half; i < size; i++)
-        cvec[i] = Counter();
-
-    max_bucket *= 2;
-    bucket_size *= 2;
-}
-
-void
-Histogram::add(Histogram &hs)
-{
-    size_type b_size = hs.size();
-    assert(size() == b_size);
-    assert(min_bucket == hs.min_bucket);
-
-    sum += hs.sum;
-    logs += hs.logs;
-    squares += hs.squares;
-    samples += hs.samples;
-
-    while(bucket_size > hs.bucket_size)
-        hs.grow_up();
-    while(bucket_size < hs.bucket_size)
-        grow_up();
-
-    for (uint32_t i = 0; i < b_size; i++)
-        cvec[i] += hs.cvec[i];
-}
-
-void
-Histogram::sample(Counter val, int number)
-{
-    assert(min_bucket < max_bucket);
-    if (val < min_bucket) {
-        if (min_bucket == 0)
-            grow_convert();
-
-        while (val < min_bucket)
-            grow_out();
-    } else if (val >= max_bucket + bucket_size) {
-        if (min_bucket == 0) {
-            while (val >= max_bucket + bucket_size)
-                grow_up();
-        } else {
-            while (val >= max_bucket + bucket_size)
-                grow_out();
-        }
-    }
-
-    size_type index =
-        (int64_t)std::floor((val - min_bucket) / bucket_size);
-
-    assert(index >= 0 && index < size());
-    cvec[index] += number;
-
-    sum += val * number;
-    squares += val * val * number;
-    logs += log(val) * number;
-    samples += number;
-}
-
-} /* namespace Stats */
diff --git a/ext/ramulator/Ramulator/src/StatType.h b/ext/ramulator/Ramulator/src/StatType.h
deleted file mode 100644
index c1e4dd344..000000000
--- a/ext/ramulator/Ramulator/src/StatType.h
+++ /dev/null
@@ -1,669 +0,0 @@
-#ifndef __STATTYPE_H
-#define __STATTYPE_H
-
-#include <limits>
-#include <fstream>
-#include <string>
-#include <vector>
-
-#include <cassert>
-#include <cmath>
-#include <cstdlib>
-
-namespace ramulator {
-
-class ScalarStat;
-class AverageStat;
-class VectorStat;
-class AverageVectorStat;
-} // namespace ramulator
-
-namespace Stats {
-
-const double eps = 1e-8;
-
-typedef unsigned int size_type;
-typedef unsigned int off_type;
-typedef double Counter;
-typedef double Result;
-typedef uint64_t Tick;
-typedef std::vector<Counter> VCounter;
-typedef std::vector<Result> VResult;
-typedef std::numeric_limits<Counter> CounterLimits;
-
-class StatBase;
-extern std::vector<StatBase*> all_stats;
-void reset_stats();
-
-// Flags
-const uint16_t init      = 0x00000001;
-const uint16_t display   = 0x00000002;
-const uint16_t total     = 0x00000010;
-const uint16_t pdf       = 0x00000020;
-const uint16_t cdf       = 0x00000040;
-const uint16_t dist      = 0x00000080;
-const uint16_t nozero    = 0x00000100;
-const uint16_t nonan     = 0x00000200;
-
-class Flags {
- protected:
-  uint16_t flags;
- public:
-  Flags(){}
-  Flags(uint16_t flags):flags(flags){}
-  void operator=(uint16_t _flags){flags = _flags;}
-  bool is_total() const {return flags & total;}
-  bool is_pdf() const {return flags & pdf;}
-  bool is_nozero() const {return flags & nozero;}
-  bool is_nonan() const {return flags & nonan;}
-  bool is_cdf() const {return flags & cdf;}
-  bool is_display() const {return flags & display;}
-};
-
-class StatBase {
- public:
-    StatBase() {
-        all_stats.push_back(this);
-    }
-
-
-  // TODO implement print for Distribution, Histogram,
-  // AverageDeviation, StandardDeviation
-  virtual void print(std::ofstream& file) = 0;
-
-  virtual size_type size() const = 0;
-  virtual bool zero() const = 0;
-  virtual void prepare() = 0;
-  virtual void reset() = 0;
-
-  virtual VResult vresult() const { return VResult(); };
-  virtual Result total() const { return Result(); };
-
-  virtual bool is_display() const  = 0;
-  virtual bool is_nozero() const = 0;
-};
-
-class StatList {
- protected:
-  std::vector<StatBase*> list;
-  std::ofstream stat_output;
- public:
-  void add(StatBase* stat) {
-    list.push_back(stat);
-  }
-  void output(std::string filename) {
-    stat_output.open(filename.c_str(), std::ios_base::out);
-    if (!stat_output.good()) {
-      assert(false && "!stat_output.good()");
-    }
-  }
-  void printall() {
-    for(off_type i = 0 ; i < list.size() ; ++i) {
-      if (!list[i]) {
-        continue;
-      }
-      if (list[i]->is_nozero() && list[i]->zero()) {
-        continue;
-      }
-      if (list[i]->is_display()) {
-        list[i]->prepare();
-        list[i]->print(stat_output);
-      }
-    }
-  }
-  ~StatList() {
-    stat_output.close();
-  }
-};
-
-extern StatList statlist;
-
-template<class Derived>
-class Stat : public StatBase {
- protected:
-  std::string _name;
-  std::string _desc;
-  int _precision = 1;
-  Flags _flags = display;
-  std::string separatorString;
- public:
-  Stat() {
-    statlist.add(selfptr());
-  }
-  Derived &self() {return *static_cast<Derived*>(this);}
-  Derived *selfptr() {return static_cast<Derived*>(this);}
-  Derived &name(const std::string &__name) {
-    _name = __name;
-    return self();
-  };
-  Derived &desc(const std::string &__desc) {
-    _desc = __desc;
-    return self();
-  };
-  Derived &precision(int __precision) {
-    _precision = __precision;
-    return self();
-  };
-  Derived &flags(Flags __flags) {
-    _flags = __flags;
-    return self();
-  };
-
-  template <class GenericStat>
-  Derived &prereq(const GenericStat & prereq) {
-    // TODO deal with prereq;
-    // only print the stat if the prereq is not zero.
-    return self();
-  }
-
-  Derived &setSeparator(std::string str) {
-    separatorString = str;
-    return self();
-  }
-  const std::string& setSeparator() const {return separatorString;}
-
-  size_type size() const { return 0; }
-
-  virtual void print(std::ofstream& file) {};
-  virtual void printname(std::ofstream& file) {
-    file.width(40);
-    file << _name;
-  }
-
-  virtual void printdesc(std::ofstream& file) {
-    file.width(40);
-    file << "# " << _desc << std::endl;
-  }
-
-  virtual bool is_display() const {
-    return _flags.is_display();
-  }
-
-  virtual bool is_nozero() const {
-    return _flags.is_nozero();
-  }
-};
-
-template <class ScalarType>
-class ScalarBase: public Stat<ScalarType> {
- public:
-  virtual Counter value() const = 0;
-  virtual Result result() const = 0;
-  virtual Result total() const = 0;
-
-  size_type size() const {return 1;}
-  VResult vresult() const {return VResult(1, result());}
-
-  virtual void print(std::ofstream& file) {
-    Stat<ScalarType>::printname(file);
-    // TODO deal with flag
-    file.precision(Stat<ScalarType>::_precision);
-    file.width(20);
-    Result res = Stat<ScalarType>::self().result();
-    file << std::fixed << res;
-    Stat<ScalarType>::printdesc(file);
-  }
-};
-
-class ConstValue: public ScalarBase<ConstValue> {
- private:
-  Counter _value;
- public:
-  ConstValue(Counter __value):_value(__value){}
-
-  void operator ++ () { ++_value; }
-  void operator -- () { --_value; }
-  void operator ++ (int) { _value++; }
-  void operator -- (int) { _value--; }
-
-  template <typename U>
-  void operator = (const U &v) { _value = v; }
-
-  template <typename U>
-  void operator += (const U &v) { _value += v;}
-
-  template <typename U>
-  void operator -= (const U &v) { _value -= v;}
-
-
-  Counter value() const {return _value;}
-  Result result() const {return (Result)_value;}
-  Result total() const {return result();}
-  bool zero() const {return (fabs(_value) < eps);}
-  void prepare() {}
-  void reset() {}
-};
-
-class Scalar: public ScalarBase<Scalar> {
- private:
-  Counter _value;
- public:
-  Scalar():_value(0) {}
-  Counter value() const {return _value;}
-  Result result() const {return (Result)_value;}
-  Result total() const {return (Result)_value;}
-
-  void operator ++ () { ++_value; }
-  void operator -- () { --_value; }
-  void operator ++ (int) { _value++; }
-  void operator -- (int) { _value--; }
-
-  template <typename U>
-  void operator = (const U &v) { _value = v; }
-
-  template <typename U>
-  void operator += (const U &v) { _value += v;}
-
-  template <typename U>
-  void operator -= (const U &v) { _value -= v;}
-
-
-  virtual bool zero() const {return (fabs(_value) < eps);}
-  void prepare() {}
-  void reset() {_value = Counter();}
-
-};
-
-extern Tick curTick;
-
-class Average: public ScalarBase<Average> {
- private:
-  Counter current;
-  Tick lastReset;
-  Result total_val;
-  Tick last;
- public:
-  Average():current(0), lastReset(0), total_val(0), last(0){}
-
-  void set(Counter val) {
-    total_val += current * (curTick - last);
-    last = curTick;
-    current = val;
-  }
-  void inc(Counter val) {
-    set(current + val);
-  }
-  void dec(Counter val) {
-    set(current - val);
-  }
-  void operator ++ () { inc(1); }
-  void operator -- () { dec(1); }
-  void operator ++ (int) { inc(1); }
-  void operator -- (int) { dec(1); }
-
-  template <typename U>
-  void operator = (const U &v) { set(v); }
-
-  template <typename U>
-  void operator += (const U &v) { inc(v);}
-
-  template <typename U>
-  void operator -= (const U &v) { dec(v);}
-
-
-  bool zero() const { return (fabs(total_val) < eps); }
-  void prepare() {
-    total_val += current * (curTick - last);
-    last = curTick;
-  }
-  void reset() {
-    total_val = 0.0;
-    last = curTick;
-    lastReset = curTick;
-  }
-
-  Counter value() const { return current; }
-  Result result() const {
-    assert(last == curTick);
-    return (Result)(total_val + current)/ (Result)(curTick - lastReset + 1);
-  }
-  Result total() const {return result();}
-};
-
-template<class Derived, class Element>
-class VectorBase: public Stat<Derived> {
- private:
-  size_type _size = 0;
-  std::vector<Element> data;
-
- public:
-  void init(size_type __size) {
-    _size = __size;
-    data.resize(size());
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].flags(0)
-             .name("[" + std::string(1, char(i + '0')) + "]");
-    }
-  }
-  size_type size() const {return _size;}
-  // Copy the values to a local vector and return a reference to it.
-  void value(VCounter& vec) const {
-    vec.resize(size());
-    for (off_type i = 0 ; i < size() ; ++i) {
-      vec[i] = data[i].value();
-    }
-  }
-  // Copy the results to a local vector and return a reference to it.
-  void result(VResult& vec) const {
-    vec.resize(size());
-    for (off_type i = 0 ; i < size() ; ++i) {
-      vec[i] = data[i].result();
-    }
-  }
-
-  Result total() const {
-    Result sum = 0.0;
-    for (off_type i = 0 ; i < size() ; ++i) {
-      sum += data[i].result();
-    }
-    return sum;
-  }
-
-  VResult vresult() const {
-    VResult vres;
-    for (off_type i = 0 ; i < size() ; ++i) {
-      vres[i] = data[i].result();
-    }
-    return vres;
-  }
-
-  bool check() const {
-    // We don't separate storage and access as gem5 does.
-    // So here is always true.
-    return true;
-  }
-
-  Element &operator[](off_type index) {
-    assert(index >= 0 && index < size());
-    return data[index];
-  }
-
-  bool zero() const {
-    return (fabs(total()) < eps);
-  }
-
-  void prepare() {
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].prepare();
-    }
-  }
-  void reset() {
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].reset();
-    }
-  }
-  void print(std::ofstream& file) {
-    Stat<Derived>::printname(file);
-    file.precision(Stat<Derived>::_precision);
-    file.width(20);
-    file << std::fixed << total();
-    Stat<Derived>::printdesc(file);
-    for (off_type i = 0 ; i < size() ; ++i) {
-      data[i].print(file);
-    }
-  }
-};
-
-class Vector: public VectorBase<Vector, Scalar> {
-};
-
-class AverageVector: public VectorBase<AverageVector, Average> {
-};
-
-class Distribution: public Stat<Distribution> {
- private:
-  // Parameter part:
-  Counter param_min;
-  Counter param_max;
-  Counter param_bucket_size;
-  Counter param_buckets;
-
-  // The minimum value to track
-  Counter min_track;
-  // The maximum value to track
-  Counter max_track;
-  // The number of entries in each bucket
-  Counter bucket_size;
-
-  Counter min_val;
-  Counter max_val;
-  // The number of values sampled less than min
-  Counter underflow;
-  // The number of values sampled more than max
-  Counter overflow;
-  // The current sum
-  Counter sum;
-  // The sum of squares
-  Counter squares;
-  // The number of samples
-  Counter samples;
-  // Counter for each bucket
-  VCounter cvec;
-
- public:
-  Distribution():param_min(Counter()), param_max(Counter()),
-      param_bucket_size(Counter()) { reset(); }
-  void init(Counter min, Counter max, Counter bkt) {
-    param_min = min;
-    param_max = max;
-    param_bucket_size = bkt;
-    param_buckets = (size_type)ceil((max - min + 1.0) / bkt);
-    cvec.resize(param_buckets);
-
-    reset();
-  }
-  void sample(Counter val, int number) {
-    if (val < min_track)
-      underflow += number;
-    else if (val > max_track)
-      overflow += number;
-    else {
-      size_type index =
-          (size_type)std::floor((val - min_track) / bucket_size);
-      assert(index < size());
-      cvec[index] += number;
-    }
-
-    if (val < min_val)
-      min_val = val;
-
-    if (val > max_val)
-      max_val = val;
-
-    sum += val * number;
-    squares += val * val * number;
-    samples += number;
-  }
-
-  size_type size() const {return cvec.size();}
-  bool zero() const {
-    return (fabs(samples) < eps);
-  }
-  void prepare() {};
-  void reset() {
-    min_track = param_min;
-    max_track = param_max;
-    bucket_size = param_bucket_size;
-
-    min_val = CounterLimits::max();
-    max_val = CounterLimits::min();
-    underflow = Counter();
-    overflow = Counter();
-
-    size_type _size = cvec.size();
-    for (off_type i = 0 ; i < _size ; ++i) {
-      cvec[i] = Counter();
-    }
-
-    sum = Counter();
-    squares = Counter();
-    samples = Counter();
-  };
-  void add(Distribution &d) {
-    size_type d_size = d.size();
-    assert(size() == d_size);
-    assert(min_track == d.min_track);
-    assert(max_track == d.max_track);
-
-    underflow += d.underflow;
-    overflow += d.overflow;
-
-    sum += d.sum;
-    squares += d.squares;
-    samples += d.samples;
-
-    if (d.min_val < min_val) {
-      min_val = d.min_val;
-    }
-
-    if (d.max_val > max_val) {
-      max_val = d.max_val;
-    }
-
-    for (off_type i = 0 ; i < d_size ; ++i) {
-      cvec[i] += d.cvec[i];
-    }
-  }
-};
-
-class Histogram: public Stat<Histogram> {
- private:
-  size_type param_buckets;
-
-  Counter min_bucket;
-  Counter max_bucket;
-  Counter bucket_size;
-
-  Counter sum;
-  Counter logs;
-  Counter squares;
-  Counter samples;
-  VCounter cvec;
-
- public:
-  Histogram():param_buckets(0) { reset(); }
-  Histogram(size_type __buckets):cvec(__buckets) {
-    init(__buckets);
-  }
-  void init(size_type __buckets) {
-    cvec.resize(__buckets);
-    param_buckets = __buckets;
-    reset();
-  }
-
-  void grow_up();
-  void grow_out();
-  void grow_convert();
-  void add(Histogram& hs);
-  void sample(Counter val, int number);
-
-  bool zero() const {
-    return (fabs(samples) < eps);
-  }
-  void prepare() {}
-  void reset() {
-    min_bucket = 0;
-    max_bucket = param_buckets - 1;
-    bucket_size = 1;
-
-    size_type size = param_buckets;
-    for (off_type i = 0 ; i < size ; ++i) {
-      cvec[i] = Counter();
-    }
-
-    sum = Counter();
-    squares = Counter();
-    samples = Counter();
-    logs = Counter();
-  }
-
-  size_type size() const {return param_buckets;}
-};
-
-class StandardDeviation: public Stat<StandardDeviation> {
- private:
-  Counter sum;
-  Counter squares;
-  Counter samples;
-
- public:
-  StandardDeviation():sum(Counter()), squares(Counter()),
-      samples(Counter()) {}
-  void sample(Counter val, int number) {
-    Counter value = val * number;
-    sum += value;
-    squares += value * value;
-    samples += number;
-  }
-  size_type size() const {return 1;}
-  bool zero() const {return (fabs(samples) < eps);}
-  void prepare() {}
-  void reset() {
-    sum = Counter();
-    squares = Counter();
-    samples = Counter();
-  }
-  void add(StandardDeviation& sd) {
-    sum += sd.sum;
-    squares += sd.squares;
-    samples += sd.samples;
-  }
-};
-
-class AverageDeviation: public Stat<AverageDeviation> {
- private:
-  Counter sum;
-  Counter squares;
-
- public:
-  AverageDeviation():sum(Counter()), squares(Counter()) {}
-  void sample(Counter val, int number) {
-    Counter value = val * number;
-    sum += value;
-    squares += value * value;
-  }
-  size_type size() const {return 1;}
-  bool zero() const {return (fabs(sum) < eps);}
-  void prepare() {}
-  void reset() {
-    sum = Counter();
-    squares = Counter();
-  }
-  void add(AverageDeviation& ad) {
-    sum += ad.sum;
-    squares += ad.squares;
-  }
-};
-
-class Op {
- private:
-  std::string opstring;
- public:
-  Op() {}
-  Op(std::string __opstring):opstring(__opstring){}
-  Result operator() (Result r) const {
-    if (opstring == "-") {
-      return -r;
-    } else {
-      assert("Unary operation can only be unary negation." && false);
-    }
-  }
-  Result operator() (Result l, Result r) const {
-    if (opstring == "+") {
-      return l + r;
-    } else if (opstring == "-") {
-      return l - r;
-    } else if (opstring == "*") {
-      return l * r;
-    } else if (opstring == "/") {
-      assert(fabs(r) > 1e-8 || "divide zero error");
-      return l / r;
-    } else {
-      assert("invalid binary opstring " && false);
-    }
-  }
-};
-
-} // namespace Stats
-
-#endif
diff --git a/ext/ramulator/Ramulator/src/Statistics.h b/ext/ramulator/Ramulator/src/Statistics.h
deleted file mode 100644
index b9f7489fe..000000000
--- a/ext/ramulator/Ramulator/src/Statistics.h
+++ /dev/null
@@ -1,246 +0,0 @@
-#ifndef __STATISTICS_H
-#define __STATISTICS_H
-
-#include <string>
-
-// FIXME Find better way to decide where does it come from
-#if !defined(RAMULATOR)
-#define INTEGRATED_WITH_GEM5
-#endif
-
-#ifdef INTEGRATED_WITH_GEM5
-#include "base/statistics.hh"
-#else
-#include "StatType.h"
-#endif
-
-/*
-  IMPORTANT NOTE - Read this first!
-
-  This version of the file provides wrappers to the gem5 statistics classes.
-  Feel free to go through this file, though it can be difficult to follow
-  with the degree of abstraction going on. In short, this file currently
-  provides the following mapping of stat classes. In almost all cases, the
-  wrapper provides identical and complete functionality to the gem5 stat
-  classes. All of our classes are defined in the ramulator namespace.
-
-  GEM5 CLASS --> RAMULATOR CLASS
-  ==============================
-  Stats::Scalar --> ScalarStat
-  Stats::Average --> AverageStat
-  Stats::Vector --> VectorStat
-  Stats::AverageVector --> AverageVectorStat
-  Stats::Distribution --> DistributionStat
-  Stats::Histogram --> HistogramStat
-  Stats::StandardDeviation --> StandardDeviationStat
-  Stats::AverageDeviation --> AverageDeviationStat
-
-  All of the stats that you create will be named "ramulator.<your name>"
-  automatically, and will be dumped at the end of simulation into the gem5
-  stats file.
-*/
-
-namespace ramulator {
-
-template<class StatType>
-class StatBase { // wrapper for Stats::DataWrap
-  protected:
-    StatType stat;
-    std::string statName;
-
-    StatBase<StatType> & self() { return *this; }
-  public:
-    StatBase() {}
-
-#ifndef INTEGRATED_WITH_GEM5
-    const StatType* get_stat() const {
-      return &stat;
-    }
-#endif
-
-    StatBase(std::string _name) {
-      name(_name);
-    }
-
-    StatBase(std::string _name, std::string _desc) {
-      name(_name);
-      desc(_desc);
-    }
-
-    StatBase<StatType> & name(std::string _name) {
-      statName = _name;
-      stat.name("ramulator." + _name);
-
-      return self();
-    }
-
-    const std::string &name(void) const { return statName; }
-
-    StatBase<StatType> & setSeparator(const std::string & _sep) {
-      stat.setSeparator(_sep);
-      return self();
-    }
-
-    const std::string &setSeparator() const { return stat.setSeparator(); }
-
-    StatBase<StatType> & desc(std::string _desc) {
-      stat.desc(_desc);
-      return self();
-    }
-
-    StatBase<StatType> & precision(int _precision) {
-      stat.precision(_precision);
-      return self();
-    }
-
-    StatBase<StatType> & flags(Stats::Flags _flags) {
-      stat.flags(_flags);
-      return self();
-    }
-
-    template <class Stat>
-    StatBase<StatType> & prereq(const Stat & _prereq) {
-      stat.prereq(_prereq);
-      return self();
-    }
-
-    Stats::size_type size(void) const { return stat.size(); }
-    bool zero(void) const { return stat.zero(); }
-    void prepare(void) { stat.prepare(); }
-    void reset(void) { stat.reset(); }
-};
-
-template<class StatType>
-class StatBaseVec : public StatBase<StatType> { // wrapper for Stats::DataWrapVec
-  protected:
-    StatBaseVec<StatType> & self() { return *this; }
-
-  public:
-    StatBaseVec<StatType> & subname(Stats::off_type index, const std::string & name) {
-      StatBase<StatType>::stat.subname(index, name);
-      return self();
-    }
-
-    StatBaseVec<StatType> & subdesc(Stats::off_type index, const std::string & desc) {
-      StatBase<StatType>::stat.subdesc(index, desc);
-      return self();
-    }
-};
-
-template<class StatType>
-class ScalarStatBase : public StatBase<StatType> { // wrapper for Stats::ScalarBase
-  public:
-    Stats::Counter value() const { return StatBase<StatType>::stat.value(); };
-    void operator++() { ++StatBase<StatType>::stat; }
-    void operator--() { --StatBase<StatType>::stat; }
-
-    void operator++(int) { StatBase<StatType>::stat++; }
-    void operator--(int) { StatBase<StatType>::stat--; }
-
-    template <typename U>
-    void operator=(const U &v) { StatBase<StatType>::stat = v; }
-
-    template <typename U>
-    void operator+=(const U &v) { StatBase<StatType>::stat += v; }
-
-    template <typename U>
-    void operator-=(const U &v) { StatBase<StatType>::stat -= v; }
-};
-
-template<class StatType, class Element>
-class VectorStatBase : public StatBaseVec<StatType> { // wrapper for Stats::VectorBase
-  protected:
-    VectorStatBase<StatType, Element> & self() { return *this; }
-
-  public:
-    void value(Stats::VCounter & vec) const { StatBase<StatType>::stat.value(vec); }
-    void result(Stats::VResult & vec) const { StatBase<StatType>::stat.result(vec); }
-    Stats::Result total(void) const { return StatBase<StatType>::stat.total(); }
-
-    bool check(void) const { return StatBase<StatType>::stat.check(); }
-
-    VectorStatBase<StatType, Element> & init(Stats::size_type size) {
-      StatBase<StatType>::stat.init(size);
-      return self();
-    }
-
-#ifdef INTEGRATED_WITH_GEM5
-    Stats::ScalarProxy<StatType> operator[](Stats::off_type index) { return StatBase<StatType>::stat[index]; }
-#else
-    Element &operator[](Stats::off_type index) { return StatBase<StatType>::stat[index]; }
-#endif
-};
-
-
-template<class StatType>
-class DistStatBase : public StatBase<StatType> { // wrapper for Stats::DistBase
-  public:
-    template<typename U>
-    void sample(const U &v, int n = 1) { StatBase<StatType>::stat.sample(v, n); }
-
-    void add(DistStatBase & d) { StatBase<StatType>::stat.add(d.StatBase<StatType>::stat); }
-};
-
-
-/*
-  nice wrappers for the gem5 stats classes used throughout the rest of the code
-*/
-
-class ScalarStat : public ScalarStatBase<Stats::Scalar> {
-  public:
-    using ScalarStatBase<Stats::Scalar>::operator=;
-};
-
-class AverageStat : public ScalarStatBase<Stats::Average> {
-  public:
-    using ScalarStatBase<Stats::Average>::operator=;
-};
-
-class VectorStat : public VectorStatBase<Stats::Vector, Stats::Scalar> {
-};
-
-class AverageVectorStat : public VectorStatBase<Stats::AverageVector, Stats::Average> {
-};
-
-class DistributionStat : public DistStatBase<Stats::Distribution> {
-  protected:
-    DistributionStat & self() { return *this; }
-
-  public:
-    DistributionStat & init(Stats::Counter min, Stats::Counter max, Stats::Counter bkt) {
-      StatBase<Stats::Distribution>::stat.init(min, max, bkt);
-      return self();
-    }
-
-};
-
-class HistogramStat : public DistStatBase<Stats::Histogram> {
-  protected:
-    HistogramStat & self() { return *this; }
-
-  public:
-    HistogramStat & init(Stats::size_type size) {
-      StatBase<Stats::Histogram>::stat.init(size);
-      return self();
-    }
-};
-
-class StandardDeviationStat : public DistStatBase<Stats::StandardDeviation> {
-};
-
-class AverageDeviationStat : public DistStatBase<Stats::AverageDeviation> {
-};
-
-/*
-  Stats TODO
-  * Formula
-  * VectorDistribution
-  * VectorStandardDeviation
-  * VectorAverageDeviation
-  * Vector2d
-  * SparseHistogram
-*/
-
-} /* namespace ramulator */
-
-#endif
diff --git a/ext/ramulator/Ramulator/src/TLDRAM.cpp b/ext/ramulator/Ramulator/src/TLDRAM.cpp
deleted file mode 100644
index c9b3052f4..000000000
--- a/ext/ramulator/Ramulator/src/TLDRAM.cpp
+++ /dev/null
@@ -1,567 +0,0 @@
-#include "TLDRAM.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-#include <iostream>
-
-using namespace std;
-using namespace ramulator;
-
-string TLDRAM::standard_name = "TLDRAM";
-string TLDRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum TLDRAM::Org> TLDRAM::org_map = {
-    {"TLDRAM_512Mb_x4", TLDRAM::Org::TLDRAM_512Mb_x4},
-    {"TLDRAM_512Mb_x8", TLDRAM::Org::TLDRAM_512Mb_x8},
-    {"TLDRAM_512Mb_x16", TLDRAM::Org::TLDRAM_512Mb_x16},
-    {"TLDRAM_1Gb_x4", TLDRAM::Org::TLDRAM_1Gb_x4},
-    {"TLDRAM_1Gb_x8", TLDRAM::Org::TLDRAM_1Gb_x8},
-    {"TLDRAM_1Gb_x16", TLDRAM::Org::TLDRAM_1Gb_x16},
-    {"TLDRAM_2Gb_x4", TLDRAM::Org::TLDRAM_2Gb_x4},
-    {"TLDRAM_2Gb_x8", TLDRAM::Org::TLDRAM_2Gb_x8},
-    {"TLDRAM_2Gb_x16", TLDRAM::Org::TLDRAM_2Gb_x16},
-    {"TLDRAM_4Gb_x4", TLDRAM::Org::TLDRAM_4Gb_x4},
-    {"TLDRAM_4Gb_x8", TLDRAM::Org::TLDRAM_4Gb_x8},
-    {"TLDRAM_4Gb_x16", TLDRAM::Org::TLDRAM_4Gb_x16},
-    {"TLDRAM_8Gb_x4", TLDRAM::Org::TLDRAM_8Gb_x4},
-    {"TLDRAM_8Gb_x8", TLDRAM::Org::TLDRAM_8Gb_x8},
-    {"TLDRAM_8Gb_x16", TLDRAM::Org::TLDRAM_8Gb_x16},
-};
-
-map<string, enum TLDRAM::Speed> TLDRAM::speed_map = {
-    {"TLDRAM_800D", TLDRAM::Speed::TLDRAM_800D},
-    {"TLDRAM_800E", TLDRAM::Speed::TLDRAM_800E},
-    {"TLDRAM_1066E", TLDRAM::Speed::TLDRAM_1066E},
-    {"TLDRAM_1066F", TLDRAM::Speed::TLDRAM_1066F},
-    {"TLDRAM_1066G", TLDRAM::Speed::TLDRAM_1066G},
-    {"TLDRAM_1333G", TLDRAM::Speed::TLDRAM_1333G},
-    {"TLDRAM_1333H", TLDRAM::Speed::TLDRAM_1333H},
-    {"TLDRAM_1600H", TLDRAM::Speed::TLDRAM_1600H},
-    {"TLDRAM_1600J", TLDRAM::Speed::TLDRAM_1600J},
-    {"TLDRAM_1600K", TLDRAM::Speed::TLDRAM_1600K},
-    {"TLDRAM_1866K", TLDRAM::Speed::TLDRAM_1866K},
-    {"TLDRAM_1866L", TLDRAM::Speed::TLDRAM_1866L},
-    {"TLDRAM_2133L", TLDRAM::Speed::TLDRAM_2133L},
-    {"TLDRAM_2133M", TLDRAM::Speed::TLDRAM_2133M},
-};
-
-
-TLDRAM::TLDRAM(Org org, Speed speed, int segment_ratio) :
-    segment_ratio(segment_ratio),
-    org_entry(org_table[int(org)]),
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nBL)
-{
-    this->segment_ratio = segment_ratio;
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-TLDRAM::TLDRAM(const string& org_str, const string& speed_str, int segment_ratio) :
-    TLDRAM(org_map[org_str], speed_map[speed_str], segment_ratio)
-{
-    this->segment_ratio = segment_ratio;
-}
-
-void TLDRAM::set_channel_number(int channel) {
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void TLDRAM::set_rank_number(int rank) {
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void TLDRAM::init_speed()
-{
-    // nRRD, nFAW
-    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4;
-          speed_entry.nFAW = (page==1) ? 16 : 20;
-          break;
-        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6;
-          speed_entry.nFAW = (page==1) ? 20 : 27;
-          break;
-        case 1333:
-          speed_entry.nRRD = (page==1) ? 4 : 5;
-          speed_entry.nFAW = (page==1) ? 20 : 30;
-          break;
-        case 1600:
-          speed_entry.nRRD = (page==1) ? 5 : 6;
-          speed_entry.nFAW = (page==1) ? 24 : 32;
-          break;
-        case 1866:
-          speed_entry.nRRD = (page==1) ? 5 : 6;
-          speed_entry.nFAW = (page==1) ? 26 : 33;
-          break;
-        case 2133:
-          speed_entry.nRRD = (page==1) ? 5 : 6;
-          speed_entry.nFAW = (page==1) ? 27 : 34;
-          break;
-        default: assert(false);
-    }
-
-    // nRFC, nXS
-    int chip = org_entry.size;
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44
-          : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59
-          : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74
-          : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88
-          : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103
-          : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118
-          : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-        default: assert(false);
-    }
-    switch (speed_entry.rate) {
-        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48
-          : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64
-          : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80
-          : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96
-          : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112
-          : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128
-          : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-        default: assert(false);
-    }
-}
-
-
-void TLDRAM::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }
-    };
-    prereq[int(Level::Rank)][int(Command::MIG)] = prereq[int(Level::Rank)][int(Command::RD)];
-
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed):
-                if (id % node->spec->segment_ratio)
-                    return Command::ACT;
-                else
-                    return Command::ACTF;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                if (id % node->spec->segment_ratio)
-                    return Command::PRE;
-                else
-                    return Command::PREF;
-            default: assert(false);
-        }
-    };
-    prereq[int(Level::Bank)][int(Command::MIG)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed):
-                return Command::ACTM;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PREM;
-            default: assert(false);
-        }
-    };
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            if (id % node->spec->segment_ratio)
-                return Command::PREA;
-            else
-                return Command::PREAF;
-        }
-        return Command::REF;
-    };
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PDE;
-            case int(State::ActPowerDown): return Command::PDE;
-            case int(State::PrePowerDown): return Command::PDE;
-            case int(State::SelfRefresh): return Command::SRX;
-            default: assert(false);
-        }
-    };
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SRE;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SRE;
-            default: assert(false);
-        }
-    };
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void TLDRAM::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void TLDRAM::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void TLDRAM::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;
-    };
-    lambda[int(Level::Bank)][int(Command::ACTF)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;
-    };
-    lambda[int(Level::Bank)][int(Command::ACTM)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;
-    };
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();
-    };
-    lambda[int(Level::Bank)][int(Command::PREF)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();
-    };
-    lambda[int(Level::Bank)][int(Command::PREM)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();
-    };
-    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();
-        }
-    };
-    lambda[int(Level::Rank)][int(Command::PREAF)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();
-        }
-    };
-    lambda[int(Level::Rank)][int(Command::PREAM)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();
-        }
-    };
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::MIG)] = [] (DRAM<TLDRAM>* node, int id) {};
-    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<TLDRAM>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;
-    };
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::PowerUp;
-    };
-    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::SelfRefresh;
-    };
-    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<TLDRAM>* node, int id) {
-        node->state = State::PowerUp;
-    };
-}
-
-
-void TLDRAM::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::MIG, 1, s.nBL});
-    t[int(Command::MIG)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-
-
-    /*** Rank ***/
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::MIG, 1, s.nCCD});
-    t[int(Command::MIG)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nCCD});
-
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::MIG)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::MIG, 1, s.nCWL + s.nBL + s.nWTR});
-
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::MIG, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREAF, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREAM, 1, s.nRTP});
-
-    t[int(Command::MIG)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::MIG)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::MIG)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-    t[int(Command::MIG)].push_back({Command::PREA, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREAF, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREAM, 1, s.nRTP});
-
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::MIG, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WR)].push_back({Command::PREAF, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WR)].push_back({Command::PREAM, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::MIG)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::MIG, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::ACTF, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACTF, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::ACTM, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACTM, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREF, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREAF, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREM, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREAM, 1, s.nRAS});
-
-    t[int(Command::ACTF)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACTF)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACTF)].push_back({Command::ACTF, 1, s.nRRD});
-    t[int(Command::ACTF)].push_back({Command::ACTF, 4, s.nFAW});
-    t[int(Command::ACTF)].push_back({Command::ACTM, 1, s.nRRD});
-    t[int(Command::ACTF)].push_back({Command::ACTM, 4, s.nFAW});
-    t[int(Command::ACTF)].push_back({Command::PRE, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREA, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREF, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREAF, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREM, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREAM, 1, s.nRASF});
-
-    t[int(Command::ACTM)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACTM)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACTM)].push_back({Command::ACTF, 1, s.nRRD});
-    t[int(Command::ACTM)].push_back({Command::ACTF, 4, s.nFAW});
-    t[int(Command::ACTM)].push_back({Command::ACTM, 1, s.nRRD});
-    t[int(Command::ACTM)].push_back({Command::ACTM, 4, s.nFAW});
-    t[int(Command::ACTM)].push_back({Command::PRE, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREA, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREF, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREAF, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREM, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREAM, 1, s.nRASM});
-
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTF, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTM, 1, s.nRP});
-
-    t[int(Command::PREF)].push_back({Command::ACT, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTF, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTM, 1, s.nRPF});
-
-    t[int(Command::PREM)].push_back({Command::ACT, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTF, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTM, 1, s.nRPM});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREF)].push_back({Command::REF, 1, s.nRPF});
-    t[int(Command::PREM)].push_back({Command::REF, 1, s.nRPM});
-
-    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PREAF)].push_back({Command::REF, 1, s.nRPF});
-    t[int(Command::PREAM)].push_back({Command::REF, 1, s.nRPM});
-
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-    t[int(Command::REF)].push_back({Command::ACTF, 1, s.nRFC});
-    t[int(Command::REF)].push_back({Command::ACTM, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-    t[int(Command::ACTF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::ACTM)].push_back({Command::PDE, 1, 1});
-
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::ACTF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::ACTM, 1, s.nXP});
-
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PREM, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREF)].push_back({Command::SRE, 1, s.nRPF});
-    t[int(Command::PREM)].push_back({Command::SRE, 1, s.nRPM});
-    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-    t[int(Command::PREAF)].push_back({Command::SRE, 1, s.nRPF});
-    t[int(Command::PREAM)].push_back({Command::SRE, 1, s.nRPM});
-
-    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-    t[int(Command::SRX)].push_back({Command::ACTF, 1, s.nXS});
-    t[int(Command::SRX)].push_back({Command::ACTM, 1, s.nXS});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-
-    // PD <-> PD
-    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-
-    // SR <-> SR
-    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-
-
-    /*** Bank ***/
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACTF)].push_back({Command::RD, 1, s.nRCDF});    // Fast Segment
-    t[int(Command::ACTM)].push_back({Command::RD, 1, s.nRCDM});    // Fast Segment
-
-    t[int(Command::ACT)].push_back({Command::MIG, 1, s.nRCD});
-    t[int(Command::ACTF)].push_back({Command::MIG, 1, s.nRCDF});  // Fast Segment
-    t[int(Command::ACTM)].push_back({Command::MIG, 1, s.nRCDM});  // Fast Segment
-
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACTF)].push_back({Command::WR, 1, s.nRCDF});    // Fast Segment
-    t[int(Command::ACTM)].push_back({Command::WR, 1, s.nRCDM});    // Fast Segment
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREF, 1, s.nRTP});
-    t[int(Command::RD)].push_back({Command::PREM, 1, s.nRTP});
-
-    t[int(Command::MIG)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREF, 1, s.nRTP});
-    t[int(Command::MIG)].push_back({Command::PREM, 1, s.nRTP});
-
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WR)].push_back({Command::PREF, 1, s.nCWL + s.nBL + s.nWR});
-
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::ACTF, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::ACTM, 1, s.nRC});
-    t[int(Command::ACTF)].push_back({Command::ACT, 1, s.nRCF});
-    t[int(Command::ACTF)].push_back({Command::ACTF, 1, s.nRCF});
-    t[int(Command::ACTF)].push_back({Command::ACTM, 1, s.nRCF});
-    t[int(Command::ACTM)].push_back({Command::ACT, 1, s.nRCM});
-    t[int(Command::ACTM)].push_back({Command::ACTF, 1, s.nRCM});
-    t[int(Command::ACTM)].push_back({Command::ACTM, 1, s.nRCM});
-
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREF, 1, s.nRAS});
-    t[int(Command::ACT)].push_back({Command::PREM, 1, s.nRAS});
-    t[int(Command::ACTF)].push_back({Command::PRE, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREF, 1, s.nRASF});
-    t[int(Command::ACTF)].push_back({Command::PREM, 1, s.nRASF});
-    t[int(Command::ACTM)].push_back({Command::PRE, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREF, 1, s.nRASM});
-    t[int(Command::ACTM)].push_back({Command::PREM, 1, s.nRASM});
-
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTF, 1, s.nRP});
-    t[int(Command::PRE)].push_back({Command::ACTM, 1, s.nRP});
-    t[int(Command::PREF)].push_back({Command::ACT, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTF, 1, s.nRPF});
-    t[int(Command::PREF)].push_back({Command::ACTM, 1, s.nRPF});
-    t[int(Command::PREM)].push_back({Command::ACT, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTF, 1, s.nRPM});
-    t[int(Command::PREM)].push_back({Command::ACTM, 1, s.nRPM});
-
-}
diff --git a/ext/ramulator/Ramulator/src/TLDRAM.h b/ext/ramulator/Ramulator/src/TLDRAM.h
deleted file mode 100644
index deced4239..000000000
--- a/ext/ramulator/Ramulator/src/TLDRAM.h
+++ /dev/null
@@ -1,261 +0,0 @@
-#ifndef __TLDRAM_H
-#define __TLDRAM_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <map>
-#include <string>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class TLDRAM
-{
-public:
-    int segment_ratio = 16;
-
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    TLDRAM(Org org, Speed speed, int segment_ratio);
-    TLDRAM(const string& org_str, const string& speed_str, int segment_ratio);
-
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-    /*** Level ***/
-    enum class Level : int
-    {
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    {
-        ACT, PRE, PREA,
-        RD, WR,
-        REF, PDE, PDX, SRE, SRX,
-        ACTF, PREF, PREAF,
-        MIG,
-        ACTM, PREM, PREAM,
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PREA",
-        "RD", "WR",
-        "REF", "PDE", "PDX", "SRE", "SRX",
-        "ACTF", "PREF", "PREAF",
-        "MIG",
-        "ACTM", "PREM", "PREAM"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row, Level::Bank, Level::Rank,
-        Level::Column, Level::Column,
-        Level::Rank, Level::Rank, Level::Rank, Level::Rank, Level::Rank,
-        Level::Row, Level::Bank, Level::Rank,
-        Level::Column,
-        Level::Row, Level::Bank, Level::Rank
-    };
-
-    bool is_opening(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-            case int(Command::ACTF):
-            case int(Command::ACTM):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::MIG):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::PRE):
-            case int(Command::PREF):
-            case int(Command::PREM):
-            case int(Command::PREA):
-            case int(Command::PREAF):
-            case int(Command::PREAM):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd)
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PDE, Command::SRE,
-        Command::MIG
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<TLDRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<TLDRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<TLDRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    };
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<TLDRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        TLDRAM_512Mb_x4, TLDRAM_512Mb_x8, TLDRAM_512Mb_x16,
-        TLDRAM_1Gb_x4,   TLDRAM_1Gb_x8,   TLDRAM_1Gb_x16,
-        TLDRAM_2Gb_x4,   TLDRAM_2Gb_x8,   TLDRAM_2Gb_x16,
-        TLDRAM_4Gb_x4,   TLDRAM_4Gb_x8,   TLDRAM_4Gb_x16,
-        TLDRAM_8Gb_x4,   TLDRAM_8Gb_x8,   TLDRAM_8Gb_x16,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        {  512,  4, {0, 0, 8, 1<<13, 1<<11}},
-        {  512,  8, {0, 0, 8, 1<<13, 1<<10}},
-        {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}},
-        {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}},
-        {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}},
-        {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}},
-        {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}},
-        {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}},
-        {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}},
-        {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}},
-        {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        TLDRAM_800D,  TLDRAM_800E,
-        TLDRAM_1066E, TLDRAM_1066F, TLDRAM_1066G,
-        TLDRAM_1333G, TLDRAM_1333H,
-        TLDRAM_1600H, TLDRAM_1600J, TLDRAM_1600K,
-        TLDRAM_1866K, TLDRAM_1866L,
-        TLDRAM_2133L, TLDRAM_2133M,
-        MAX
-    };
-
-    int prefetch_size = 8; // 8n prefetch DDR
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nRTRS;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFC, nREFI;
-        int nPD, nXP, nXPDLL;
-        int nCKESR, nXS, nXSDLL;
-        int nRCDF, nRPF, nRASF, nRCF;
-        int nRCDM, nRPM, nRASM, nRCM;
-    } speed_table[int(Speed::MAX)] = {
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0,
-          3120, 3, 3, 10, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0,
-          3120, 3, 3, 10, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0,
-          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0,
-          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0,
-          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0,
-          5200, 4, 4, 16, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0,
-          5200, 4, 4, 16, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0,
-          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0,
-          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0,
-          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0,
-          7280, 5, 6, 23, 6, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0,
-          7280, 5, 6, 23, 6, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0,
-          8320, 6, 7, 26, 7, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0,
-          8320, 6, 7, 26, 7, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__TLDRAM_H*/
diff --git a/ext/ramulator/Ramulator/src/WideIO.cpp b/ext/ramulator/Ramulator/src/WideIO.cpp
deleted file mode 100644
index 987193f89..000000000
--- a/ext/ramulator/Ramulator/src/WideIO.cpp
+++ /dev/null
@@ -1,326 +0,0 @@
-#include "WideIO.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string WideIO::standard_name = "WideIO";
-string WideIO::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum WideIO::Org> WideIO::org_map = {
-    {"WideIO_1Gb", WideIO::Org::WideIO_1Gb},
-    {"WideIO_2Gb", WideIO::Org::WideIO_2Gb},
-    {"WideIO_4Gb", WideIO::Org::WideIO_4Gb},
-    {"WideIO_8Gb", WideIO::Org::WideIO_8Gb},
-};
-
-map<string, enum WideIO::Speed> WideIO::speed_map = {
-    {"WideIO_200", WideIO::Speed::WideIO_200}, 
-    {"WideIO_266", WideIO::Speed::WideIO_266},
-};
-
-WideIO::WideIO(Org org, Speed speed) : 
-    org_entry(org_table[int(org)]), 
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    init_speed();
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_rowopen();
-    init_lambda();
-    init_timing();
-}
-
-WideIO::WideIO(const string& org_str, const string& speed_str) :
-    WideIO(org_map[org_str], speed_map[speed_str]) 
-{
-}
-
-void WideIO::set_channel_number(int channel) {
-  assert((channel == 4) && "The Wide I/O interface supports 4 physical and 4 logical channels.");
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void WideIO::set_rank_number(int rank) {
-  assert((rank == 1) && "WideIO rank number is fixed to 1.");
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void WideIO::init_speed()
-{
-    const static int RFC_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {18, 26, 26, 42},
-        {24, 35, 35, 56}
-    };
-    const static int REFI_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-        {3120, 1560, 780, 780},
-        {4160, 2080, 1040, 520}
-    };
-    int speed = 0, density = 0;
-    switch(speed_entry.rate){
-        case 200: speed = 0; break;
-        case 266: speed = 1; break;
-        default: assert(false);
-    }
-    switch(org_entry.size >> 8){
-        case 1: density = 0; break;
-        case 2: density = 1; break;
-        case 4: density = 2; break;
-        case 8: density = 3; break;
-        default: assert(false);
-    }
-    speed_entry.nRFC = RFC_TABLE[speed][density];
-    speed_entry.nREFI = REFI_TABLE[speed][density];
-}
-
-
-void WideIO::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PRA;
-        }
-        return Command::REF;};
-
-    // PD
-    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PD;
-            case int(State::ActPowerDown): return Command::PD;
-            case int(State::PrePowerDown): return Command::PD;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void WideIO::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<WideIO>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<WideIO>* node, int id) {};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<WideIO>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void WideIO::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nRTW});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nRTW});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nRTW});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nRTW});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-
-    // CAS <-> PRA
-    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 2, s.nTAW});
-    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRP});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRP});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRP});
-    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRP});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    
-    // PD <-> PD
-    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-    
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-}
diff --git a/ext/ramulator/Ramulator/src/WideIO.h b/ext/ramulator/Ramulator/src/WideIO.h
deleted file mode 100644
index 4cdbc7646..000000000
--- a/ext/ramulator/Ramulator/src/WideIO.h
+++ /dev/null
@@ -1,203 +0,0 @@
-#ifndef __WIDEIO_H
-#define __WIDEIO_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class WideIO
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    WideIO(Org org, Speed speed);
-    WideIO(const string& org_str, const string& speed_str);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE, PRA, 
-        RD,  WR,  RDA,  WRA, 
-        REF, PD,  PDX,  SREF, SREFX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE", "PRA", 
-        "RD",  "WR",  "RDA",  "WRA", 
-        "REF", "PD", "PDX",  "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PD, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<WideIO>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<WideIO>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<WideIO>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<WideIO>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        WideIO_1Gb,
-        WideIO_2Gb,
-        WideIO_4Gb,
-        WideIO_8Gb,
-        MAX
-    };
-
-    struct OrgEntry {
-        int size;
-        int dq;
-        int count[int(Level::MAX)];
-    } org_table[int(Org::MAX)] = {
-        // fixed to have 1 rank
-        { 256, 128, {0, 1, 4, 1<<12, 1<<7}},
-        { 512, 128, {0, 1, 4, 1<<13, 1<<7}},
-        {1024, 128, {0, 1, 4, 1<<14, 1<<7}},
-        {2048, 128, {0, 1, 4, 1<<15, 1<<7}}
-    }, org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        WideIO_200,
-        WideIO_266,
-        MAX
-    };
-    
-    int prefetch_size = 4; // 4n prefetch SDR
-    int channel_width = 128;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nDQSCK;
-        int nCL, nRCD, nRP, nCWL;
-        int nRAS, nRC;
-        int nRTP, nRTW, nWTR, nWR;
-        int nRRD, nTAW;
-        int nRFC, nREFI;
-        int nCKE, nXP;
-        int nCKESR, nXSR; // tXSR = tRFC+10
-    } speed_table[int(Speed::MAX)] = {
-        {200, 200.0/3*3, 5.0*3/3, 4, 4, 1, 3, 4, 4, 1,  9, 12, 4, 8, 3, 3, 2, 10, 0, 0, 3, 2, 3, 0},
-        {266, 200.0/3*4, 5.0*3/4, 4, 4, 1, 3, 5, 5, 1, 12, 16, 4, 8, 4, 4, 3, 14, 0, 0, 3, 3, 4, 0}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_speed();
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__WIDEIO_H*/
diff --git a/ext/ramulator/Ramulator/src/WideIO2.cpp b/ext/ramulator/Ramulator/src/WideIO2.cpp
deleted file mode 100644
index c4517382e..000000000
--- a/ext/ramulator/Ramulator/src/WideIO2.cpp
+++ /dev/null
@@ -1,339 +0,0 @@
-#include "WideIO2.h"
-#include "DRAM.h"
-#include <vector>
-#include <functional>
-#include <cassert>
-
-using namespace std;
-using namespace ramulator;
-
-string WideIO2::standard_name = "WideIO2";
-string WideIO2::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-
-map<string, enum WideIO2::Org> WideIO2::org_map = {
-    {"WideIO2_8Gb", WideIO2::Org::WideIO2_8Gb},
-};
-
-map<string, enum WideIO2::Speed> WideIO2::speed_map = {
-    {"WideIO2_800", WideIO2::Speed::WideIO2_800}, 
-    {"WideIO2_1066", WideIO2::Speed::WideIO2_1066},
-};
-
-WideIO2::WideIO2(Org org, Speed speed, int channels) :  
-    speed_entry(speed_table[int(speed)]),
-    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-{
-    switch(int(org)){
-        case int(Org::WideIO2_8Gb):
-            org_entry.size = (8<<10) / channels;
-            org_entry.dq = 64;
-            if (channels == 4) {
-                org_entry.size = 2<<10;
-                org_entry.count[int(Level::Channel)] = channels;
-                org_entry.count[int(Level::Rank)] = 0;
-                org_entry.count[int(Level::Bank)] = 8;
-                org_entry.count[int(Level::Row)] = 1<<13;
-                org_entry.count[int(Level::Column)] = 1<<9;
-            } else if (channels == 8) {
-                org_entry.size = 1<<10;
-                org_entry.count[int(Level::Channel)] = channels;
-                org_entry.count[int(Level::Rank)] = 0;
-                org_entry.count[int(Level::Bank)] = 4;
-                org_entry.count[int(Level::Row)] = 1<<14;
-                org_entry.count[int(Level::Column)] = 1<<8;
-            } else assert(false && "The WideIO2 interface supports 4 or 8 physical channels.");
-            break;
-        default: assert(false);
-    }
-    speed_entry.nRPab = (channels == 4)? speed_entry.nRP8b: speed_entry.nRPpb;
-    init_prereq();
-    init_rowhit(); // SAUGATA: added row hit function
-    init_lambda();
-    init_timing();
-}
-
-WideIO2::WideIO2(const string& org_str, const string& speed_str, int channels) :
-    WideIO2(org_map[org_str], speed_map[speed_str], channels)
-{
-}
-
-void WideIO2::set_channel_number(int channel) {
-  assert((channel == org_entry.count[int(Level::Channel)]) && "channel number must be consistent with spec initializaiton configuration.");
-  org_entry.count[int(Level::Channel)] = channel;
-}
-
-void WideIO2::set_rank_number(int rank) {
-  assert(((rank == 1) || (rank == 2)) && "WideIO2 supports single and dual rank configurations.");
-  org_entry.count[int(Level::Rank)] = rank;
-}
-
-void WideIO2::init_prereq()
-{
-    // RD
-    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::MAX;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return Command::ACT;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return cmd;
-                return Command::PRE;
-            default: assert(false);
-        }};
-    // WR
-    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-    // REF
-    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            return Command::PRA;
-        }
-        return Command::REF;};
-    // PD
-    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::PD;
-            case int(State::ActPowerDown): return Command::PD;
-            case int(State::PrePowerDown): return Command::PD;
-            case int(State::SelfRefresh): return Command::SREFX;
-            default: assert(false);
-        }};
-    // SR
-    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::PowerUp): return Command::SREF;
-            case int(State::ActPowerDown): return Command::PDX;
-            case int(State::PrePowerDown): return Command::PDX;
-            case int(State::SelfRefresh): return Command::SREF;
-            default: assert(false);
-        }};
-}
-
-// SAUGATA: added row hit check functions to see if the desired location is currently open
-void WideIO2::init_rowhit()
-{
-    // RD
-    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened):
-                if (node->row_state.find(id) != node->row_state.end())
-                    return true;
-                return false;
-            default: assert(false);
-        }};
-
-    // WR
-    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO2::init_rowopen()
-{
-    // RD
-    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-        switch (int(node->state)) {
-            case int(State::Closed): return false;
-            case int(State::Opened): return true;
-            default: assert(false);
-        }};
-
-    // WR
-    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-}
-
-void WideIO2::init_lambda()
-{
-    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Opened;
-        node->row_state[id] = State::Opened;};
-    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<WideIO2>* node, int id) {
-        for (auto bank : node->children) {
-            bank->state = State::Closed;
-            bank->row_state.clear();}};
-    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::Closed;
-        node->row_state.clear();};
-    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO2>* node, int id) {
-        for (auto bank : node->children) {
-            if (bank->state == State::Closed)
-                continue;
-            node->state = State::ActPowerDown;
-            return;
-        }
-        node->state = State::PrePowerDown;};
-    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::PowerUp;};
-    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::SelfRefresh;};
-    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<WideIO2>* node, int id) {
-        node->state = State::PowerUp;};
-}
-
-
-void WideIO2::init_timing()
-{
-    SpeedEntry& s = speed_entry;
-    vector<TimingEntry> *t;
-
-    /*** Channel ***/ 
-    t = timing[int(Level::Channel)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-
-
-    /*** Rank ***/ 
-    t = timing[int(Level::Rank)];
-
-    // CAS <-> CAS
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-
-    // CAS <-> CAS (between sibling ranks)
-    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-
-    // CAS <-> PRA
-    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + 1 + s.nBL + s.nWR});
-
-    // CAS <-> PD
-    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nDQSCK + s.nBL + 1});
-    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nDQSCK + s.nBL + 1});
-    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + 1 + s.nBL + s.nWR});
-    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + 1 + s.nBL + s.nWR + 1}); // +1 for pre
-    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-    
-    // CAS <-> SR: none (all banks have to be precharged)
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRPab});
-
-    // RAS <-> REF
-    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRPab});
-    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-
-    // RAS <-> PD
-    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-
-    // RAS <-> SR
-    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRPab});
-    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-
-    // REF <-> REF
-    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-
-    // REF <-> PD
-    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-    t[int(Command::REFPB)].push_back({Command::PD, 1, 1});
-    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-
-    // REF <-> SR
-    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-
-    // PD <-> PD
-    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-
-    // PD <-> SR
-    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-    
-    // SR <-> SR
-    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-
-    /*** Bank ***/ 
-    t = timing[int(Level::Bank)];
-
-    // CAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-
-    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + 1 + s.nBL + s.nWR});
-
-    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + 1 + s.nBL + s.nWR + s.nRPpb});
-
-    // RAS <-> RAS
-    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-
-    // between different banks
-    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-
-    // REFPB
-    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-}
diff --git a/ext/ramulator/Ramulator/src/WideIO2.h b/ext/ramulator/Ramulator/src/WideIO2.h
deleted file mode 100644
index 36ee794ff..000000000
--- a/ext/ramulator/Ramulator/src/WideIO2.h
+++ /dev/null
@@ -1,199 +0,0 @@
-#ifndef __WIDEIO2_H
-#define __WIDEIO2_H
-
-#include "DRAM.h"
-#include "Request.h"
-#include <vector>
-#include <functional>
-
-using namespace std;
-
-namespace ramulator
-{
-
-class WideIO2
-{
-public:
-    static string standard_name;
-    enum class Org;
-    enum class Speed;
-    WideIO2(Org org, Speed speed, int channels = 4);
-    WideIO2(const string& org_str, const string& speed_str, int channels = 4);
-    
-    static map<string, enum Org> org_map;
-    static map<string, enum Speed> speed_map;
-
-    /*** Level ***/
-    enum class Level : int
-    { 
-        Channel, Rank, Bank, Row, Column, MAX
-    };
-    
-    static std::string level_str [int(Level::MAX)];
-
-    /*** Command ***/
-    enum class Command : int
-    { 
-        ACT, PRE,   PRA, 
-        RD,  WR,    RDA,  WRA, 
-        REF, REFPB, PD,  PDX,  SREF, SREFX, 
-        MAX
-    };
-
-    string command_name[int(Command::MAX)] = {
-        "ACT", "PRE",   "PRA", 
-        "RD",  "WR",    "RDA", "WRA", 
-        "REF", "REFPB", "PD",  "PDX",  "SREF", "SREFX"
-    };
-
-    Level scope[int(Command::MAX)] = {
-        Level::Row,    Level::Bank,   Level::Rank,   
-        Level::Column, Level::Column, Level::Column, Level::Column,
-        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-    };
-
-    bool is_opening(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::ACT):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_accessing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RD):
-            case int(Command::WR):
-            case int(Command::RDA):
-            case int(Command::WRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_closing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::RDA):
-            case int(Command::WRA):
-            case int(Command::PRE):
-            case int(Command::PRA):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    bool is_refreshing(Command cmd) 
-    {
-        switch(int(cmd)) {
-            case int(Command::REF):
-            case int(Command::REFPB):
-                return true;
-            default:
-                return false;
-        }
-    }
-
-
-    /* State */
-    enum class State : int
-    {
-        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-    } start[int(Level::MAX)] = {
-        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-    };
-
-    /* Translate */
-    Command translate[int(Request::Type::MAX)] = {
-        Command::RD,  Command::WR,
-        Command::REF, Command::PD, Command::SREF
-    };
-
-    /* Prerequisite */
-    function<Command(DRAM<WideIO2>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-
-    // SAUGATA: added function object container for row hit status
-    /* Row hit */
-    function<bool(DRAM<WideIO2>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-    function<bool(DRAM<WideIO2>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-
-    /* Timing */
-    struct TimingEntry
-    {
-        Command cmd;
-        int dist;
-        int val;
-        bool sibling;
-    }; 
-    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-
-    /* Lambda */
-    function<void(DRAM<WideIO2>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-
-    /* Organization */
-    enum class Org : int
-    {
-        // per-die density
-        WideIO2_8Gb,
-        // WideIO2_12Gb, tRFC TBD
-        // WideIO2_16Gb, tRFC TBD
-        // WideIO2_24Gb, TBD
-        // WideIO2_32Gb, TBD
-        MAX
-    };
-
-    struct OrgEntry {
-        int size; // per-channel density
-        int dq;
-        int count[int(Level::MAX)];
-    } org_entry;
-
-    void set_channel_number(int channel);
-    void set_rank_number(int rank);
-
-    /* Speed */
-    enum class Speed : int
-    {
-        WideIO2_800,
-        WideIO2_1066,
-        MAX
-    };
-    // WideIO2 specified /4, /2, x1, x2, x4 refresh rates. x1 is used here
-
-    int prefetch_size = 4;
-    int channel_width = 64;
-
-    struct SpeedEntry {
-        int rate;
-        double freq, tCK;
-        int nBL, nCCD, nDQSCK, nRTRS; // 4n prefetch, DDR (although 8n is allowed?)
-        int nCL, nRCD, nRPpb, nRP8b, nRPab, nCWL;
-        int nRAS, nRC;
-        int nRTP, nWTR, nWR;
-        int nRRD, nFAW;
-        int nRFCab, nRFCpb, nREFI;
-        int nCKE, nXP;
-        int nCKESR, nXSR;
-    } speed_table[int(Speed::MAX)] = {
-        { 800, 800.0/3*3, 2.5*3/3, 2, 2, 1, 2, 7,  8,  8,  9, 0, 5, 17, 25, 3, 4,  8, 4, 24, 72, 36, 1560, 3, 3, 6,  76},
-        {1066, 800.0/3*4, 2.5*3/4, 2, 2, 1, 2, 9, 10, 10, 12, 0, 7, 23, 33, 4, 6, 11, 6, 32, 96, 48, 2080, 3, 4, 8, 102}
-    }, speed_entry;
-
-    int read_latency;
-
-private:
-    void init_lambda();
-    void init_prereq();
-    void init_rowhit();  // SAUGATA: added function to check for row hits
-    void init_rowopen();
-    void init_timing();
-};
-
-} /*namespace ramulator*/
-
-#endif /*__WIDEIO2_H*/
diff --git a/ext/ramulator/Ramulator/src/temp.txt b/ext/ramulator/Ramulator/src/temp.txt
deleted file mode 100644
index 2e4899223..000000000
--- a/ext/ramulator/Ramulator/src/temp.txt
+++ /dev/null
@@ -1,113 +0,0 @@
-
-
-#include "ALDRAM.h"
-#include "TLDRAM.h"
-
-
-    ALDRAM* aldram = new ALDRAM(ALDRAM::Org::ALDRAM_4Gb_x8, ALDRAM::Speed::ALDRAM_1600K);
-    IPC = run_simulation(aldram, argv[1], 1, 1, 4);
-    printf("ALDRAM:   %.5lf %.5lf\n", IPC, IPC / baseIPC);
-
-    TLDRAM* tldram = new TLDRAM(TLDRAM::Org::TLDRAM_4Gb_x8, TLDRAM::Speed::TLDRAM_1600K, 16);
-    IPC = run_simulation(tldram, argv[1], 1, 1, 4);
-    printf("TLDRAM:   %.5lf %.5lf\n", IPC, IPC / baseIPC);
-
-
-            // ALDRAM: update timing parameters based on temperatures
-            ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-            update_temp(current_temperature);
-
-
-    void update_temp(ALDRAM::Temp current_temperature)
-    {
-    }
-
-
-template <>
-void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature){
-    channel->spec->aldram_timing(current_temperature);
-}
-
-
-template <>
-void Controller<TLDRAM>::tick(){
-    clk++;
-
-    /*** 1. Serve completed reads ***/
-    if (pending.size()) {
-        Request& req = pending[0];
-        if (req.depart <= clk) {
-            req.callback(req);
-            pending.pop_front();
-        }
-    }
-
-    /*** 2. Should we schedule refreshes? ***/
-    int refresh_interval = channel->spec->speed_entry.nREFI;
-    if (clk - refreshed >= refresh_interval) {
-        auto req_type = Request::Type::REFRESH;
-
-        vector<int> addr_vec(int(TLDRAM::Level::MAX), -1);
-        addr_vec[0] = channel->id;
-        for (auto child : channel->children) {
-            addr_vec[1] = child->id;
-            Request req(addr_vec, req_type, NULL);
-            bool res = enqueue(req);
-            assert(res);
-        }
-        refreshed = clk;
-    }
-
-    /*** 3. Should we schedule writes? ***/
-    if (!write_mode) {
-        // yes -- write queue is almost full or read queue is empty
-        if (writeq.size() >= int(0.8 * writeq.max) || readq.size() == 0)
-            write_mode = true;
-    }
-    else {
-        // no -- write queue is almost empty and read queue is not empty
-        if (writeq.size() <= int(0.2 * writeq.max) && readq.size() != 0)
-            write_mode = false;
-    }
-
-    /*** 4. Find the best command to schedule, if any ***/
-    Queue* queue = !write_mode ? &readq : &writeq;
-    if (otherq.size())
-        queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-
-    auto req = scheduler->get_head(queue->q);
-    if (req == queue->q.end() || !is_ready(req)) {
-        // we couldn't find a command to schedule -- let's try to be speculative
-        auto cmd = TLDRAM::Command::PRE;
-        vector<int> victim = rowpolicy->get_victim(cmd);
-        if (!victim.empty()){
-            issue_cmd(cmd, victim);
-        }
-        return;  // nothing more to be done this cycle
-    }
-
-    /*** 5. Change a read request to a migration request ***/
-    if (req->type == Request::Type::READ) {
-        req->type = Request::Type::EXTENSION;
-    }
-
-    // issue command on behalf of request
-    auto cmd = get_first_cmd(req);
-    issue_cmd(cmd, get_addr_vec(cmd, req));
-
-    // check whether this is the last command (which finishes the request)
-    if (cmd != channel->spec->translate[int(req->type)])
-        return;
-
-    // set a future completion time for read requests
-    if (req->type == Request::Type::READ || req->type == Request::Type::EXTENSION) {
-        req->depart = clk + channel->spec->read_latency;
-        pending.push_back(*req);
-    }
-
-    // remove request from queue
-    queue->q.erase(req);
-}
-
-
-        EXTENSION,  // DHL: supporting extended functionality
diff --git a/ext/ramulator/SConscript b/ext/ramulator/SConscript
deleted file mode 100644
index 270903473..000000000
--- a/ext/ramulator/SConscript
+++ /dev/null
@@ -1,49 +0,0 @@
-# -*- mode:python -*-
-
-import os
-
-Import('main')
-
-if not os.path.exists(Dir('.').srcnode().abspath + '/Ramulator'):
-    main['HAVE_RAMULATOR'] = False
-    Return()
-
-# We have got the folder, so add the library and build the wrappers
-main['HAVE_RAMULATOR'] = True
-
-# Add the appropriate files. We leave out the trace driven simulator
-dram_files = []
-
-def DRAMFile(filename):
-    dram_files.append(File('Ramulator/src/' + filename))
-
-DRAMFile('Config.cpp')
-DRAMFile('Controller.cpp')
-DRAMFile('DDR3.cpp')
-DRAMFile('DDR4.cpp')
-DRAMFile('GDDR5.cpp')
-DRAMFile('Gem5Wrapper.cpp')
-DRAMFile('HBM.cpp')
-DRAMFile('LPDDR3.cpp')
-DRAMFile('LPDDR4.cpp')
-DRAMFile('MemoryFactory.cpp')
-DRAMFile('SALP.cpp')
-DRAMFile('WideIO.cpp')
-DRAMFile('WideIO2.cpp')
-DRAMFile('TLDRAM.cpp')
-DRAMFile('ALDRAM.cpp')
-
-dramenv = main.Clone()
-dramenv.Append(CXXFLAGS=['-g'])
-dramenv.Append(CXXFLAGS=['-Wno-missing-field-initializers'])
-dramenv.Append(CXXFLAGS=['-Wno-unused-variable'])
-dramenv.Append(CXXFLAGS=['-Wno-reorder'])
-
-# added support to hook in gem5 headers
-dramenv.Append(CPPPATH = Dir('./../../src/'))
-
-dramenv.Library('ramulator', [dramenv.SharedObject(f) for f in dram_files])
-
-main.Prepend(CPPPATH=Dir('.'))
-main.Append(LIBS=['ramulator'])
-main.Prepend(LIBPATH=[Dir('.')])
diff --git a/gem5_ramulator.diff b/gem5_ramulator.diff
deleted file mode 100644
index 37a54bd13..000000000
--- a/gem5_ramulator.diff
+++ /dev/null
@@ -1,19744 +0,0 @@
-diff --git a/ext/ramulator/README b/ext/ramulator/README
-new file mode 100644
-index 0000000..e1850e9
---- /dev/null
-+++ b/ext/ramulator/README
-@@ -0,0 +1,11 @@
-+To use Ramulator in gem5 simulations
-+
-+1. Download Ramulator
-+    1.1 Go to ext/ramulator (this directory)
-+    1.2 Clone Ramulator: git clone git://github.com/CMU-SAFARI/ramulator.git
-+
-+2. Compile gem5
-+
-+3. Run gem5 with Ramulator
-+    3.1 Use --mem-type=ramulator and --ramulator-config=XXX
-+
-diff --git a/ext/ramulator/Ramulator/src/ALDRAM.cpp b/ext/ramulator/Ramulator/src/ALDRAM.cpp
-new file mode 100644
-index 0000000..453300b
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/ALDRAM.cpp
-@@ -0,0 +1,362 @@
-+#include <iostream>
-+
-+#include "ALDRAM.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string ALDRAM::standard_name = "ALDRAM";
-+string ALDRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum ALDRAM::Org> ALDRAM::org_map = {
-+    {"ALDRAM_512Mb_x4", ALDRAM::Org::ALDRAM_512Mb_x4}, {"ALDRAM_512Mb_x8", ALDRAM::Org::ALDRAM_512Mb_x8}, {"ALDRAM_512Mb_x16", ALDRAM::Org::ALDRAM_512Mb_x16},
-+    {"ALDRAM_1Gb_x4", ALDRAM::Org::ALDRAM_1Gb_x4}, {"ALDRAM_1Gb_x8", ALDRAM::Org::ALDRAM_1Gb_x8}, {"ALDRAM_1Gb_x16", ALDRAM::Org::ALDRAM_1Gb_x16},
-+    {"ALDRAM_2Gb_x4", ALDRAM::Org::ALDRAM_2Gb_x4}, {"ALDRAM_2Gb_x8", ALDRAM::Org::ALDRAM_2Gb_x8}, {"ALDRAM_2Gb_x16", ALDRAM::Org::ALDRAM_2Gb_x16},
-+    {"ALDRAM_4Gb_x4", ALDRAM::Org::ALDRAM_4Gb_x4}, {"ALDRAM_4Gb_x8", ALDRAM::Org::ALDRAM_4Gb_x8}, {"ALDRAM_4Gb_x16", ALDRAM::Org::ALDRAM_4Gb_x16},
-+    {"ALDRAM_8Gb_x4", ALDRAM::Org::ALDRAM_8Gb_x4}, {"ALDRAM_8Gb_x8", ALDRAM::Org::ALDRAM_8Gb_x8}, {"ALDRAM_8Gb_x16", ALDRAM::Org::ALDRAM_8Gb_x16},
-+};
-+
-+map<string, enum ALDRAM::Speed> ALDRAM::speed_map = {
-+    {"ALDRAM_800D", ALDRAM::Speed::ALDRAM_800D}, {"ALDRAM_800E", ALDRAM::Speed::ALDRAM_800E},
-+    {"ALDRAM_1066E", ALDRAM::Speed::ALDRAM_1066E}, {"ALDRAM_1066F", ALDRAM::Speed::ALDRAM_1066F}, {"ALDRAM_1066G", ALDRAM::Speed::ALDRAM_1066G},
-+    {"ALDRAM_1333G", ALDRAM::Speed::ALDRAM_1333G}, {"ALDRAM_1333H", ALDRAM::Speed::ALDRAM_1333H},
-+    {"ALDRAM_1600H", ALDRAM::Speed::ALDRAM_1600H}, {"ALDRAM_1600J", ALDRAM::Speed::ALDRAM_1600J}, {"ALDRAM_1600K", ALDRAM::Speed::ALDRAM_1600K},
-+    {"ALDRAM_1866K", ALDRAM::Speed::ALDRAM_1866K}, {"ALDRAM_1866L", ALDRAM::Speed::ALDRAM_1866L},
-+    {"ALDRAM_2133L", ALDRAM::Speed::ALDRAM_2133L}, {"ALDRAM_2133M", ALDRAM::Speed::ALDRAM_2133M},
-+};
-+
-+
-+ALDRAM::ALDRAM(Org org, Speed speed) :
-+    org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(Temp::COLD)][int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    current_speed = speed;
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_lambda();
-+    init_timing(speed_table[int(Temp::HOT)][int(speed)]);
-+    temperature = Temp::COLD;
-+}
-+
-+ALDRAM::ALDRAM(const string& org_str, const string& speed_str) :
-+    ALDRAM(org_map[org_str], speed_map[speed_str])
-+{
-+}
-+
-+void ALDRAM::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void ALDRAM::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void ALDRAM::aldram_timing(Temp current_temperature)
-+{
-+    for (int i = 0; i < int(Level::MAX); i++) {
-+        for (int j = 0; j < int(Command::MAX); j++) {
-+            timing[i][j].clear();
-+        }
-+    }
-+    temperature = current_temperature;
-+    read_latency = speed_entry.nCL + speed_entry.nBL;
-+    init_timing(speed_table[int(temperature)][int(current_speed)]);
-+
-+    //std::cout << "vector size: " << timing[int(Temp::HOT)][int(current_speed)].size() << endl;
-+    //std::cout << "after cold nRCD : ";
-+    //std::cout << int(timing[int(Level::Bank)][int(Command::ACT)][0].val) << endl << endl;
-+}
-+
-+void ALDRAM::init_speed()
-+{
-+    // nRRD, nFAW
-+    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-+        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-+        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-+        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-+        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-+        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-+        default: assert(false);
-+    }
-+
-+    // nRFC, nXS
-+    int chip = org_entry.size;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-+        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-+        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-+        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-+        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-+        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-+        default: assert(false);
-+    }
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-+        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-+        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-+        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-+        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-+        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-+        default: assert(false);
-+    }
-+}
-+
-+
-+void ALDRAM::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PREA;
-+        }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void ALDRAM::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+
-+void ALDRAM::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<ALDRAM>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<ALDRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<ALDRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<ALDRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<ALDRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<ALDRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<ALDRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<ALDRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<ALDRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<ALDRAM>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<ALDRAM>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<ALDRAM>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void ALDRAM::init_timing(SpeedEntry speed_entry)
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+}
-diff --git a/ext/ramulator/Ramulator/src/ALDRAM.h b/ext/ramulator/Ramulator/src/ALDRAM.h
-new file mode 100644
-index 0000000..dad6228
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/ALDRAM.h
-@@ -0,0 +1,249 @@
-+#ifndef __ALDRAM_H
-+#define __ALDRAM_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <map>
-+#include <string>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class ALDRAM
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    enum class Temp;
-+
-+    ALDRAM(Org org, Speed speed);
-+    ALDRAM(const string& org_str, const string& speed_str);
-+
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    /*** Level ***/
-+    enum class Level : int
-+    {
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    {
-+        ACT, PRE, PREA,
-+        RD,  WR,  RDA,  WRA,
-+        REF, PDE, PDX,  SRE, SRX,
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA",
-+        "RD",  "WR",  "RDA",  "WRA",
-+        "REF", "PDE", "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<ALDRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<ALDRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<ALDRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    };
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<ALDRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        ALDRAM_512Mb_x4, ALDRAM_512Mb_x8, ALDRAM_512Mb_x16,
-+        ALDRAM_1Gb_x4,   ALDRAM_1Gb_x8,   ALDRAM_1Gb_x16,
-+        ALDRAM_2Gb_x4,   ALDRAM_2Gb_x8,   ALDRAM_2Gb_x16,
-+        ALDRAM_4Gb_x4,   ALDRAM_4Gb_x8,   ALDRAM_4Gb_x16,
-+        ALDRAM_8Gb_x4,   ALDRAM_8Gb_x8,   ALDRAM_8Gb_x16,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-+        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-+        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-+        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-+        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        ALDRAM_800D,  ALDRAM_800E,
-+        ALDRAM_1066E, ALDRAM_1066F, ALDRAM_1066G,
-+        ALDRAM_1333G, ALDRAM_1333H,
-+        ALDRAM_1600H, ALDRAM_1600J, ALDRAM_1600K,
-+        ALDRAM_1866K, ALDRAM_1866L,
-+        ALDRAM_2133L, ALDRAM_2133M,
-+        MAX
-+    };
-+
-+    Speed current_speed;
-+
-+    enum class Temp : int
-+    {
-+        COLD, HOT, MAX
-+    };
-+
-+    Temp temperature = Temp::HOT;  // DHL
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRD, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL;
-+        int nCKESR, nXS, nXSDLL;
-+    } speed_table[int(Temp::MAX)][int(Speed::MAX)] = {
-+        {
-+            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5-1,  5-1,  5, 15-5, 20-6, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-+            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6-1,  6-1,  5, 15-5, 21-6, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-+            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6-1,  6-1,  6, 20-5, 26-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7-1,  7-1,  6, 20-5, 27-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8-1,  8-1,  6, 20-5, 28-6, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8-1,  8-1,  7, 24-5, 32-6, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-+            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9-1,  9-1,  7, 24-5, 33-6, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-+            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9-2,  9-2,  8, 28-10, 37-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10-2, 10-2,  8, 28-10, 38-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11-2, 11-2,  8, 28-10, 39-12, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11-2, 11-2,  9, 32-10, 43-12, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-+            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12-2, 12-3,  9, 32-10, 44-13, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-+            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12-2, 12-3, 10, 36-10, 48-13, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-+            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13-2, 13-3, 10, 36-10, 49-13, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-+        },
-+        {
-+            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-+            {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-+            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+            {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-+            {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-+            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+            {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-+            {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-+            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-+            {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-+        }
-+    }, speed_entry;
-+
-+    int read_latency;
-+    void aldram_timing(Temp current_temperature);
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing(SpeedEntry speed_entry);
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__ALDRAM_H*/
-diff --git a/ext/ramulator/Ramulator/src/Cache.cpp b/ext/ramulator/Ramulator/src/Cache.cpp
-new file mode 100644
-index 0000000..6a383ed
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Cache.cpp
-@@ -0,0 +1,432 @@
-+#include "Cache.h"
-+
-+#ifndef DEBUG_CACHE
-+#define debug(...)
-+#else
-+#define debug(...) do { \
-+          printf("\033[36m[DEBUG] %s ", __FUNCTION__); \
-+          printf(__VA_ARGS__); \
-+          printf("\033[0m\n"); \
-+      } while (0)
-+#endif
-+
-+namespace ramulator
-+{
-+
-+Cache::Cache(int size, int assoc, int block_size,
-+    int mshr_entry_num, Level level,
-+    std::shared_ptr<CacheSystem> cachesys):
-+    level(level), cachesys(cachesys), higher_cache(0),
-+    lower_cache(nullptr), size(size), assoc(assoc),
-+    block_size(block_size), mshr_entry_num(mshr_entry_num) {
-+
-+  debug("level %d size %d assoc %d block_size %d\n",
-+      int(level), size, assoc, block_size);
-+
-+  if (level == Level::L1) {
-+    level_string = "L1";
-+  } else if (level == Level::L2) {
-+    level_string = "L2";
-+  } else if (level == Level::L3) {
-+    level_string = "L3";
-+  }
-+
-+  is_first_level = (level == cachesys->first_level);
-+  is_last_level = (level == cachesys->last_level);
-+
-+  // Check size, block size and assoc are 2^N
-+  assert((size & (size - 1)) == 0);
-+  assert((block_size & (block_size - 1)) == 0);
-+  assert((assoc & (assoc - 1)) == 0);
-+  assert(size >= block_size);
-+
-+  // Initialize cache configuration
-+  block_num = size / (block_size * assoc);
-+  index_mask = block_num - 1;
-+  index_offset = calc_log2(block_size);
-+  tag_offset = calc_log2(block_num) + index_offset;
-+
-+  debug("index_offset %d", index_offset);
-+  debug("index_mask 0x%x", index_mask);
-+  debug("tag_offset %d", tag_offset);
-+
-+  // regStats
-+  cache_read_miss.name(level_string + string("_cache_read_miss"))
-+                 .desc("cache read miss count")
-+                 .precision(0)
-+                 ;
-+
-+  cache_write_miss.name(level_string + string("_cache_write_miss"))
-+                  .desc("cache write miss count")
-+                  .precision(0)
-+                  ;
-+
-+  cache_total_miss.name(level_string + string("_cache_total_miss"))
-+                  .desc("cache total miss count")
-+                  .precision(0)
-+                  ;
-+
-+  cache_eviction.name(level_string + string("_cache_eviction"))
-+                .desc("number of evict from this level to lower level")
-+                .precision(0)
-+                ;
-+
-+  cache_read_access.name(level_string + string("_cache_read_access"))
-+                  .desc("cache read access count")
-+                  .precision(0)
-+                  ;
-+
-+  cache_write_access.name(level_string + string("_cache_write_access"))
-+                    .desc("cache write access count")
-+                    .precision(0)
-+                    ;
-+
-+  cache_total_access.name(level_string + string("_cache_total_access"))
-+                    .desc("cache total access count")
-+                    .precision(0)
-+                    ;
-+
-+  cache_mshr_hit.name(level_string + string("_cache_mshr_hit"))
-+                .desc("cache mshr hit count")
-+                .precision(0)
-+                ;
-+  cache_mshr_unavailable.name(level_string + string("_cache_mshr_unavailable"))
-+                         .desc("cache mshr not available count")
-+                         .precision(0)
-+                         ;
-+  cache_set_unavailable.name(level_string + string("_cache_set_unavailable"))
-+                         .desc("cache set not available")
-+                         .precision(0)
-+                         ;
-+}
-+
-+bool Cache::send(Request req) {
-+  debug("level %d req.addr %lx req.type %d, index %d, tag %ld",
-+      int(level), req.addr, int(req.type), get_index(req.addr),
-+      get_tag(req.addr));
-+
-+  cache_total_access++;
-+  if (req.type == Request::Type::WRITE) {
-+    cache_write_access++;
-+  } else {
-+    assert(req.type == Request::Type::READ);
-+    cache_read_access++;
-+  }
-+  // If there isn't a set, create it.
-+  auto& lines = get_lines(req.addr);
-+  std::list<Line>::iterator line;
-+
-+  if (is_hit(lines, req.addr, &line)) {
-+    lines.push_back(Line(req.addr, get_tag(req.addr), false,
-+        line->dirty || (req.type == Request::Type::WRITE)));
-+    lines.erase(line);
-+    cachesys->hit_list.push_back(
-+        make_pair(cachesys->clk + latency[int(level)], req));
-+
-+    debug("hit, update timestamp %ld", cachesys->clk);
-+    debug("hit finish time %ld",
-+        cachesys->clk + latency[int(level)]);
-+
-+    return true;
-+
-+  } else {
-+    debug("miss @level %d", int(level));
-+    cache_total_miss++;
-+    if (req.type == Request::Type::WRITE) {
-+      cache_write_miss++;
-+    } else {
-+      assert(req.type == Request::Type::READ);
-+      cache_read_miss++;
-+    }
-+
-+    // The dirty bit will be set if this is a write request and @L1
-+    bool dirty = (req.type == Request::Type::WRITE);
-+
-+    // Modify the type of the request to lower level
-+    if (req.type == Request::Type::WRITE) {
-+      req.type = Request::Type::READ;
-+    }
-+
-+    // Look it up in MSHR entries
-+    assert(req.type == Request::Type::READ);
-+    auto mshr = hit_mshr(req.addr);
-+    if (mshr != mshr_entries.end()) {
-+      debug("hit mshr");
-+      cache_mshr_hit++;
-+      mshr->second->dirty = dirty || mshr->second->dirty;
-+      return true;
-+    }
-+
-+    // All requests come to this stage will be READ, so they
-+    // should be recorded in MSHR entries.
-+    if (mshr_entries.size() == mshr_entry_num) {
-+      // When no MSHR entries available, the miss request
-+      // is stalling.
-+      cache_mshr_unavailable++;
-+      debug("no mshr entry available");
-+      return false;
-+    }
-+
-+    // Check whether there is a line available
-+    if (all_sets_locked(lines)) {
-+      cache_set_unavailable++;
-+      return false;
-+    }
-+
-+    auto newline = allocate_line(lines, req.addr);
-+    if (newline == lines.end()) {
-+      return false;
-+    }
-+
-+    newline->dirty = dirty;
-+
-+    // Add to MSHR entries
-+    mshr_entries.push_back(make_pair(req.addr, newline));
-+
-+    // Send the request to next level;
-+    if (!is_last_level) {
-+      if(!lower_cache->send(req)) {
-+        retry_list.push_back(req);
-+      }
-+    } else {
-+      cachesys->wait_list.push_back(
-+          make_pair(cachesys->clk + latency[int(level)], req));
-+    }
-+    return true;
-+  }
-+}
-+
-+void Cache::evictline(long addr, bool dirty) {
-+
-+  auto it = cache_lines.find(get_index(addr));
-+  assert(it != cache_lines.end()); // check inclusive cache
-+  auto& lines = it->second;
-+  auto line = find_if(lines.begin(), lines.end(),
-+      [addr, this](Line l){return (l.tag == get_tag(addr));});
-+
-+  assert(line != lines.end());
-+  // Update LRU queue. The dirty bit will be set if the dirty
-+  // bit inherited from higher level(s) is set.
-+  lines.push_back(Line(addr, get_tag(addr), false,
-+      dirty || line->dirty));
-+  lines.erase(line);
-+}
-+
-+std::pair<long, bool> Cache::invalidate(long addr) {
-+  long delay = latency_each[int(level)];
-+  bool dirty = false;
-+
-+  auto& lines = get_lines(addr);
-+  if (lines.size() == 0) {
-+    // The line of this address doesn't exist.
-+    return make_pair(0, false);
-+  }
-+  auto line = find_if(lines.begin(), lines.end(),
-+      [addr, this](Line l){return (l.tag == get_tag(addr));});
-+
-+  // If the line is in this level cache, then erase it from
-+  // the buffer.
-+  if (line != lines.end()) {
-+    assert(!line->lock);
-+    debug("invalidate %lx @ level %d", addr, int(level));
-+    lines.erase(line);
-+  } else {
-+    // If it's not in current level, then no need to go up.
-+    return make_pair(delay, false);
-+  }
-+
-+  if (higher_cache.size()) {
-+    long max_delay = delay;
-+    for (auto hc : higher_cache) {
-+      auto result = hc->invalidate(addr);
-+      if (result.second) {
-+        max_delay = max(max_delay, delay + result.first * 2);
-+      } else {
-+        max_delay = max(max_delay, delay + result.first);
-+      }
-+      dirty = dirty || line->dirty || result.second;
-+    }
-+    delay = max_delay;
-+  } else {
-+    dirty = line->dirty;
-+  }
-+  return make_pair(delay, dirty);
-+}
-+
-+
-+void Cache::evict(std::list<Line>* lines,
-+    std::list<Line>::iterator victim) {
-+  debug("level %d miss evict victim %lx", int(level), victim->addr);
-+  cache_eviction++;
-+
-+  long addr = victim->addr;
-+  long invalidate_time = 0;
-+  bool dirty = victim->dirty;
-+
-+  // First invalidate the victim line in higher level.
-+  if (higher_cache.size()) {
-+    for (auto hc : higher_cache) {
-+      auto result = hc->invalidate(addr);
-+      invalidate_time = max(invalidate_time,
-+          result.first + (result.second ? latency_each[int(level)] : 0));
-+      dirty = dirty || result.second || victim->dirty;
-+    }
-+  }
-+
-+  debug("invalidate delay: %ld, dirty: %s", invalidate_time,
-+      dirty ? "true" : "false");
-+
-+  if (!is_last_level) {
-+    // not LLC eviction
-+    assert(lower_cache != nullptr);
-+    lower_cache->evictline(addr, dirty);
-+  } else {
-+    // LLC eviction
-+    if (dirty) {
-+      Request write_req(addr, Request::Type::WRITE);
-+      cachesys->wait_list.push_back(make_pair(
-+          cachesys->clk + invalidate_time + latency[int(level)],
-+          write_req));
-+
-+      debug("inject one write request to memory system "
-+          "addr %lx, invalidate time %ld, issue time %ld",
-+          write_req.addr, invalidate_time,
-+          cachesys->clk + invalidate_time + latency[int(level)]);
-+    }
-+  }
-+
-+  lines->erase(victim);
-+}
-+
-+std::list<Cache::Line>::iterator Cache::allocate_line(
-+    std::list<Line>& lines, long addr) {
-+  // See if an eviction is needed
-+  if (need_eviction(lines, addr)) {
-+    // Get victim.
-+    // The first one might still be locked due to reorder in MC
-+    auto victim = find_if(lines.begin(), lines.end(),
-+        [this](Line line) {
-+          bool check = !line.lock;
-+          if (!is_first_level) {
-+            for (auto hc : higher_cache) {
-+              if(!check) {
-+                return check;
-+              }
-+              check = check && hc->check_unlock(line.addr);
-+            }
-+          }
-+          return check;
-+        });
-+    if (victim == lines.end()) {
-+      return victim;  // doesn't exist a line that's already unlocked in each level
-+    }
-+    assert(victim != lines.end());
-+    evict(&lines, victim);
-+  }
-+
-+  // Allocate newline, with lock bit on and dirty bit off
-+  lines.push_back(Line(addr, get_tag(addr)));
-+  auto last_element = lines.end();
-+  --last_element;
-+  return last_element;
-+}
-+
-+bool Cache::is_hit(std::list<Line>& lines, long addr,
-+    std::list<Line>::iterator* pos_ptr) {
-+  auto pos = find_if(lines.begin(), lines.end(),
-+      [addr, this](Line l){return (l.tag == get_tag(addr));});
-+  *pos_ptr = pos;
-+  if (pos == lines.end()) {
-+    return false;
-+  }
-+  return !pos->lock;
-+}
-+
-+void Cache::concatlower(Cache* lower) {
-+  lower_cache = lower;
-+  assert(lower != nullptr);
-+  lower->higher_cache.push_back(this);
-+};
-+
-+bool Cache::need_eviction(const std::list<Line>& lines, long addr) {
-+  if (find_if(lines.begin(), lines.end(),
-+      [addr, this](Line l){
-+        return (get_tag(addr) == l.tag);})
-+      != lines.end()) {
-+    // Due to MSHR, the program can't reach here. Just for checking
-+    assert(false);
-+  } else {
-+    if (lines.size() < assoc) {
-+      return false;
-+    } else {
-+      return true;
-+    }
-+  }
-+}
-+
-+void Cache::callback(Request& req) {
-+  debug("level %d", int(level));
-+
-+  auto it = find_if(mshr_entries.begin(), mshr_entries.end(),
-+      [&req, this](std::pair<long, std::list<Line>::iterator> mshr_entry) {
-+        return (align(mshr_entry.first) == align(req.addr));
-+      });
-+
-+  if (it != mshr_entries.end()) {
-+    it->second->lock = false;
-+    mshr_entries.erase(it);
-+  }
-+
-+  if (higher_cache.size()) {
-+    for (auto hc : higher_cache) {
-+      hc->callback(req);
-+    }
-+  }
-+}
-+
-+void Cache::tick() {
-+
-+    if(!lower_cache->is_last_level)
-+        lower_cache->tick();
-+
-+    for (auto it = retry_list.begin(); it != retry_list.end(); it++) {
-+        if(lower_cache->send(*it))
-+            it = retry_list.erase(it);
-+    }
-+
-+}
-+
-+void CacheSystem::tick() {
-+  debug("clk %ld", clk);
-+
-+  ++clk;
-+
-+  // Sends ready waiting request to memory
-+  auto it = wait_list.begin();
-+  while (it != wait_list.end() && clk >= it->first) {
-+    if (!send_memory(it->second)) {
-+      ++it;
-+    } else {
-+
-+      debug("complete req: addr %lx", (it->second).addr);
-+
-+      it = wait_list.erase(it);
-+    }
-+  }
-+
-+  // hit request callback
-+  it = hit_list.begin();
-+  while (it != hit_list.end()) {
-+    if (clk >= it->first) {
-+      it->second.callback(it->second);
-+
-+      debug("finish hit: addr %lx", (it->second).addr);
-+
-+      it = hit_list.erase(it);
-+    } else {
-+      ++it;
-+    }
-+  }
-+}
-+
-+} // namespace ramulator
-diff --git a/ext/ramulator/Ramulator/src/Cache.h b/ext/ramulator/Ramulator/src/Cache.h
-new file mode 100644
-index 0000000..b9869c7
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Cache.h
-@@ -0,0 +1,242 @@
-+#ifndef __CACHE_H
-+#define __CACHE_H
-+
-+#include "Config.h"
-+#include "Request.h"
-+#include "Statistics.h"
-+#include <algorithm>
-+#include <cstdio>
-+#include <cassert>
-+#include <functional>
-+#include <list>
-+#include <map>
-+#include <memory>
-+#include <queue>
-+#include <list>
-+
-+namespace ramulator
-+{
-+class CacheSystem;
-+
-+class Cache {
-+protected:
-+  ScalarStat cache_read_miss;
-+  ScalarStat cache_write_miss;
-+  ScalarStat cache_total_miss;
-+  ScalarStat cache_eviction;
-+  ScalarStat cache_read_access;
-+  ScalarStat cache_write_access;
-+  ScalarStat cache_total_access;
-+  ScalarStat cache_mshr_hit;
-+  ScalarStat cache_mshr_unavailable;
-+  ScalarStat cache_set_unavailable;
-+public:
-+  enum class Level {
-+    L1,
-+    L2,
-+    L3,
-+    MAX
-+  } level;
-+  std::string level_string;
-+
-+  struct Line {
-+    long addr;
-+    long tag;
-+    bool lock; // When the lock is on, the value is not valid yet.
-+    bool dirty;
-+    Line(long addr, long tag):
-+        addr(addr), tag(tag), lock(true), dirty(false) {}
-+    Line(long addr, long tag, bool lock, bool dirty):
-+        addr(addr), tag(tag), lock(lock), dirty(dirty) {}
-+  };
-+
-+  Cache(int size, int assoc, int block_size, int mshr_entry_num,
-+      Level level, std::shared_ptr<CacheSystem> cachesys);
-+
-+  void tick();
-+
-+  // L1, L2, L3 accumulated latencies
-+  int latency[int(Level::MAX)] = {4, 4 + 12, 4 + 12 + 31};
-+  int latency_each[int(Level::MAX)] = {4, 12, 31};
-+
-+  std::shared_ptr<CacheSystem> cachesys;
-+  // LLC has multiple higher caches
-+  std::vector<Cache*> higher_cache;
-+  Cache* lower_cache;
-+
-+  bool send(Request req);
-+
-+  void concatlower(Cache* lower);
-+
-+  void callback(Request& req);
-+
-+protected:
-+
-+  bool is_first_level;
-+  bool is_last_level;
-+  size_t size;
-+  unsigned int assoc;
-+  unsigned int block_num;
-+  unsigned int index_mask;
-+  unsigned int block_size;
-+  unsigned int index_offset;
-+  unsigned int tag_offset;
-+  unsigned int mshr_entry_num;
-+  std::vector<std::pair<long, std::list<Line>::iterator>> mshr_entries;
-+  std::list<Request> retry_list;
-+
-+  std::map<int, std::list<Line> > cache_lines;
-+
-+  int calc_log2(int val) {
-+      int n = 0;
-+      while ((val >>= 1))
-+          n ++;
-+      return n;
-+  }
-+
-+  int get_index(long addr) {
-+    return (addr >> index_offset) & index_mask;
-+  };
-+
-+  long get_tag(long addr) {
-+    return (addr >> tag_offset);
-+  }
-+
-+  // Align the address to cache line size
-+  long align(long addr) {
-+    return (addr & ~(block_size-1l));
-+  }
-+
-+  // Evict the cache line from higher level to this level.
-+  // Pass the dirty bit and update LRU queue.
-+  void evictline(long addr, bool dirty);
-+
-+  // Invalidate the line from this level to higher levels
-+  // The return value is a pair. The first element is invalidation
-+  // latency, and the second is wether the value has new version
-+  // in higher level and this level.
-+  std::pair<long, bool> invalidate(long addr);
-+
-+  // Evict the victim from current set of lines.
-+  // First do invalidation, then call evictline(L1 or L2) or send
-+  // a write request to memory(L3) when dirty bit is on.
-+  void evict(std::list<Line>* lines,
-+      std::list<Line>::iterator victim);
-+
-+  // First test whether need eviction, if so, do eviction by
-+  // calling evict function. Then allocate a new line and return
-+  // the iterator points to it.
-+  std::list<Line>::iterator allocate_line(
-+      std::list<Line>& lines, long addr);
-+
-+  // Check whether the set to hold addr has space or eviction is
-+  // needed.
-+  bool need_eviction(const std::list<Line>& lines, long addr);
-+
-+  // Check whether this addr is hit and fill in the pos_ptr with
-+  // the iterator to the hit line or lines.end()
-+  bool is_hit(std::list<Line>& lines, long addr,
-+              std::list<Line>::iterator* pos_ptr);
-+
-+  bool all_sets_locked(const std::list<Line>& lines) {
-+    if (lines.size() < assoc) {
-+      return false;
-+    }
-+    for (const auto& line : lines) {
-+      if (!line.lock) {
-+        return false;
-+      }
-+    }
-+    return true;
-+  }
-+
-+  bool check_unlock(long addr) {
-+    auto it = cache_lines.find(get_index(addr));
-+    if (it == cache_lines.end()) {
-+      return true;
-+    } else {
-+      auto& lines = it->second;
-+      auto line = find_if(lines.begin(), lines.end(),
-+          [addr, this](Line l){return (l.tag == get_tag(addr));});
-+      if (line == lines.end()) {
-+        return true;
-+      } else {
-+        bool check = !line->lock;
-+        if (!is_first_level) {
-+          for (auto hc : higher_cache) {
-+            if (!check) {
-+              return check;
-+            }
-+            check = check && hc->check_unlock(line->addr);
-+          }
-+        }
-+        return check;
-+      }
-+    }
-+  }
-+
-+  std::vector<std::pair<long, std::list<Line>::iterator>>::iterator
-+  hit_mshr(long addr) {
-+    auto mshr_it =
-+        find_if(mshr_entries.begin(), mshr_entries.end(),
-+            [addr, this](std::pair<long, std::list<Line>::iterator>
-+                   mshr_entry) {
-+              return (align(mshr_entry.first) == align(addr));
-+            });
-+    return mshr_it;
-+  }
-+
-+  std::list<Line>& get_lines(long addr) {
-+    if (cache_lines.find(get_index(addr))
-+        == cache_lines.end()) {
-+      cache_lines.insert(make_pair(get_index(addr),
-+          std::list<Line>()));
-+    }
-+    return cache_lines[get_index(addr)];
-+  }
-+
-+};
-+
-+class CacheSystem {
-+public:
-+  CacheSystem(const Config& configs, std::function<bool(Request)> send_memory):
-+    send_memory(send_memory) {
-+      if (configs.has_core_caches()) {
-+        first_level = Cache::Level::L1;
-+      } else if (configs.has_l3_cache()) {
-+        first_level = Cache::Level::L3;
-+      } else {
-+        last_level = Cache::Level::MAX; // no cache
-+      }
-+
-+      if (configs.has_l3_cache()) {
-+        last_level = Cache::Level::L3;
-+      } else if (configs.has_core_caches()) {
-+        last_level = Cache::Level::L2;
-+      } else {
-+        last_level = Cache::Level::MAX; // no cache
-+      }
-+    }
-+
-+  // wait_list contains miss requests with their latencies in
-+  // cache. When this latency is met, the send_memory function
-+  // will be called to send the request to the memory system.
-+  std::list<std::pair<long, Request> > wait_list;
-+
-+  // hit_list contains hit requests with their latencies in cache.
-+  // callback function will be called when this latency is met and
-+  // set the instruction status to ready in processor's window.
-+  std::list<std::pair<long, Request> > hit_list;
-+
-+  std::function<bool(Request)> send_memory;
-+
-+  long clk = 0;
-+  void tick();
-+
-+  Cache::Level first_level;
-+  Cache::Level last_level;
-+};
-+
-+} // namespace ramulator
-+
-+#endif /* __CACHE_H */
-diff --git a/ext/ramulator/Ramulator/src/Config.cpp b/ext/ramulator/Ramulator/src/Config.cpp
-new file mode 100644
-index 0000000..b3a4658
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Config.cpp
-@@ -0,0 +1,67 @@
-+#include "Config.h"
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+Config::Config(const std::string& fname) {
-+  parse(fname);
-+}
-+
-+void Config::parse(const string& fname)
-+{
-+    ifstream file(fname);
-+    assert(file.good() && "Bad config file");
-+    string line;
-+
-+    while (getline(file, line)) {
-+        char delim[] = " \t=";
-+        vector<string> tokens;
-+
-+        while (true) {
-+            size_t start = line.find_first_not_of(delim);
-+            if (start == string::npos) 
-+                break;
-+
-+            size_t end = line.find_first_of(delim, start);
-+            if (end == string::npos) {
-+                tokens.push_back(line.substr(start));
-+                break;
-+            }
-+
-+            tokens.push_back(line.substr(start, end - start));
-+            line = line.substr(end);
-+        }
-+
-+        // empty line
-+        if (!tokens.size())
-+            continue;
-+
-+        // comment line
-+        if (tokens[0][0] == '#')
-+            continue;
-+
-+        // parameter line
-+        assert(tokens.size() == 2 && "Only allow two tokens in one line");
-+
-+        options[tokens[0]] = tokens[1];
-+
-+        if (tokens[0] == "channels") {
-+          channels = atoi(tokens[1].c_str());
-+        } else if (tokens[0] == "ranks") {
-+          ranks = atoi(tokens[1].c_str());
-+        } else if (tokens[0] == "subarrays") {
-+          subarrays = atoi(tokens[1].c_str());
-+        } else if (tokens[0] == "cpu_tick") {
-+          cpu_tick = atoi(tokens[1].c_str());
-+        } else if (tokens[0] == "mem_tick") {
-+          mem_tick = atoi(tokens[1].c_str());
-+        } else if (tokens[0] == "expected_limit_insts") {
-+          expected_limit_insts = atoi(tokens[1].c_str());
-+        } else if (tokens[0] == "warmup_insts") {
-+          warmup_insts = atoi(tokens[1].c_str());
-+        }
-+    }
-+    file.close();
-+}
-+
-+
-diff --git a/ext/ramulator/Ramulator/src/Config.h b/ext/ramulator/Ramulator/src/Config.h
-new file mode 100644
-index 0000000..aef68dc
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Config.h
-@@ -0,0 +1,126 @@
-+#ifndef __CONFIG_H
-+#define __CONFIG_H
-+
-+#include <string>
-+#include <fstream>
-+#include <vector>
-+#include <map>
-+#include <iostream>
-+#include <cassert>
-+
-+namespace ramulator
-+{
-+
-+class Config {
-+
-+private:
-+    std::map<std::string, std::string> options;
-+    int channels;
-+    int ranks;
-+    int subarrays;
-+    int cpu_tick;
-+    int mem_tick;
-+    int core_num = 0;
-+    long expected_limit_insts = 0;
-+    long warmup_insts = 0;
-+    std::string tracefile_directory;
-+
-+public:
-+    Config() {}
-+    Config(const std::string& fname);
-+    void parse(const std::string& fname);
-+    std::string operator [] (const std::string& name) const {
-+      if (options.find(name) != options.end()) {
-+        return (options.find(name))->second;
-+      } else {
-+        return "";
-+      }
-+    }
-+
-+    bool contains(const std::string& name) const {
-+      if (options.find(name) != options.end()) {
-+        return true;
-+      } else {
-+        return false;
-+      }
-+    }
-+
-+    void add (const std::string& name, const std::string& value) {
-+      if (!contains(name)) {
-+        options.insert(make_pair(name, value));
-+      } else {
-+        printf("ramulator::Config::add options[%s] already set.\n", name.c_str());
-+      }
-+    }
-+
-+    std::string get_tracefile_directory() const { return tracefile_directory; }
-+    void set_tracefile_directory(std::string directory) { tracefile_directory = directory; }
-+    
-+
-+    void set_core_num(int _core_num) {core_num = _core_num;}
-+
-+    int get_channels() const {return channels;}
-+    int get_subarrays() const {return subarrays;}
-+    int get_ranks() const {return ranks;}
-+    int get_cpu_tick() const {return cpu_tick;}
-+    int get_mem_tick() const {return mem_tick;}
-+    int get_core_num() const {return core_num;}
-+    long get_expected_limit_insts() const {return expected_limit_insts;}
-+    long get_warmup_insts() const {return warmup_insts;}
-+
-+    bool has_l3_cache() const {
-+      if (options.find("cache") != options.end()) {
-+        const std::string& cache_option = (options.find("cache"))->second;
-+        return (cache_option == "all") || (cache_option == "L3");
-+      } else {
-+        return false;
-+      }
-+    }
-+    bool has_core_caches() const {
-+      if (options.find("cache") != options.end()) {
-+        const std::string& cache_option = (options.find("cache"))->second;
-+        return (cache_option == "all" || cache_option == "L1L2");
-+      } else {
-+        return false;
-+      }
-+    }
-+    bool is_early_exit() const {
-+      // the default value is true
-+      if (options.find("early_exit") != options.end()) {
-+        if ((options.find("early_exit"))->second == "off") {
-+          return false;
-+        }
-+        return true;
-+      }
-+      return true;
-+    }
-+    bool calc_weighted_speedup() const {
-+      return (expected_limit_insts != 0);
-+    }
-+    bool record_cmd_trace() const {
-+      // the default value is false
-+      if (options.find("record_cmd_trace") != options.end()) {
-+        if ((options.find("record_cmd_trace"))->second == "on") {
-+          return true;
-+        }
-+        return false;
-+      }
-+      return false;
-+    }
-+    bool print_cmd_trace() const {
-+      // the default value is false
-+      if (options.find("print_cmd_trace") != options.end()) {
-+        if ((options.find("print_cmd_trace"))->second == "on") {
-+          return true;
-+        }
-+        return false;
-+      }
-+      return false;
-+    }
-+};
-+
-+
-+} /* namespace ramulator */
-+
-+#endif /* _CONFIG_H */
-+
-diff --git a/ext/ramulator/Ramulator/src/Controller.cpp b/ext/ramulator/Ramulator/src/Controller.cpp
-new file mode 100644
-index 0000000..af2e9db
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Controller.cpp
-@@ -0,0 +1,204 @@
-+#include "Controller.h"
-+#include "SALP.h"
-+#include "ALDRAM.h"
-+#include "TLDRAM.h"
-+
-+using namespace ramulator;
-+
-+namespace ramulator
-+{
-+
-+static vector<int> get_offending_subarray(DRAM<SALP>* channel, vector<int> & addr_vec){
-+    int sa_id = 0;
-+    auto rank = channel->children[addr_vec[int(SALP::Level::Rank)]];
-+    auto bank = rank->children[addr_vec[int(SALP::Level::Bank)]];
-+    auto sa = bank->children[addr_vec[int(SALP::Level::SubArray)]];
-+    for (auto sa_other : bank->children)
-+        if (sa != sa_other && sa_other->state == SALP::State::Opened){
-+            sa_id = sa_other->id;
-+            break;
-+        }
-+    vector<int> offending = addr_vec;
-+    offending[int(SALP::Level::SubArray)] = sa_id;
-+    offending[int(SALP::Level::Row)] = -1;
-+    return offending;
-+}
-+
-+
-+template <>
-+vector<int> Controller<SALP>::get_addr_vec(SALP::Command cmd, list<Request>::iterator req){
-+    if (cmd == SALP::Command::PRE_OTHER)
-+        return get_offending_subarray(channel, req->addr_vec);
-+    else
-+        return req->addr_vec;
-+}
-+
-+
-+template <>
-+bool Controller<SALP>::is_ready(list<Request>::iterator req){
-+    SALP::Command cmd = get_first_cmd(req);
-+    if (cmd == SALP::Command::PRE_OTHER){
-+
-+        vector<int> addr_vec = get_offending_subarray(channel, req->addr_vec);
-+        return channel->check(cmd, addr_vec.data(), clk);
-+    }
-+    else return channel->check(cmd, req->addr_vec.data(), clk);
-+}
-+
-+template <>
-+void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature){
-+    channel->spec->aldram_timing(current_temperature);
-+}
-+
-+
-+template <>
-+void Controller<TLDRAM>::tick(){
-+    clk++;
-+    req_queue_length_sum += readq.size() + writeq.size();
-+    read_req_queue_length_sum += readq.size();
-+    write_req_queue_length_sum += writeq.size();
-+
-+    /*** 1. Serve completed reads ***/
-+    if (pending.size()) {
-+        Request& req = pending[0];
-+        if (req.depart <= clk) {
-+          if (req.depart - req.arrive > 1) {
-+                  read_latency_sum += req.depart - req.arrive;
-+		  // gagan : demand and prefetch reads
-+		  if(req.is_prefetch)
-+		    prefetch_read_latency_sum += req.depart - req.arrive;
-+		  else
-+		    demand_read_latency_sum += req.depart - req.arrive;
-+                  channel->update_serving_requests(
-+                      req.addr_vec.data(), -1, clk);
-+          }
-+            req.callback(req);
-+            pending.pop_front();
-+        }
-+    }
-+
-+    /*** 2. Should we schedule refreshes? ***/
-+    refresh->tick_ref();
-+
-+    /*** 3. Should we schedule writes? ***/
-+    if (!write_mode) {
-+        // yes -- write queue is almost full or read queue is empty
-+        if (writeq.size() >= int(0.8 * writeq.max) /*|| readq.size() == 0*/)
-+            write_mode = true;
-+    }
-+    else {
-+        // no -- write queue is almost empty and read queue is not empty
-+        if (writeq.size() <= int(0.2 * writeq.max) && readq.size() != 0)
-+            write_mode = false;
-+    }
-+
-+    /*** 4. Find the best command to schedule, if any ***/
-+    Queue* queue = !write_mode ? &readq : &writeq;
-+    if (otherq.size())
-+        queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-+
-+    auto req = scheduler->get_head(queue->q);
-+    if (req == queue->q.end() || !is_ready(req)) {
-+        // we couldn't find a command to schedule -- let's try to be speculative
-+        auto cmd = TLDRAM::Command::PRE;
-+        vector<int> victim = rowpolicy->get_victim(cmd);
-+        if (!victim.empty()){
-+            issue_cmd(cmd, victim);
-+        }
-+        return;  // nothing more to be done this cycle
-+    }
-+
-+    if (req->is_first_command) {
-+        int coreid = req->coreid;
-+        req->is_first_command = false;
-+        if (req->type == Request::Type::READ || req->type == Request::Type::WRITE) {
-+          channel->update_serving_requests(req->addr_vec.data(), 1, clk);
-+        }
-+        int tx = (channel->spec->prefetch_size * channel->spec->channel_width / 8);
-+        if (req->type == Request::Type::READ) {
-+            if (is_row_hit(req)) {
-+                ++read_row_hits[coreid];
-+                ++row_hits;
-+                // daz3
-+                period_read_row_hits++;
-+            } else if (is_row_open(req)) {
-+                ++read_row_conflicts[coreid];
-+                ++row_conflicts;
-+                // daz3
-+                period_read_row_conflicts++;
-+            } else {
-+                ++read_row_misses[coreid];
-+                ++row_misses;
-+                // daz3
-+                period_read_row_misses++;
-+            }
-+            read_transaction_bytes += tx;
-+        } else if (req->type == Request::Type::WRITE) {
-+            if (is_row_hit(req)) {
-+                ++write_row_hits[coreid];
-+                ++row_hits;
-+                // daz3
-+                period_write_row_hits++;
-+            } else if (is_row_open(req)) {
-+                ++write_row_conflicts[coreid];
-+                ++row_conflicts;
-+                // daz3
-+                period_write_row_conflicts++;
-+            } else {
-+                ++write_row_misses[coreid];
-+                ++row_misses;
-+                // daz3
-+                period_write_row_misses++;
-+            }
-+          write_transaction_bytes += tx;
-+        }
-+    }
-+
-+    /*** 5. Change a read request to a migration request ***/
-+    if (req->type == Request::Type::READ) {
-+        req->type = Request::Type::EXTENSION;
-+    }
-+
-+    // issue command on behalf of request
-+    auto cmd = get_first_cmd(req);
-+    issue_cmd(cmd, get_addr_vec(cmd, req));
-+
-+    // check whether this is the last command (which finishes the request)
-+    if (cmd != channel->spec->translate[int(req->type)])
-+        return;
-+
-+    // set a future completion time for read requests
-+    if (req->type == Request::Type::READ || req->type == Request::Type::EXTENSION) {
-+        req->depart = clk + channel->spec->read_latency;
-+        pending.push_back(*req);
-+    }
-+    if (req->type == Request::Type::WRITE) {
-+        channel->update_serving_requests(req->addr_vec.data(), -1, clk);
-+    }
-+
-+    // remove request from queue
-+    queue->q.erase(req);
-+
-+    // daz3
-+    if(clk % my_print_intelval == 0)
-+    {
-+        std::cout << "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv" << std::endl;
-+        std::cout << "clk " << clk << std::endl;
-+        std::cout << "period_read_row_hits " << period_read_row_hits << std::endl;
-+        std::cout << "period_read_row_misses " << period_read_row_misses << std::endl;
-+        std::cout << "period_read_row_conflicts " << period_read_row_conflicts << std::endl;
-+        std::cout << "period_write_row_hits " << period_write_row_hits << std::endl;
-+        std::cout << "period_write_row_misses " << period_write_row_misses << std::endl;
-+        std::cout << "period_write_row_conflicts " << period_write_row_conflicts << std::endl;
-+        std::cout << "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" << std::endl;
-+    }
-+}
-+
-+template<>
-+void Controller<TLDRAM>::cmd_issue_autoprecharge(typename TLDRAM::Command& cmd,
-+                                                    const vector<int>& addr_vec) {
-+    //TLDRAM currently does not have autoprecharge commands
-+    return;
-+}
-+
-+} /* namespace ramulator */
-diff --git a/ext/ramulator/Ramulator/src/Controller.h b/ext/ramulator/Ramulator/src/Controller.h
-new file mode 100644
-index 0000000..8a30e9d
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Controller.h
-@@ -0,0 +1,902 @@
-+#ifndef __CONTROLLER_H
-+#define __CONTROLLER_H
-+
-+#include <cassert>
-+#include <cstdio>
-+#include <deque>
-+#include <fstream>
-+#include <list>
-+#include <string>
-+#include <vector>
-+#include <queue>
-+
-+#include "Config.h"
-+#include "DRAM.h"
-+#include "Refresh.h"
-+#include "Request.h"
-+#include "Scheduler.h"
-+#include "Statistics.h"
-+
-+#include "ALDRAM.h"
-+#include "SALP.h"
-+#include "TLDRAM.h"
-+#include "DDR4.h"
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+    extern bool warmup_complete;
-+
-+template <typename T>
-+class Controller
-+{
-+protected:
-+    // For counting bandwidth
-+    ScalarStat read_transaction_bytes;
-+    ScalarStat write_transaction_bytes;
-+
-+    ScalarStat row_hits;
-+    ScalarStat row_misses;
-+    ScalarStat row_conflicts;
-+    VectorStat read_row_hits;
-+    VectorStat read_row_misses;
-+    VectorStat read_row_conflicts;
-+    VectorStat write_row_hits;
-+    VectorStat write_row_misses;
-+    VectorStat write_row_conflicts;
-+    ScalarStat useless_activates;
-+
-+    ScalarStat read_latency_avg;
-+    ScalarStat read_latency_sum;
-+    // gagan : demand requests and prefetch requests
-+    ScalarStat demand_read_latency_avg;
-+    ScalarStat demand_read_latency_sum;
-+    ScalarStat prefetch_read_latency_avg;
-+    ScalarStat prefetch_read_latency_sum;
-+
-+    ScalarStat req_queue_length_avg;
-+    ScalarStat req_queue_length_sum;
-+    ScalarStat read_req_queue_length_avg;
-+    ScalarStat read_req_queue_length_sum;
-+    ScalarStat write_req_queue_length_avg;
-+    ScalarStat write_req_queue_length_sum;
-+
-+#ifndef INTEGRATED_WITH_GEM5
-+    VectorStat record_read_hits;
-+    VectorStat record_read_misses;
-+    VectorStat record_read_conflicts;
-+    VectorStat record_write_hits;
-+    VectorStat record_write_misses;
-+    VectorStat record_write_conflicts;
-+#endif
-+
-+public:
-+    /* Member Variables */
-+    long clk = 0;
-+    DRAM<T>* channel;
-+
-+    // gagan : enable_debug
-+    bool enable_debug;
-+
-+    // daz3
-+    long period_read_row_hits;
-+    long period_read_row_misses;
-+    long period_read_row_conflicts;
-+    long period_write_row_hits;
-+    long period_write_row_misses;
-+    long period_write_row_conflicts;
-+    long my_print_intelval = 200000000; //every 0.2ms
-+
-+    Scheduler<T>* scheduler;  // determines the highest priority request whose commands will be issued
-+    RowPolicy<T>* rowpolicy;  // determines the row-policy (e.g., closed-row vs. open-row)
-+    RowTable<T>* rowtable;  // tracks metadata about rows (e.g., which are open and for how long)
-+    Refresh<T>* refresh;
-+
-+    struct Queue {
-+        list<Request> q;
-+        unsigned int max = 32;
-+        // daz3: test tWTR
-+        // unsigned int max = 16;
-+        unsigned int size() { return q.size(); }
-+      void print()
-+      {
-+	//std::cout << "Printing queue: " << std::endl;
-+	for(auto &i : q)
-+	  {
-+	    i.print();
-+	  }
-+      }
-+
-+      bool hasRequestType(Request::Type type)
-+      {
-+	for(auto &r : q)
-+	  {
-+	    if(r.type == type)
-+	      return true;
-+	  }
-+	return false;
-+      }
-+    };
-+
-+    Queue readq;  // queue for read requests
-+    Queue writeq;  // queue for write requests
-+    Queue actq; // read and write requests for which activate was issued are moved to 
-+                   // actq, which has higher priority than readq and writeq.
-+                   // This is an optimization
-+                   // for avoiding useless activations (i.e., PRECHARGE
-+                   // after ACTIVATE w/o READ of WRITE command)
-+    Queue otherq;  // queue for all "other" requests (e.g., refresh)
-+
-+    deque<Request> pending;  // read requests that are about to receive data from DRAM
-+    bool write_mode = false;  // whether write requests should be prioritized over reads
-+    float wr_high_watermark = 0.8f; // threshold for switching to write mode
-+    float wr_low_watermark = 0.2f; // threshold for switching back to read mode
-+    //long refreshed = 0;  // last time refresh requests were generated
-+
-+    /* Command trace for DRAMPower 3.1 */
-+    string cmd_trace_prefix = "cmd-trace-";
-+    vector<ofstream> cmd_trace_files;
-+    bool record_cmd_trace = false;
-+    /* Commands to stdout */
-+    bool print_cmd_trace = false;
-+
-+    /* Constructor */
-+    Controller(const Config& configs, DRAM<T>* channel, bool enable_debug) :
-+        enable_debug(enable_debug),
-+        channel(channel),
-+        scheduler(new Scheduler<T>(this)),
-+        rowpolicy(new RowPolicy<T>(this)),
-+        rowtable(new RowTable<T>(this)),
-+        refresh(new Refresh<T>(this)),
-+        cmd_trace_files(channel->children.size())
-+    {
-+        // daz3: set read/write queue
-+        // readq.max = 128;
-+        readq.max = 512;
-+        writeq.max = 128;
-+        // writeq.max = 256;
-+        std::cout << "Controller readq " << readq.max << ", writeq " << writeq.max << std::endl;
-+
-+        record_cmd_trace = configs.record_cmd_trace();
-+        print_cmd_trace = configs.print_cmd_trace();
-+        if (record_cmd_trace){
-+            if (configs["cmd_trace_prefix"] != "") {
-+              cmd_trace_prefix = configs["cmd_trace_prefix"];
-+            }
-+	    std::string traceDir = configs.get_tracefile_directory();
-+            string prefix = traceDir + cmd_trace_prefix + "chan-" + to_string(channel->id) + "-rank-";
-+            string suffix = ".cmdtrace";
-+            for (unsigned int i = 0; i < channel->children.size(); i++)
-+                cmd_trace_files[i].open(prefix + to_string(i) + suffix);
-+        }
-+
-+        // daz3
-+        period_read_row_hits = 0;
-+        period_read_row_misses = 0;
-+        period_read_row_conflicts = 0;
-+        period_write_row_hits = 0;
-+        period_write_row_misses = 0;
-+        period_write_row_conflicts = 0;
-+
-+        // regStats
-+
-+        row_hits
-+            .name("row_hits_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row hits per channel per core")
-+            .precision(0)
-+            ;
-+        row_misses
-+            .name("row_misses_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row misses per channel per core")
-+            .precision(0)
-+            ;
-+        row_conflicts
-+            .name("row_conflicts_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row conflicts per channel per core")
-+            .precision(0)
-+            ;
-+
-+        read_row_hits
-+            .init(configs.get_core_num())
-+            .name("read_row_hits_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row hits for read requests per channel per core")
-+            .precision(0)
-+            ;
-+        read_row_misses
-+            .init(configs.get_core_num())
-+            .name("read_row_misses_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row misses for read requests per channel per core")
-+            .precision(0)
-+            ;
-+        read_row_conflicts
-+            .init(configs.get_core_num())
-+            .name("read_row_conflicts_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row conflicts for read requests per channel per core")
-+            .precision(0)
-+            ;
-+
-+        write_row_hits
-+            .init(configs.get_core_num())
-+            .name("write_row_hits_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row hits for write requests per channel per core")
-+            .precision(0)
-+            ;
-+        write_row_misses
-+            .init(configs.get_core_num())
-+            .name("write_row_misses_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row misses for write requests per channel per core")
-+            .precision(0)
-+            ;
-+        write_row_conflicts
-+            .init(configs.get_core_num())
-+            .name("write_row_conflicts_channel_"+to_string(channel->id) + "_core")
-+            .desc("Number of row conflicts for write requests per channel per core")
-+            .precision(0)
-+            ;
-+
-+        useless_activates
-+            .name("useless_activates_"+to_string(channel->id)+ "_core")
-+            .desc("Number of useless activations. E.g, ACT -> PRE w/o RD or WR")
-+            .precision(0)
-+            ;
-+
-+        read_transaction_bytes
-+            .name("read_transaction_bytes_"+to_string(channel->id))
-+            .desc("The total byte of read transaction per channel")
-+            .precision(0)
-+            ;
-+        write_transaction_bytes
-+            .name("write_transaction_bytes_"+to_string(channel->id))
-+            .desc("The total byte of write transaction per channel")
-+            .precision(0)
-+            ;
-+
-+        read_latency_sum
-+            .name("read_latency_sum_"+to_string(channel->id))
-+            .desc("The memory latency cycles (in memory time domain) sum for all read requests in this channel")
-+            .precision(0)
-+            ;
-+        read_latency_avg
-+            .name("read_latency_avg_"+to_string(channel->id))
-+            .desc("The average memory latency cycles (in memory time domain) per request for all read requests in this channel")
-+            .precision(6)
-+            ;
-+	// gagan : demand and prefetch read requests
-+        demand_read_latency_sum
-+            .name("demand_read_latency_sum_"+to_string(channel->id))
-+            .desc("The memory latency cycles (in memory time domain) sum for demand read requests in this channel")
-+            .precision(0)
-+            ;
-+        demand_read_latency_avg
-+            .name("demand_read_latency_avg_"+to_string(channel->id))
-+            .desc("The average memory latency cycles (in memory time domain) per request for demand read requests in this channel")
-+            .precision(6)
-+            ;
-+	prefetch_read_latency_sum
-+            .name("prefetch_read_latency_sum_"+to_string(channel->id))
-+            .desc("The memory latency cycles (in memory time domain) sum for prefetch read requests in this channel")
-+            .precision(0)
-+            ;
-+        prefetch_read_latency_avg
-+            .name("prefetch_read_latency_avg_"+to_string(channel->id))
-+            .desc("The average memory latency cycles (in memory time domain) per request for prefetch read requests in this channel")
-+            .precision(6)
-+            ;
-+        req_queue_length_sum
-+            .name("req_queue_length_sum_"+to_string(channel->id))
-+            .desc("Sum of read and write queue length per memory cycle per channel.")
-+            .precision(0)
-+            ;
-+        req_queue_length_avg
-+            .name("req_queue_length_avg_"+to_string(channel->id))
-+            .desc("Average of read and write queue length per memory cycle per channel.")
-+            .precision(6)
-+            ;
-+
-+        read_req_queue_length_sum
-+            .name("read_req_queue_length_sum_"+to_string(channel->id))
-+            .desc("Read queue length sum per memory cycle per channel.")
-+            .precision(0)
-+            ;
-+        read_req_queue_length_avg
-+            .name("read_req_queue_length_avg_"+to_string(channel->id))
-+            .desc("Read queue length average per memory cycle per channel.")
-+            .precision(6)
-+            ;
-+
-+        write_req_queue_length_sum
-+            .name("write_req_queue_length_sum_"+to_string(channel->id))
-+            .desc("Write queue length sum per memory cycle per channel.")
-+            .precision(0)
-+            ;
-+        write_req_queue_length_avg
-+            .name("write_req_queue_length_avg_"+to_string(channel->id))
-+            .desc("Write queue length average per memory cycle per channel.")
-+            .precision(6)
-+            ;
-+
-+#ifndef INTEGRATED_WITH_GEM5
-+        record_read_hits
-+            .init(configs.get_core_num())
-+            .name("record_read_hits")
-+            .desc("record read hit count for this core when it reaches request limit or to the end")
-+            ;
-+
-+        record_read_misses
-+            .init(configs.get_core_num())
-+            .name("record_read_misses")
-+            .desc("record_read_miss count for this core when it reaches request limit or to the end")
-+            ;
-+
-+        record_read_conflicts
-+            .init(configs.get_core_num())
-+            .name("record_read_conflicts")
-+            .desc("record read conflict count for this core when it reaches request limit or to the end")
-+            ;
-+
-+        record_write_hits
-+            .init(configs.get_core_num())
-+            .name("record_write_hits")
-+            .desc("record write hit count for this core when it reaches request limit or to the end")
-+            ;
-+
-+        record_write_misses
-+            .init(configs.get_core_num())
-+            .name("record_write_misses")
-+            .desc("record write miss count for this core when it reaches request limit or to the end")
-+            ;
-+
-+        record_write_conflicts
-+            .init(configs.get_core_num())
-+            .name("record_write_conflicts")
-+            .desc("record write conflict for this core when it reaches request limit or to the end")
-+            ;
-+#endif
-+    }
-+
-+    ~Controller(){
-+        delete scheduler;
-+        delete rowpolicy;
-+        delete rowtable;
-+        delete channel;
-+        delete refresh;
-+        for (auto& file : cmd_trace_files)
-+            file.close();
-+        cmd_trace_files.clear();
-+    }
-+
-+    void finish(long read_req, long demand_read_req, long prefetch_read_req,long dram_cycles) {
-+      read_latency_avg = read_latency_sum.value() / read_req;
-+      req_queue_length_avg = req_queue_length_sum.value() / dram_cycles;
-+      read_req_queue_length_avg = read_req_queue_length_sum.value() / dram_cycles;
-+      write_req_queue_length_avg = write_req_queue_length_sum.value() / dram_cycles;
-+      // gagan : demand and prefetch reads
-+      demand_read_latency_avg = demand_read_latency_sum.value() / demand_read_req;
-+      prefetch_read_latency_avg = prefetch_read_latency_sum.value() / prefetch_read_req;
-+      // call finish function of each channel
-+      channel->finish(dram_cycles);
-+    }
-+
-+    /* Member Functions */
-+    Queue& get_queue(Request::Type type)
-+    {
-+        switch (int(type)) {
-+            case int(Request::Type::READ): return readq;
-+            case int(Request::Type::WRITE): return writeq;
-+            default: return otherq;
-+        }
-+    }
-+
-+    // gagan :
-+    bool promote(Request& req)
-+    {
-+      assert(req.type == Request::Type::READ);
-+      // promote : actq
-+      for(auto &r : actq.q)
-+	{
-+	  if(r.addr == req.addr && r.type == Request::Type::READ)
-+	    {
-+	      assert(r.is_prefetch == true);
-+	      r.is_prefetch = false;
-+	      r.arrive = clk;
-+	    }
-+	}
-+
-+      for(auto &r : readq.q)
-+	{
-+	  if(r.addr == req.addr)
-+	    {
-+	      assert(r.is_prefetch == true);
-+	      r.arrive = clk;
-+	      r.is_prefetch = false;
-+	    }
-+	}
-+
-+      return true;
-+    }
-+    
-+    bool enqueue(Request& req)
-+    {
-+        Queue& queue = get_queue(req.type);
-+        if (queue.max == queue.size())
-+            return false;
-+
-+        req.arrive = clk;
-+        queue.q.push_back(req);
-+        // shortcut for read requests, if a write to same addr exists
-+        // necessary for coherence
-+        if (req.type == Request::Type::READ && find_if(writeq.q.begin(), writeq.q.end(),
-+                [req](Request& wreq){ return req.addr == wreq.addr;}) != writeq.q.end()){
-+            req.depart = clk + 1;
-+            pending.push_back(req);
-+            readq.q.pop_back();
-+        }
-+        return true;
-+    }
-+
-+    void tick()
-+    {
-+        clk++;
-+        req_queue_length_sum += readq.size() + writeq.size() + pending.size();
-+        read_req_queue_length_sum += readq.size() + pending.size();
-+        write_req_queue_length_sum += writeq.size();
-+
-+        /*** 1. Serve completed reads ***/
-+        if (pending.size()) {
-+            Request& req = pending[0];
-+            if (req.depart <= clk) {
-+                if (req.depart - req.arrive > 1) { // this request really accessed a row
-+                  read_latency_sum += req.depart - req.arrive;
-+		  // gagan : demand and prefetch reads
-+		  if(req.is_prefetch)
-+		      prefetch_read_latency_sum += req.depart - req.arrive;
-+		  else
-+		      demand_read_latency_sum += req.depart - req.arrive;
-+                  channel->update_serving_requests(
-+                      req.addr_vec.data(), -1, clk);
-+                }
-+                req.callback(req);
-+                pending.pop_front();
-+            }
-+        }
-+
-+        /*** 2. Refresh scheduler ***/
-+        refresh->tick_ref();
-+
-+        /*** 3. Should we schedule writes? ***/
-+        if (!write_mode)
-+	  {
-+            // yes -- write queue is almost full or read queue is empty
-+            if (writeq.size() > int(wr_high_watermark * writeq.max) 
-+                    /*|| readq.size() == 0*/) // Hasan: Switching to write mode when there are just a few 
-+                                              // write requests, even if the read queue is empty, incurs a lot of overhead. 
-+                                              // Commented out the read request queue empty condition
-+	      write_mode = true;
-+        }
-+        else {
-+            // no -- write queue is almost empty and read queue is not empty
-+            if (writeq.size() < int(wr_low_watermark * writeq.max) && readq.size() != 0)
-+	      write_mode = false;
-+        }
-+
-+        /*** 4. Find the best command to schedule, if any ***/
-+
-+        // First check the actq (which has higher priority) to see if there
-+        // are requests available to service in this cycle
-+        Queue* queue = &actq;
-+
-+	if(enable_debug)
-+	  {
-+	    std::cout << "<------------------------------------------->" << std::endl;
-+	    std::cout << "Clk: " << clk << std::endl;
-+	    std::cout << "Channel: " << channel->id << std::endl;
-+	    if(actq.q.size() != 0)
-+	      {
-+		std::cout << "Activation Queue: " << std::endl;
-+		actq.print();
-+	      }
-+	    if(readq.q.size() != 0)
-+	      {
-+		std::cout << "Read Queue: " << std::endl;
-+		readq.print();
-+	      }
-+	    if(writeq.q.size() != 0)
-+	      {
-+		std::cout << "Write Queue: " << std::endl;
-+		writeq.print();
-+	      }
-+	    if(otherq.q.size() != 0)
-+	      {
-+		std::cout << "Other Queue: " << std::endl;
-+		otherq.print();
-+	      }
-+	    rowtable->print();
-+	    std::cout << "<------------------------------------------->" << std::endl;
-+	  }
-+
-+	/*
-+	std::cout << "Clk: " << clk << std::endl;
-+	std::cout << "Channel: " << channel->id << std::endl;
-+	std::cout << "Refreshing rank: " << get_refreshing_rank() << std::endl;
-+	if(otherq.q.size() != 0)
-+	  {
-+	    std::cout << "Other Queue: " << std::endl;
-+	    otherq.print();
-+	  }
-+	*/
-+	
-+
-+        auto req = scheduler->get_head(queue->q);
-+        if (req == queue->q.end() || !is_ready(req)) {
-+            queue = !write_mode ? &readq : &writeq;
-+
-+            if (otherq.size())
-+                queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-+
-+            req = scheduler->get_head(queue->q);
-+        }
-+
-+        if (req == queue->q.end() || !is_ready(req)) {
-+            // we couldn't find a command to schedule -- let's try to be speculative
-+            auto cmd = T::Command::PRE;
-+            vector<int> victim = rowpolicy->get_victim(cmd);
-+            if (!victim.empty()){
-+                issue_cmd(cmd, victim);
-+            }
-+            return;  // nothing more to be done this cycle
-+        }
-+
-+	if (req->is_first_command) {
-+            req->is_first_command = false;
-+            int coreid = req->coreid;
-+            if (req->type == Request::Type::READ || req->type == Request::Type::WRITE) {
-+              channel->update_serving_requests(req->addr_vec.data(), 1, clk);
-+            }
-+            int tx = (channel->spec->prefetch_size * channel->spec->channel_width / 8);
-+            if (req->type == Request::Type::READ) {
-+                if (is_row_hit(req)) {
-+                    ++read_row_hits[coreid];
-+                    ++row_hits;
-+                    // daz3
-+                    period_read_row_hits++;
-+                } else if (is_row_open(req)) {
-+                    ++read_row_conflicts[coreid];
-+                    ++row_conflicts;
-+                    // daz3
-+                    period_read_row_conflicts++;
-+                } else {
-+                    ++read_row_misses[coreid];
-+                    ++row_misses;
-+                    // daz3
-+                    period_read_row_misses++;
-+                }
-+              read_transaction_bytes += tx;
-+            } else if (req->type == Request::Type::WRITE) {
-+              if (is_row_hit(req)) {
-+                  ++write_row_hits[coreid];
-+                  ++row_hits;
-+                  // daz3
-+                  period_write_row_hits++;
-+              } else if (is_row_open(req)) {
-+                  ++write_row_conflicts[coreid];
-+                  ++row_conflicts;
-+                  // daz3
-+                  period_write_row_conflicts++;
-+              } else {
-+                  ++write_row_misses[coreid];
-+                  ++row_misses;
-+                  // daz3
-+                  period_write_row_misses++;
-+              }
-+              write_transaction_bytes += tx;
-+            }
-+        }
-+
-+        // issue command on behalf of request
-+	//std::cout << "Issuing command on behalf of request: ";
-+	//req->print();	  
-+        auto cmd = get_first_cmd(req);
-+        issue_cmd(cmd, get_addr_vec(cmd, req));
-+
-+        // check whether this is the last command (which finishes the request)
-+        //if (cmd != channel->spec->translate[int(req->type)]){
-+        if (!(channel->spec->is_accessing(cmd) || channel->spec->is_refreshing(cmd))) {
-+            if(channel->spec->is_opening(cmd)) {
-+                // promote the request that caused issuing activation to actq
-+                actq.q.push_back(*req);
-+                queue->q.erase(req);
-+            }
-+
-+            return;
-+        }
-+
-+        // set a future completion time for read requests
-+        if (req->type == Request::Type::READ) {
-+            req->depart = clk + channel->spec->read_latency;
-+            pending.push_back(*req);
-+        }
-+
-+        if (req->type == Request::Type::WRITE) {
-+            channel->update_serving_requests(req->addr_vec.data(), -1, clk);
-+        }
-+
-+	if(enable_debug)
-+	  {
-+	    std::cout << "Request completed: "; req->print();
-+	  }
-+
-+	/*
-+	// gagan : debug
-+	if(req->type == Request::Type::REFRESH)
-+	  {
-+	    std::cout << "Request completed: "; req->print();
-+	  }
-+	*/
-+	
-+	if(req->type == Request::Type::READ || req->type == Request::Type::WRITE)
-+	  {
-+	    int rank = req->addr_vec[1];
-+	    assert(rank != get_refreshing_rank());
-+	  }
-+        // remove request from queue
-+        queue->q.erase(req);
-+
-+        // daz3
-+        if(clk % my_print_intelval == 0)
-+        {
-+            std::cout << "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv" << std::endl;
-+            std::cout << "clk " << clk << std::endl;
-+            std::cout << "period_read_row_hits " << period_read_row_hits << std::endl;
-+            std::cout << "period_read_row_misses " << period_read_row_misses << std::endl;
-+            std::cout << "period_read_row_conflicts " << period_read_row_conflicts << std::endl;
-+            std::cout << "period_write_row_hits " << period_write_row_hits << std::endl;
-+            std::cout << "period_write_row_misses " << period_write_row_misses << std::endl;
-+            std::cout << "period_write_row_conflicts " << period_write_row_conflicts << std::endl;
-+            std::cout << "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" << std::endl;
-+        }
-+    }
-+
-+    bool is_ready(list<Request>::iterator req)
-+    {
-+        typename T::Command cmd = get_first_cmd(req);
-+        return channel->check(cmd, req->addr_vec.data(), clk);
-+    }
-+
-+    bool is_ready(typename T::Command cmd, const vector<int>& addr_vec)
-+    {
-+        return channel->check(cmd, addr_vec.data(), clk);
-+    }
-+
-+    bool is_row_hit(list<Request>::iterator req)
-+    {
-+        // cmd must be decided by the request type, not the first cmd
-+        typename T::Command cmd = channel->spec->translate[int(req->type)];
-+        return channel->check_row_hit(cmd, req->addr_vec.data());
-+    }
-+
-+    bool is_row_hit(typename T::Command cmd, const vector<int>& addr_vec)
-+    {
-+        return channel->check_row_hit(cmd, addr_vec.data());
-+    }
-+
-+    bool is_row_open(list<Request>::iterator req)
-+    {
-+        // cmd must be decided by the request type, not the first cmd
-+        typename T::Command cmd = channel->spec->translate[int(req->type)];
-+        return channel->check_row_open(cmd, req->addr_vec.data());
-+    }
-+
-+    bool is_row_open(typename T::Command cmd, const vector<int>& addr_vec)
-+    {
-+        return channel->check_row_open(cmd, addr_vec.data());
-+    }
-+
-+    void update_temp(ALDRAM::Temp current_temperature)
-+    {
-+    }
-+
-+    // For telling whether this channel is busying in processing read or write
-+    bool is_active() {
-+      return (channel->cur_serving_requests > 0);
-+    }
-+
-+    // For telling whether this channel is under refresh
-+    /*
-+    bool is_refresh() {
-+      // gagan : for all-rank refresh
-+      // return clk <= channel->end_of_refreshing;
-+      // gagan : for staggered refresh
-+      bool isAnyRankRefresh = false;
-+      for(auto rank : channel->children)
-+	{
-+	  assert(isAnyRankRefresh == false);
-+	  isAnyRankRefresh = (bool)(clk <= rank->end_of_refreshing);
-+	}
-+      return isAnyRankRefresh;
-+    }
-+    */
-+
-+    // gagan : returns which rank is refreshing, otherwise returns -1.
-+    int get_refreshing_rank()
-+    {
-+      for(auto rank : channel->children)
-+	{
-+	  if(clk <= rank->end_of_refreshing)
-+	    {
-+	      return rank->id;
-+	    }
-+	}
-+      return -1;
-+    }
-+
-+    bool no_reads_to_non_refreshing_ranks(int refreshing_rank)
-+    {
-+      auto &read_queue = readq.q;
-+      for(auto &req : read_queue)
-+	{
-+	  int rank = req.addr_vec[1];
-+	  if(rank != refreshing_rank)
-+	    return false;
-+	}
-+      return true;
-+    }
-+
-+    void set_high_writeq_watermark(const float watermark) {
-+       wr_high_watermark = watermark; 
-+    }
-+
-+    void set_low_writeq_watermark(const float watermark) {
-+       wr_low_watermark = watermark;
-+    }
-+
-+    void record_core(int coreid) {
-+#ifndef INTEGRATED_WITH_GEM5
-+      record_read_hits[coreid] = read_row_hits[coreid];
-+      record_read_misses[coreid] = read_row_misses[coreid];
-+      record_read_conflicts[coreid] = read_row_conflicts[coreid];
-+      record_write_hits[coreid] = write_row_hits[coreid];
-+      record_write_misses[coreid] = write_row_misses[coreid];
-+      record_write_conflicts[coreid] = write_row_conflicts[coreid];
-+#endif
-+    }
-+
-+private:
-+    typename T::Command get_first_cmd(list<Request>::iterator req)
-+    {
-+        typename T::Command cmd = channel->spec->translate[int(req->type)];
-+        return channel->decode(cmd, req->addr_vec.data());
-+    }
-+
-+    // upgrade to an autoprecharge command
-+    void cmd_issue_autoprecharge(typename T::Command& cmd,
-+                                            const vector<int>& addr_vec) {
-+
-+        // currently, autoprecharge is only used with closed row policy
-+        if(channel->spec->is_accessing(cmd) && rowpolicy->type == RowPolicy<T>::Type::ClosedAP) {
-+            // check if it is the last request to the opened row
-+            Queue* queue = write_mode ? &writeq : &readq;
-+
-+            auto begin = addr_vec.begin();
-+            vector<int> rowgroup(begin, begin + int(T::Level::Row) + 1);
-+
-+			int num_row_hits = 0;
-+
-+            for (auto itr = queue->q.begin(); itr != queue->q.end(); ++itr) {
-+                if (is_row_hit(itr)) { 
-+                    auto begin2 = itr->addr_vec.begin();
-+                    vector<int> rowgroup2(begin2, begin2 + int(T::Level::Row) + 1);
-+                    if(rowgroup == rowgroup2)
-+                        num_row_hits++;
-+                }
-+            }
-+
-+            if(num_row_hits == 0) {
-+                Queue* queue = &actq;
-+                for (auto itr = queue->q.begin(); itr != queue->q.end(); ++itr) {
-+                    if (is_row_hit(itr)) {
-+                        auto begin2 = itr->addr_vec.begin();
-+                        vector<int> rowgroup2(begin2, begin2 + int(T::Level::Row) + 1);
-+                        if(rowgroup == rowgroup2)
-+                            num_row_hits++;
-+                    }
-+                }
-+            }
-+
-+            assert(num_row_hits > 0); // The current request should be a hit, 
-+                                      // so there should be at least one request 
-+                                      // that hits in the current open row
-+            if(num_row_hits == 1) {
-+                if(cmd == T::Command::RD)
-+                    cmd = T::Command::RDA;
-+                else if (cmd == T::Command::WR)
-+                    cmd = T::Command::WRA;
-+                else
-+                    assert(false && "Unimplemented command type.");
-+            }
-+        }
-+
-+    }
-+
-+    void issue_cmd(typename T::Command cmd, const vector<int>& addr_vec)
-+    {
-+      	// gagan : staggered refresh
-+      /*
-+	if(channel->spec->standard_name == "DDR4" && int(cmd) == int(T::Command::REF))
-+	  {
-+	    assert(is_refresh() == false);
-+	  }
-+      */
-+      
-+        cmd_issue_autoprecharge(cmd, addr_vec);
-+        assert(is_ready(cmd, addr_vec));
-+        channel->update(cmd, addr_vec.data(), clk);
-+
-+	/*
-+	 // gagan : debug
-+	if(channel->spec->standard_name == "DDR4" && int(cmd) == int(T::Command::REF))
-+	  {
-+	    int i = 0;
-+	    for (auto child : channel->children)
-+	      {
-+		std::cout << "end_of_refreshing_rank: " << i << ", clk: " << child->end_of_refreshing << std::endl;
-+		i++;
-+	      }
-+	  }
-+	*/
-+
-+        if(cmd == T::Command::PRE){
-+            if(rowtable->get_hits(addr_vec, true) == 0){
-+                useless_activates++;
-+            }
-+        }
-+ 
-+        rowtable->update(cmd, addr_vec, clk);
-+        if (record_cmd_trace){
-+            // select rank
-+            auto& file = cmd_trace_files[addr_vec[1]];
-+            string& cmd_name = channel->spec->command_name[int(cmd)];
-+            file<<clk<<','<<cmd_name;
-+            // TODO bad coding here
-+            if (cmd_name == "PREA" || cmd_name == "REF")
-+                file<<endl;
-+            else{
-+                int bank_id = addr_vec[int(T::Level::Bank)];
-+                if (channel->spec->standard_name == "DDR4" || channel->spec->standard_name == "GDDR5")
-+                    bank_id += addr_vec[int(T::Level::Bank) - 1] * channel->spec->org_entry.count[int(T::Level::Bank)];
-+                file<<','<<bank_id<<endl;
-+            }
-+        }
-+        if (print_cmd_trace){
-+            printf("%5s %10ld:", channel->spec->command_name[int(cmd)].c_str(), clk);
-+            for (int lev = 0; lev < int(T::Level::MAX); lev++)
-+                printf(" %5d", addr_vec[lev]);
-+            printf("\n");
-+        }
-+    }
-+    vector<int> get_addr_vec(typename T::Command cmd, list<Request>::iterator req){
-+        return req->addr_vec;
-+    }
-+};
-+
-+template <>
-+vector<int> Controller<SALP>::get_addr_vec(
-+    SALP::Command cmd, list<Request>::iterator req);
-+
-+template <>
-+bool Controller<SALP>::is_ready(list<Request>::iterator req);
-+
-+template <>
-+void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature);
-+
-+template <>
-+void Controller<TLDRAM>::tick();
-+
-+template <>
-+void Controller<TLDRAM>::cmd_issue_autoprecharge(typename TLDRAM::Command& cmd,
-+                                                    const vector<int>& addr_vec);
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__CONTROLLER_H*/
-diff --git a/ext/ramulator/Ramulator/src/DDR3.cpp b/ext/ramulator/Ramulator/src/DDR3.cpp
-new file mode 100644
-index 0000000..bc3957d
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DDR3.cpp
-@@ -0,0 +1,357 @@
-+#include "DDR3.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string DDR3::standard_name = "DDR3";
-+string DDR3::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum DDR3::Org> DDR3::org_map = {
-+    {"DDR3_512Mb_x4", DDR3::Org::DDR3_512Mb_x4}, {"DDR3_512Mb_x8", DDR3::Org::DDR3_512Mb_x8}, {"DDR3_512Mb_x16", DDR3::Org::DDR3_512Mb_x16},
-+    {"DDR3_1Gb_x4", DDR3::Org::DDR3_1Gb_x4}, {"DDR3_1Gb_x8", DDR3::Org::DDR3_1Gb_x8}, {"DDR3_1Gb_x16", DDR3::Org::DDR3_1Gb_x16},
-+    {"DDR3_2Gb_x4", DDR3::Org::DDR3_2Gb_x4}, {"DDR3_2Gb_x8", DDR3::Org::DDR3_2Gb_x8}, {"DDR3_2Gb_x16", DDR3::Org::DDR3_2Gb_x16},
-+    {"DDR3_4Gb_x4", DDR3::Org::DDR3_4Gb_x4}, {"DDR3_4Gb_x8", DDR3::Org::DDR3_4Gb_x8}, {"DDR3_4Gb_x16", DDR3::Org::DDR3_4Gb_x16},
-+    {"DDR3_8Gb_x4", DDR3::Org::DDR3_8Gb_x4}, {"DDR3_8Gb_x8", DDR3::Org::DDR3_8Gb_x8}, {"DDR3_8Gb_x16", DDR3::Org::DDR3_8Gb_x16},
-+};
-+
-+map<string, enum DDR3::Speed> DDR3::speed_map = {
-+    {"DDR3_800D", DDR3::Speed::DDR3_800D}, {"DDR3_800E", DDR3::Speed::DDR3_800E},
-+    {"DDR3_1066E", DDR3::Speed::DDR3_1066E}, {"DDR3_1066F", DDR3::Speed::DDR3_1066F}, {"DDR3_1066G", DDR3::Speed::DDR3_1066G},
-+    {"DDR3_1333G", DDR3::Speed::DDR3_1333G}, {"DDR3_1333H", DDR3::Speed::DDR3_1333H},
-+    {"DDR3_1600H", DDR3::Speed::DDR3_1600H}, {"DDR3_1600J", DDR3::Speed::DDR3_1600J}, {"DDR3_1600K", DDR3::Speed::DDR3_1600K},
-+    {"DDR3_1866K", DDR3::Speed::DDR3_1866K}, {"DDR3_1866L", DDR3::Speed::DDR3_1866L},
-+    {"DDR3_2133L", DDR3::Speed::DDR3_2133L}, {"DDR3_2133M", DDR3::Speed::DDR3_2133M},
-+};
-+
-+
-+DDR3::DDR3(Org org, Speed speed) :
-+    org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+DDR3::DDR3(const string& org_str, const string& speed_str) :
-+    DDR3(org_map[org_str], speed_map[speed_str])
-+{
-+}
-+
-+void DDR3::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void DDR3::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void DDR3::init_speed()
-+{
-+    // nRRD, nFAW
-+    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-+        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-+        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-+        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-+        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-+        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-+        default: assert(false);
-+    }
-+
-+    // nRFC, nXS
-+    int chip = org_entry.size;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-+        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-+        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-+        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-+        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-+        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-+        default: assert(false);
-+    }
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-+        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-+        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-+        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-+        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-+        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-+        default: assert(false);
-+    }
-+}
-+
-+
-+void DDR3::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PREA;
-+        }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void DDR3::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void DDR3::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void DDR3::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DDR3>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DDR3>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DDR3>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR3>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR3>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DDR3>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DDR3>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DDR3>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR3>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DDR3>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR3>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DDR3>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void DDR3::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+}
-diff --git a/ext/ramulator/Ramulator/src/DDR3.h b/ext/ramulator/Ramulator/src/DDR3.h
-new file mode 100644
-index 0000000..bed966b
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DDR3.h
-@@ -0,0 +1,220 @@
-+#ifndef __DDR3_H
-+#define __DDR3_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <map>
-+#include <string>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class DDR3
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    DDR3(Org org, Speed speed);
-+    DDR3(const string& org_str, const string& speed_str);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    /*** Level ***/
-+    enum class Level : int
-+    { 
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+    
-+    /*** Command ***/
-+    enum class Command : int
-+    { 
-+        ACT, PRE, PREA, 
-+        RD,  WR,  RDA,  WRA, 
-+        REF, PDE, PDX,  SRE, SRX, 
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA", 
-+        "RD",  "WR",  "RDA",  "WRA", 
-+        "REF", "PDE", "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<DDR3>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<DDR3>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<DDR3>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<DDR3>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        DDR3_512Mb_x4, DDR3_512Mb_x8, DDR3_512Mb_x16,
-+        DDR3_1Gb_x4,   DDR3_1Gb_x8,   DDR3_1Gb_x16,
-+        DDR3_2Gb_x4,   DDR3_2Gb_x8,   DDR3_2Gb_x16,
-+        DDR3_4Gb_x4,   DDR3_4Gb_x8,   DDR3_4Gb_x16,
-+        DDR3_8Gb_x4,   DDR3_8Gb_x8,   DDR3_8Gb_x16,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-+        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-+        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-+        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-+        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        DDR3_800D,  DDR3_800E,
-+        DDR3_1066E, DDR3_1066F, DDR3_1066G,
-+        DDR3_1333G, DDR3_1333H,
-+        DDR3_1600H, DDR3_1600J, DDR3_1600K,
-+        DDR3_1866K, DDR3_1866L,
-+        DDR3_2133L, DDR3_2133M,
-+        MAX
-+    };
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRD, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL;
-+        int nCKESR, nXS, nXSDLL;
-+    } speed_table[int(Speed::MAX)] = {
-+        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-+        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512},
-+        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-+        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__DDR3_H*/
-diff --git a/ext/ramulator/Ramulator/src/DDR4.cpp b/ext/ramulator/Ramulator/src/DDR4.cpp
-new file mode 100644
-index 0000000..1fceb88
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DDR4.cpp
-@@ -0,0 +1,634 @@
-+
-+#include "DDR4.h"
-+#include "DRAM.h"
-+
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string DDR4::standard_name = "DDR4";
-+string DDR4::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-+
-+map<string, enum DDR4::Org> DDR4::org_map = {
-+    {"DDR4_2Gb_x4", DDR4::Org::DDR4_2Gb_x4}, {"DDR4_2Gb_x8", DDR4::Org::DDR4_2Gb_x8}, {"DDR4_2Gb_x16", DDR4::Org::DDR4_2Gb_x16},
-+    {"DDR4_4Gb_x4", DDR4::Org::DDR4_4Gb_x4}, {"DDR4_4Gb_x8", DDR4::Org::DDR4_4Gb_x8}, {"DDR4_4Gb_x16", DDR4::Org::DDR4_4Gb_x16},
-+    {"DDR4_8Gb_x4", DDR4::Org::DDR4_8Gb_x4}, {"DDR4_8Gb_x8", DDR4::Org::DDR4_8Gb_x8}, {"DDR4_8Gb_x16", DDR4::Org::DDR4_8Gb_x16},
-+    {"DDR4_4Gb_x8_w16", DDR4::Org::DDR4_4Gb_x8_w16}, {"DDR4_4Gb_x8_w32", DDR4::Org::DDR4_4Gb_x8_w32}, {"DDR4_4Gb_x8_w64", DDR4::Org::DDR4_4Gb_x8_w64},
-+    {"DDR4_4Gb_x8_w8", DDR4::Org::DDR4_4Gb_x8_w8},
-+    {"DDR4_4Gb_x8_4xBank", DDR4::Org::DDR4_4Gb_x8_4xBank},
-+    {"DDR4_4Gb_x8_2xBank", DDR4::Org::DDR4_4Gb_x8_2xBank}
-+};
-+
-+map<string, enum DDR4::Speed> DDR4::speed_map = {
-+    {"DDR4_1600K", DDR4::Speed::DDR4_1600K},
-+    {"DDR4_1600L", DDR4::Speed::DDR4_1600L},
-+    {"DDR4_1866M", DDR4::Speed::DDR4_1866M},
-+    {"DDR4_1866N", DDR4::Speed::DDR4_1866N},
-+    {"DDR4_2133P", DDR4::Speed::DDR4_2133P},
-+    {"DDR4_2133R", DDR4::Speed::DDR4_2133R},
-+    {"DDR4_2400R", DDR4::Speed::DDR4_2400R},
-+    // gagan
-+    {"DDR4_2400R_base", DDR4::Speed::DDR4_2400R_base},
-+    {"DDR4_2400R_ideal_nbr_lbb", DDR4::Speed::DDR4_2400R_ideal_nbr_lbb},
-+    {"DDR4_2933R_ideal_nbr_lbb_ts", DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts},
-+    {"DDR4_2933R_ideal_nbr_lbb_sts", DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts},
-+    // Ramulator
-+    {"DDR4_2400U", DDR4::Speed::DDR4_2400U},
-+    {"DDR4_3200", DDR4::Speed::DDR4_3200},
-+    // daz3
-+    {"DDR4_3200_base", DDR4::Speed::DDR4_3200_base},
-+    {"DDR4_3200_ideal_v1", DDR4::Speed::DDR4_3200_ideal_v1},
-+    {"DDR4_3200_ideal_v2", DDR4::Speed::DDR4_3200_ideal_v2},
-+    {"DDR4_3200_ideal_v2_modified", DDR4::Speed::DDR4_3200_ideal_v2_modified},
-+    {"DDR4_3200_ideal_v3", DDR4::Speed::DDR4_3200_ideal_v3},
-+    {"DDR4_3200_ideal_v4", DDR4::Speed::DDR4_3200_ideal_v4},
-+    {"DDR4_3200_ideal_v7", DDR4::Speed::DDR4_3200_ideal_v7},
-+    {"DDR4_3200_ideal_v4s", DDR4::Speed::DDR4_3200_ideal_v4s},
-+    {"DDR4_3200_ideal_v5a", DDR4::Speed::DDR4_3200_ideal_v5a},
-+    {"DDR4_3600_ideal_v4", DDR4::Speed::DDR4_3600_ideal_v4},
-+    {"DDR4_3866_ideal_v4", DDR4::Speed::DDR4_3866_ideal_v4},
-+    {"DDR4_3200_ideal_nbr_lbb", DDR4::Speed::DDR4_3200_ideal_nbr_lbb},
-+    {"DDR4_3866_ideal_nbr_lbb_ts", DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts},
-+    {"DDR4_3866_ideal_nbr_lbb_sts", DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts},
-+    {"DDR4_3200_base_half_w8", DDR4::Speed::DDR4_3200_base_half_w8},
-+    {"DDR4_3200_base_half_w16", DDR4::Speed::DDR4_3200_base_half_w16},
-+    {"DDR4_3200_base_half_w32", DDR4::Speed::DDR4_3200_base_half_w32},
-+    {"DDR4_3200_base_half_w64", DDR4::Speed::DDR4_3200_base_half_w64},
-+    {"DDR4_3200_base_full_w8", DDR4::Speed::DDR4_3200_base_full_w8},
-+    {"DDR4_3200_base_full_w16", DDR4::Speed::DDR4_3200_base_full_w16},
-+    {"DDR4_3200_base_full_w32", DDR4::Speed::DDR4_3200_base_full_w32},
-+    {"DDR4_3200_base_full_w64", DDR4::Speed::DDR4_3200_base_full_w64},
-+    {"DDR4_3200_base_quarter_w8", DDR4::Speed::DDR4_3200_base_quarter_w8},
-+    {"DDR4_3200_base_quarter_w16", DDR4::Speed::DDR4_3200_base_quarter_w16},
-+    {"DDR4_3200_base_quarter_w32", DDR4::Speed::DDR4_3200_base_quarter_w32},
-+    {"DDR4_3200_base_quarter_w64", DDR4::Speed::DDR4_3200_base_quarter_w64},
-+    {"DDR4_3734_reduced_tRCD_tRP", DDR4::Speed::DDR4_3734_reduced_tRCD_tRP},
-+    {"DDR4_2666_base", DDR4::Speed::DDR4_2666_base},
-+    {"DDR4_4000_base", DDR4::Speed::DDR4_4000_base},
-+    {"DDR4_4000_base_reduced", DDR4::Speed::DDR4_4000_base_reduced},
-+};
-+
-+
-+DDR4::DDR4(Org org, Speed speed)
-+    : org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]), 
-+    read_latency(speed_entry.nCL + speed_entry.nBL),
-+    mySpeed(speed)//daz3
-+{
-+    if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w8))
-+    {
-+        channel_width = 8;
-+    }
-+    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w16))
-+    {
-+        channel_width = 16;
-+    }
-+    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w32))
-+    {
-+        channel_width = 32;
-+    }
-+    else if(int(org) == int(DDR4::Org::DDR4_4Gb_x8_w64))
-+    {
-+        channel_width = 64;
-+    }
-+
-+    if(int(speed) == int(DDR4::Speed::DDR4_3734_reduced_tRCD_tRP)
-+            || int(speed) == int(DDR4::Speed::DDR4_4000_base_reduced))
-+    {
-+        SpeedEntry& s = speed_entry;
-+        int _RCD = s.nRCD;
-+        int _RP = s.nRP;
-+        int _REFI = s.nREFI;
-+        s.nRAS -= 0.12 * _RCD;
-+        s.nRC -= (0.12 * _RCD + 0.5 * _RP);
-+        _RCD *= 0.88;
-+        s.nRCD = _RCD;
-+        _RP *= 0.5;
-+        s.nRP = _RP;
-+        _REFI *= 4;
-+        s.nREFI = _REFI;
-+    }
-+
-+    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v4) || int(speed) == int(DDR4::Speed::DDR4_3600_ideal_v4) ||
-+       int(speed) == int(DDR4::Speed::DDR4_3866_ideal_v4) || int(speed) == int(DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts) ||
-+       int(speed) == int(DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts))
-+    {
-+        SpeedEntry& s = speed_entry;
-+        int _RCD = s.nRCD;
-+        _RCD *= 0.75;
-+        int diff_RCD = _RCD - s.nRCD;
-+        s.nRCD = _RCD;
-+        s.nRC = s.nRC + diff_RCD;
-+
-+        int _RP = s.nRP;
-+        _RP *= 0.75;
-+        int diff_RP = _RP - s.nRP;
-+        s.nRP = _RP;
-+
-+        s.nRAS = s.nRAS + diff_RCD + diff_RP;
-+
-+      /*
-+	// gagan : 
-+        SpeedEntry& s = speed_entry;
-+        int _RCD = s.nRCD;
-+        _RCD *= 0.75;
-+        int diff_RCD = _RCD - s.nRCD;
-+        s.nRCD = _RCD;
-+
-+        int _RP = s.nRP;
-+        _RP *= 0.75;
-+        int diff_RP = _RP - s.nRP;
-+        s.nRP = _RP;
-+
-+        s.nRC = s.nRC + diff_RCD + diff_RP;
-+        s.nRAS = s.nRAS + diff_RCD + diff_RP;
-+      */
-+    }
-+
-+    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v4s) || int(speed) == int(DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts) ||
-+       int(speed) == int(DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts))
-+    {
-+        SpeedEntry& s = speed_entry;
-+        int _RCD = s.nRCD;
-+        _RCD -= (_RCD - 1);
-+        int diff_RCD = _RCD - s.nRCD;
-+        s.nRCD = _RCD;
-+        s.nRC = s.nRC + diff_RCD;
-+
-+        int _RP = s.nRP;
-+        _RP -= (_RP - 1);
-+        int diff_RP = _RP - s.nRP;
-+        s.nRP = _RP;
-+
-+	s.nRAS = s.nRAS + diff_RCD + diff_RP;
-+    }
-+
-+    if(int(speed) == int(DDR4::Speed::DDR4_3200_ideal_v5a))
-+    {
-+    }
-+
-+    
-+
-+
-+    std::cout << "ramulator channel width = " << channel_width << std::endl;
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+DDR4::DDR4(const string& org_str, const string& speed_str) :
-+    DDR4(org_map[org_str], speed_map[speed_str]) 
-+{
-+}
-+
-+void DDR4::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void DDR4::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void DDR4::init_speed()
-+{
-+    const static int RRDS_TABLE[2][7] = {
-+      {4, 4, 4, 4, 4, 4, 4},
-+      {5, 5, 6, 7, 9, 10, 11}
-+    };
-+    const static int RRDL_TABLE[2][7] = {
-+        {5, 5, 6, 6, 8},
-+        {6, 6, 7, 8, 11}
-+    };
-+    const static int FAW_TABLE[3][7] = {
-+      {16, 16, 16, 16, 16, 16, 16},
-+      {20, 22, 23, 26, 34, 38, 41},
-+      {28, 28, 32, 36, 48, 54, 58}
-+    };
-+    const static int RFC_TABLE[int(RefreshMode::MAX)][3][7] = {{   
-+	{128, 150, 171, 192, 256, 288, 310},
-+	{208, 243, 278, 312, 416, 468, 503},
-+	{280, 327, 374, 420, 560, 630, 677}
-+        },{
-+	{88, 103, 118, 132,  176, 198, 213},
-+	{128, 150, 171, 192, 256, 288, 310},
-+	{208, 243, 278, 312, 416, 468, 503} 
-+        },{
-+	{72, 84, 96, 108, 144, 162, 174},
-+	{88, 103, 118, 132, 176, 198, 213},
-+	{128, 150, 171, 192, 256, 288, 310}  
-+        }
-+    };
-+    const static int REFI_TABLE[7] = {
-+      6240, 7280, 8320, 9360, 12480, 14040, 15077
-+    };
-+    const static int XS_TABLE[3][7] = {
-+      {136, 159, 182, 204, 272, 306, 329},
-+      {216, 252, 288, 324, 432, 486, 522},
-+      {288, 336, 384, 432, 576, 648, 697}
-+    };
-+
-+    int speed = 0, density = 0;
-+    switch (speed_entry.rate) {
-+        case 1600: speed = 0; break;
-+        case 1866: speed = 1; break;
-+        case 2133: speed = 2; break;
-+        case 2400: speed = 3; break;
-+        case 2933: break; // gagan
-+        case 3200: speed = 4; break;
-+        case 3600: speed = 5; break;
-+        case 3734: break;
-+        case 4000: break;
-+        case 2666: break;
-+        case 3866: speed = 6; break;
-+        case 6400: break;//daz3
-+        case 800: break;//daz3
-+        case 12800: break;
-+        case 25600: break;
-+        default: assert(false);
-+    };
-+    switch (org_entry.size >> 10){
-+        case 2: density = 0; break;
-+        case 4: density = 1; break;
-+        case 8: density = 2; break;
-+        default: assert(false);
-+    }
-+    // daz3
-+    if(mySpeed != DDR4::Speed::DDR4_3200_base 
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v1 
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v2 
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v3
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v4
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v7
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v4s
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_v5a
-+            && mySpeed != DDR4::Speed::DDR4_3600_ideal_v4
-+            && mySpeed != DDR4::Speed::DDR4_3866_ideal_v4
-+            && mySpeed != DDR4::Speed::DDR4_3200_ideal_nbr_lbb
-+            && mySpeed != DDR4::Speed::DDR4_3866_ideal_nbr_lbb_ts
-+            && mySpeed != DDR4::Speed::DDR4_3866_ideal_nbr_lbb_sts
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w8
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w16
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w32
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_half_w64
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w8
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w16
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w32
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_full_w64
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w8
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w16
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w32
-+            && mySpeed != DDR4::Speed::DDR4_3200_base_quarter_w64
-+            && mySpeed != DDR4::Speed::DDR4_3734_reduced_tRCD_tRP
-+            && mySpeed != DDR4::Speed::DDR4_2666_base
-+            && mySpeed != DDR4::Speed::DDR4_4000_base
-+            && mySpeed != DDR4::Speed::DDR4_4000_base_reduced
-+       // gagan
-+            && mySpeed != DDR4::Speed::DDR4_2400R_base
-+            && mySpeed != DDR4::Speed::DDR4_2400R_ideal_nbr_lbb
-+            && mySpeed != DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_ts
-+            && mySpeed != DDR4::Speed::DDR4_2933R_ideal_nbr_lbb_sts)
-+    {
-+        speed_entry.nRRDS = RRDS_TABLE[org_entry.dq == 16? 1: 0][speed];
-+        speed_entry.nRRDL = RRDL_TABLE[org_entry.dq == 16? 1: 0][speed];
-+        speed_entry.nFAW = FAW_TABLE[org_entry.dq == 4? 0: org_entry.dq == 8? 1: 2][speed];
-+        speed_entry.nRFC = RFC_TABLE[(int)refresh_mode][density][speed];
-+        speed_entry.nREFI = (REFI_TABLE[speed] >> int(refresh_mode));
-+        speed_entry.nXS = XS_TABLE[density][speed];
-+    }
-+    // speed_entry.nRRDS = RRDS_TABLE[org_entry.dq == 16? 1: 0][speed];
-+    // speed_entry.nRRDL = RRDL_TABLE[org_entry.dq == 16? 1: 0][speed];
-+    // speed_entry.nFAW = FAW_TABLE[org_entry.dq == 4? 0: org_entry.dq == 8? 1: 2][speed];
-+    // speed_entry.nRFC = RFC_TABLE[(int)refresh_mode][density][speed];
-+    // speed_entry.nREFI = (REFI_TABLE[speed] >> int(refresh_mode));
-+    // speed_entry.nXS = XS_TABLE[density][speed];
-+}
-+
-+
-+void DDR4::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                else return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank: bg->children) {
-+                if (bank->state == State::Closed)
-+                    continue;
-+                return Command::PREA;
-+            }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void DDR4::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void DDR4::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void DDR4::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DDR4>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DDR4>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DDR4>* node, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank : bg->children) {
-+                bank->state = State::Closed;
-+                bank->row_state.clear();
-+            }};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DDR4>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DDR4>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DDR4>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DDR4>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DDR4>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DDR4>* node, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank : bg->children) {
-+                if (bank->state == State::Closed)
-+                    continue;
-+                node->state = State::ActPowerDown;
-+                return;
-+            }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DDR4>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DDR4>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DDR4>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void DDR4::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/ 
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/ 
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+    
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDS});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::RDA)].push_back({Command::REF, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::REF, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+    
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+    
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+    /*** Bank Group ***/ 
-+    t = timing[int(Level::BankGroup)];
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDL});
-+
-+    /*** Bank ***/ 
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // daz3
-+    std::cout << "rate " << s.rate << std::endl; 
-+    std::cout << "freq " << s.freq << std::endl; 
-+    std::cout << "tCK " << s.tCK << std::endl; 
-+    std::cout << "nBL " << s.nBL << std::endl; 
-+    std::cout << "nCCDS " << s.nCCDS << std::endl; 
-+    std::cout << "nCCDL " << s.nCCDL << std::endl; 
-+    std::cout << "nRTRS " << s.nRTRS << std::endl; 
-+    std::cout << "nCL " << s.nCL << std::endl; 
-+    std::cout << "nRCD " << s.nRCD << std::endl; 
-+    std::cout << "nRP " << s.nRP << std::endl; 
-+    std::cout << "nCWL " << s.nCWL << std::endl; 
-+    std::cout << "nRAS " << s.nRAS << std::endl; 
-+    std::cout << "nRC " << s.nRC << std::endl; 
-+    std::cout << "nRTP " << s.nRTP << std::endl; 
-+    std::cout << "nWTRS " << s.nWTRS << std::endl; 
-+    std::cout << "nWTRL " << s.nWTRL << std::endl; 
-+    std::cout << "nWR " << s.nWR << std::endl; 
-+    std::cout << "nRRDS " << s.nRRDS << std::endl; 
-+    std::cout << "nRRDL " << s.nRRDL << std::endl; 
-+    std::cout << "nFAW " << s.nFAW << std::endl; 
-+    std::cout << "nRFC " << s.nRFC << std::endl; 
-+    std::cout << "nREFI " << s.nREFI << std::endl; 
-+    std::cout << "nPD " << s.nPD << std::endl; 
-+    std::cout << "nXP " << s.nXP << std::endl; 
-+    std::cout << "nXPDLL " << s.nXPDLL << std::endl; 
-+    std::cout << "nCKESR " << s.nCKESR << std::endl; 
-+    std::cout << "nXS " << s.nXS << std::endl; 
-+    std::cout << "nXSDLL " << s.nXSDLL << std::endl; 
-+    std::cout << "nRCD " << s.nRCD << std::endl; 
-+    std::cout << "nRC " << s.nRC << std::endl; 
-+    std::cout << "nRP " << s.nRP << std::endl; 
-+    std::cout << "channel_id " << org_entry.count[int(Level::Channel)] << std::endl; 
-+    std::cout << "ranks " << org_entry.count[int(Level::Rank)] << std::endl; 
-+}
-diff --git a/ext/ramulator/Ramulator/src/DDR4.h b/ext/ramulator/Ramulator/src/DDR4.h
-new file mode 100644
-index 0000000..612e1f2
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DDR4.h
-@@ -0,0 +1,311 @@
-+#ifndef __DDR4_H
-+#define __DDR4_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class DDR4
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    DDR4(Org org, Speed speed);
-+    DDR4(const string& org_str, const string& speed_str);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    /* Level */
-+    enum class Level : int
-+    { 
-+        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /* Command */
-+    enum class Command : int
-+    { 
-+        ACT, PRE, PREA, 
-+        RD,  WR,  RDA,  WRA, 
-+        REF, PDE, PDX,  SRE, SRX, 
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA", 
-+        "RD",  "WR",  "RDA",  "WRA", 
-+        "REF", "PDE", "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prereq */
-+    function<Command(DRAM<DDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<DDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<DDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<DDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        DDR4_2Gb_x4,   DDR4_2Gb_x8,   DDR4_2Gb_x16,
-+        DDR4_4Gb_x4,   DDR4_4Gb_x8,   DDR4_4Gb_x16,
-+        DDR4_8Gb_x4,   DDR4_8Gb_x8,   DDR4_8Gb_x16,
-+        DDR4_4Gb_x8_w16, DDR4_4Gb_x8_w32, DDR4_4Gb_x8_w64,
-+        DDR4_4Gb_x8_w8,
-+        DDR4_4Gb_x8_4xBank,
-+        DDR4_4Gb_x8_2xBank,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {2<<10,  4, {0, 0, 4, 4, 1<<15, 1<<10}}, {2<<10,  8, {0, 0, 4, 4, 1<<14, 1<<10}}, {2<<10, 16, {0, 0, 2, 4, 1<<14, 1<<10}},
-+        {4<<10,  4, {0, 0, 4, 4, 1<<16, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10, 16, {0, 0, 2, 4, 1<<15, 1<<10}},
-+        {8<<10,  4, {0, 0, 4, 4, 1<<17, 1<<10}}, {8<<10,  8, {0, 0, 4, 4, 1<<16, 1<<10}}, {8<<10, 16, {0, 0, 2, 4, 1<<16, 1<<10}},
-+        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//16,32,64B cacheline
-+        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//8B cacheline
-+        {4<<10,  8, {0, 0, 4, 16, 1<<15, 1<<10}},
-+        {4<<10,  8, {0, 0, 4, 8, 1<<15, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        DDR4_1600K,
-+	DDR4_1600L,
-+        DDR4_1866M,
-+	DDR4_1866N,
-+        DDR4_2133P,
-+	DDR4_2133R,
-+        DDR4_2400R,
-+        // gagan
-+        DDR4_2400R_base,
-+	DDR4_2400R_ideal_nbr_lbb,
-+	DDR4_2933R_ideal_nbr_lbb_ts,
-+	DDR4_2933R_ideal_nbr_lbb_sts,
-+        // Ramulator
-+	DDR4_2400U,
-+        DDR4_3200,
-+        // daz3
-+        DDR4_3200_base,
-+        DDR4_3200_ideal_v1,// tRFC=0
-+        DDR4_3200_ideal_v2,// tRFC=0,tWTR_*=0
-+        DDR4_3200_ideal_v2_modified,// tRFC=0,tWTR_*=0
-+        DDR4_3200_ideal_v3,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0
-+        DDR4_3200_ideal_v4,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0,tRDC*75%,tRP*75%
-+        DDR4_3200_ideal_v7,// tRFC=0
-+	DDR4_3200_ideal_v4s,
-+	DDR4_3200_ideal_v5a,
-+	DDR4_3600_ideal_v4,
-+	DDR4_3866_ideal_v4,
-+	DDR4_3200_ideal_nbr_lbb, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0
-+	DDR4_3866_ideal_nbr_lbb_ts, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0,tRDC*=75%,tRP*=75%
-+	DDR4_3866_ideal_nbr_lbb_sts, // tRFC=0,tWTR_=0,tWR=0,tRRD_=0,tFAW_=0,tRDC=1,tRP=1
-+        DDR4_3200_base_half_w8,// for different cacheline size
-+        DDR4_3200_base_half_w16,// for different cacheline size
-+        DDR4_3200_base_half_w32,
-+        DDR4_3200_base_half_w64,
-+        DDR4_3200_base_full_w8,// for different cacheline size
-+        DDR4_3200_base_full_w16,// for different cacheline size
-+        DDR4_3200_base_full_w32,
-+        DDR4_3200_base_full_w64,
-+        DDR4_3200_base_quarter_w8,// for different cacheline size
-+        DDR4_3200_base_quarter_w16,// for different cacheline size
-+        DDR4_3200_base_quarter_w32,
-+        DDR4_3200_base_quarter_w64,
-+        DDR4_3734_reduced_tRCD_tRP,
-+        DDR4_2666_base,
-+        DDR4_4000_base,
-+        DDR4_4000_base_reduced,
-+        MAX
-+    }mySpeed;
-+    // };
-+
-+    enum class RefreshMode : int
-+    {
-+        Refresh_1X,
-+        Refresh_2X,
-+        Refresh_4X,
-+        MAX
-+    } refresh_mode = RefreshMode::Refresh_1X;
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCDS, nCCDL, nRTRS;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTRS, nWTRL, nWR;
-+        int nRRDS, nRRDL, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL; // XPDLL not found in DDR4??
-+        int nCKESR, nXS, nXSDLL; // nXSDLL TBD (nDLLK), nXS = (tRFC+10ns)/tCK
-+    } speed_table[int(Speed::MAX)] = {
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 11, 11, 11,  9, 28, 39, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 12, 12, 12,  9, 28, 40, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 13, 13, 13, 10, 32, 45, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 14, 14, 14, 10, 32, 46, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 15, 15, 15, 11, 36, 51, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 16, 16, 16, 11, 36, 52, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-+        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 16, 16, 16, 12, 39, 55, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-+	// gagan
-+        {2400, 1200,   0.833, prefetch_size/2/*DDR*/,   4,    6,    2, 16, 16,  16, 12,  39, 55,   9,    3,     9,  18,   4,   6,   26, 660,  9360,    6,    8,    0,   7,   672,  768},
-+        {2400, 1200,   0.833, prefetch_size/2/*DDR*/,   4,    6,    2, 16, 16,  16, 12,  39, 55,   9,    0,     0,   0,   0,   0,    0,   0,  9360,    6,    8,    0,   7,   672,  768},
-+	{2933, 2933/2, 0.681, prefetch_size/2/*DDR*/,   4,    7,    2, 16, 20,  20, 15,  47, 67,  11,    0,     0,   0,   0,   0,    0,   0, 11439,    7,   10,    0,   9,   821,  939},
-+	{2933, 2933/2, 0.681, prefetch_size/2/*DDR*/,   4,    7,    2, 16, 20,  20, 15,  47, 67,  11,    0,     0,   0,   0,   0,    0,   0, 11439,    7,   10,    0,   9,   821,  939},
-+	//rate, freq,    tCK,             nBL,       nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC  nREFI   nPD   nXP  nXPDLL nCKESR nXS  nXSDLL
-+	// Ramulator
-+        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 18, 18, 18, 12, 39, 57, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,     10,   2,    22, 22,  22, 16,  56,  78, 12,  4,    12,   24, 8,    10,   40,  0,   0,    8,  10, 0,     8,     0,  0},
-+        // daz3
-+        // {3200, 1600, 0.625, prefetch_size/2[>DDR<], 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  480, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,  480, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   48,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+	{3600, 1800, 0.555, prefetch_size/2/*DDR*/, 4,      9,   2,    25, 25,  25, 22,  57,  82, 13,  0,     0,   27, 0,     0,    0,    0, 14040,   9,   11,  0,   10, 1008, 1152},
-+	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,   29, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-+	{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,    0, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,    0, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-+	{3866, 1933, 0.517, prefetch_size/2/*DDR*/, 4,     10,   2,    27, 27,  27, 24,  61,  88, 14,  0,     0,    0, 0,     0,    0,    0, 15077,  10,   12,  0,   11, 1083, 1237},
-+	//{3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22,  0,   0, 20,  10,  32, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+	//rate, freq, tCK,  nBL,                    nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI   nPD   nXP  nXPDLL nCKESR nXS  nXSDLL
-+
-+        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-+        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-+
-+        {25600, 12800, 0.078125, prefetch_size*2/*DDR*/, 32,      64,   16,    176, 176,  176, 160, 416,  592, 96,  0,     0,   192, 0,     0,    0,    0, 99840,   64,   80,  0,   72,   7168, 8192},
-+        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-+        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+
-+        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-+        {800, 400, 2.5, prefetch_size/8/*DDR*/, 1,      2,   1,    6, 6,  6, 5,  13,  14, 3,  0,     0,   6, 0,     0,    0,    0, 3120,   2,   3,  0,   3,   224, 256},
-+        //rate, freq, tCK,  nBL, nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-+        // rate, freq, tCK,  nBL,                  nCCDS  nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL 480 nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-+        {3734, 1867, 0.537, prefetch_size/2/*DDR*/, 4,      10,   3,    26, 26,  26, 24,  61,  87, 14,  5,    14,   28, 5,     10,   40,   560, 14563,   12,   12,  0,   11,   1046, 1195},
-+        {2666, 1333, 0.75, prefetch_size/2/*DDR*/, 4,        7,   2,    19, 19,  19, 17,  44,  62, 10,  4,    10,   20, 4,     7,    29,   734, 10400,   7,   9,   0,   8,   747, 854},
-+        {4000, 2000, 0.5, prefetch_size/2/*DDR*/,  4,       10,   2,    27, 27,  27, 25,  65,  92, 15,  4,    15,   30,  4,    10,   42,   600, 15600,   8,   12,  0,   11,   1120, 1280},
-+        {4000, 2000, 0.5, prefetch_size/2/*DDR*/,  4,       10,   2,    27, 27,  27, 25,  65,  92, 15,  4,    15,   30, 4,     10,   42,   600, 15600,   0,    0,  0,    0,      0,    0}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__DDR4_H*/
-diff --git a/ext/ramulator/Ramulator/src/DDR4.h.backup b/ext/ramulator/Ramulator/src/DDR4.h.backup
-new file mode 100644
-index 0000000..02ad585
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DDR4.h.backup
-@@ -0,0 +1,267 @@
-+#ifndef __DDR4_H
-+#define __DDR4_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class DDR4
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    DDR4(Org org, Speed speed);
-+    DDR4(const string& org_str, const string& speed_str);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    /* Level */
-+    enum class Level : int
-+    { 
-+        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /* Command */
-+    enum class Command : int
-+    { 
-+        ACT, PRE, PREA, 
-+        RD,  WR,  RDA,  WRA, 
-+        REF, PDE, PDX,  SRE, SRX, 
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA", 
-+        "RD",  "WR",  "RDA",  "WRA", 
-+        "REF", "PDE", "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prereq */
-+    function<Command(DRAM<DDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<DDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<DDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<DDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        DDR4_2Gb_x4,   DDR4_2Gb_x8,   DDR4_2Gb_x16,
-+        DDR4_4Gb_x4,   DDR4_4Gb_x8,   DDR4_4Gb_x16,
-+        DDR4_8Gb_x4,   DDR4_8Gb_x8,   DDR4_8Gb_x16,
-+        DDR4_4Gb_x8_w16, DDR4_4Gb_x8_w32, DDR4_4Gb_x8_w64,
-+        DDR4_4Gb_x8_w8,
-+        DDR4_4Gb_x8_4xBank,
-+        DDR4_4Gb_x8_2xBank,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {2<<10,  4, {0, 0, 4, 4, 1<<15, 1<<10}}, {2<<10,  8, {0, 0, 4, 4, 1<<14, 1<<10}}, {2<<10, 16, {0, 0, 2, 4, 1<<14, 1<<10}},
-+        {4<<10,  4, {0, 0, 4, 4, 1<<16, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10, 16, {0, 0, 2, 4, 1<<15, 1<<10}},
-+        {8<<10,  4, {0, 0, 4, 4, 1<<17, 1<<10}}, {8<<10,  8, {0, 0, 4, 4, 1<<16, 1<<10}}, {8<<10, 16, {0, 0, 2, 4, 1<<16, 1<<10}},
-+        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}}, {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//16,32,64B cacheline
-+        {4<<10,  8, {0, 0, 4, 4, 1<<15, 1<<10}},//8B cacheline
-+        {4<<10,  8, {0, 0, 4, 16, 1<<15, 1<<10}},
-+        {4<<10,  8, {0, 0, 4, 8, 1<<15, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        DDR4_1600K, DDR4_1600L,
-+        DDR4_1866M, DDR4_1866N,
-+        DDR4_2133P, DDR4_2133R,
-+        DDR4_2400R, DDR4_2400U,
-+        DDR4_3200,
-+        // daz3
-+        DDR4_3200_base,
-+        DDR4_3200_ideal_v1,// tRFC=0
-+        DDR4_3200_ideal_v2,// tRFC=0,tWTR_*=0
-+        DDR4_3200_ideal_v2_modified,// tRFC=0,tWTR_*=0
-+        DDR4_3200_ideal_v3,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0
-+        DDR4_3200_ideal_v4,// tRFC=0,tWTR_*=0,tRRD_*=0,tFAW_*=0,tRDC*75%,tRP*75%
-+        DDR4_3200_base_half_w8,// for different cacheline size
-+        DDR4_3200_base_half_w16,// for different cacheline size
-+        DDR4_3200_base_half_w32,
-+        DDR4_3200_base_half_w64,
-+        DDR4_3200_base_full_w8,// for different cacheline size
-+        DDR4_3200_base_full_w16,// for different cacheline size
-+        DDR4_3200_base_full_w32,
-+        DDR4_3200_base_full_w64,
-+        DDR4_3200_base_quarter_w8,// for different cacheline size
-+        DDR4_3200_base_quarter_w16,// for different cacheline size
-+        DDR4_3200_base_quarter_w32,
-+        DDR4_3200_base_quarter_w64,
-+        MAX
-+    }mySpeed;
-+    // };
-+
-+    enum class RefreshMode : int
-+    {
-+        Refresh_1X,
-+        Refresh_2X,
-+        Refresh_4X,
-+        MAX
-+    } refresh_mode = RefreshMode::Refresh_1X;
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCDS, nCCDL, nRTRS;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTRS, nWTRL, nWR;
-+        int nRRDS, nRRDL, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL; // XPDLL not found in DDR4??
-+        int nCKESR, nXS, nXSDLL; // nXSDLL TBD (nDLLK), nXS = (tRFC+10ns)/tCK
-+    } speed_table[int(Speed::MAX)] = {
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 11, 11, 11,  9, 28, 39, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 5, 2, 12, 12, 12,  9, 28, 40, 6, 2, 6, 12, 0, 0, 0, 0, 0, 4, 5, 0, 5, 0, 0},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 13, 13, 13, 10, 32, 45, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 5, 2, 14, 14, 14, 10, 32, 46, 7, 3, 7, 14, 0, 0, 0, 0, 0, 5, 6, 0, 6, 0, 0},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 15, 15, 15, 11, 36, 51, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 6, 2, 16, 16, 16, 11, 36, 52, 8, 3, 8, 16, 0, 0, 0, 0, 0, 6, 7, 0, 7, 0, 0},
-+        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 16, 16, 16, 12, 39, 55, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-+        {2400, (400.0/3)*9, (3/0.4)/9, 4, 4, 6, 2, 18, 18, 18, 12, 39, 57, 9, 3, 9, 18, 0, 0, 0, 0, 0, 6, 8, 0, 7, 0, 0},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,     10,   2,    22, 22,  22, 16,  56,  78, 12,  4,    12,   24, 8,    10,   40,  0,   0,    8,  10, 0,     8,     0,  0},
-+        // daz3
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   34,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 4,     8,   48,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  0,     0,   24, 0,     0,    0,    0, 12480,   8,   10,  0,   9,   896, 1024},
-+
-+        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-+        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-+
-+        {25600, 12800, 0.078125, prefetch_size*2/*DDR*/, 32,      64,   16,    176, 176,  176, 160, 416,  592, 96,  0,     0,   192, 0,     0,    0,    0, 99840,   64,   80,  0,   72,   7168, 8192},
-+        {12800, 6400, 0.15625, prefetch_size*2/*DDR*/, 16,      32,   8,    88, 88,  88, 80, 208,  296, 48,  0,     0,   96, 0,     0,    0,    0, 49920,   32,   40,  0,   36,   3584, 4096},
-+        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+
-+        {6400, 3200, 0.3125, prefetch_size/*DDR*/, 8,      16,   4,    44, 44,  44, 40,  104,  148, 24,  0,     0,   48, 0,     0,    0,    0, 24960,   16,   20,  0,   18,   1792, 2048},
-+        {3200, 1600, 0.625, prefetch_size/2/*DDR*/, 4,      8,   2,    22, 22,  22, 20,  52,  74, 12,  4,    12,   24, 4,     8,   34,  880, 12480,   8,   10,  0,   9,   896, 1024},
-+        {1600, 800, 1.25, prefetch_size/4/*DDR*/, 2,      4,   1,    11, 11,  11, 10,  26,  37, 6,  0,     0,   12, 0,     0,    0,    0, 6240,   4,   5,  0,   5,   448, 512},
-+        {800, 400, 2.5, prefetch_size/8/*DDR*/, 1,      2,   1,    6, 6,  6, 5,  13,  14, 3,  0,     0,   6, 0,     0,    0,    0, 3120,   2,   3,  0,   3,   224, 256}
-+        //rate, f eq, tCK,  nBL, nCCDS nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-+        // //rate, freq, tCK,  nBL,           nCCDS  nCCDL nRTRS nCL nRCD nRP nCWL nRAS nRC nRTP nWTRS nWTRL nWR nRRDS nRRDL nFAW nRFC nREFI nPD nXP nXPDLL nCKESR nXS nXSDLL
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__DDR4_H*/
-diff --git a/ext/ramulator/Ramulator/src/DRAM.h b/ext/ramulator/Ramulator/src/DRAM.h
-new file mode 100644
-index 0000000..1456b4b
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DRAM.h
-@@ -0,0 +1,451 @@
-+#ifndef __DRAM_H
-+#define __DRAM_H
-+
-+#include "Statistics.h"
-+#include <iostream>
-+#include <vector>
-+#include <deque>
-+#include <map>
-+#include <functional>
-+#include <algorithm>
-+#include <cassert>
-+#include <type_traits>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+template <typename T>
-+class DRAM
-+{
-+public:
-+    ScalarStat active_cycles;
-+    ScalarStat refresh_cycles;
-+    ScalarStat busy_cycles;
-+    ScalarStat active_refresh_overlap_cycles;
-+
-+    ScalarStat serving_requests;
-+    ScalarStat average_serving_requests;
-+
-+    // Constructor
-+    DRAM(T* spec, typename T::Level level);
-+    ~DRAM();
-+
-+    // Specification (e.g., DDR3)
-+    T* spec;
-+
-+    // Tree Organization (e.g., Channel->Rank->Bank->Row->Column)
-+    typename T::Level level;
-+    int id;
-+    long size;
-+    DRAM* parent;
-+    vector<DRAM*> children;
-+
-+    // State (e.g., Opened, Closed)
-+    typename T::State state;
-+
-+    // State of Rows:
-+    // There are too many rows for them to be instantiated individually
-+    // Instead, their bank (or an equivalent entity) tracks their state for them
-+    map<int, typename T::State> row_state;
-+
-+    // Insert a node as one of my child nodes
-+    void insert(DRAM<T>* child);
-+
-+    // Decode a command into its "prerequisite" command (if any is needed)
-+    typename T::Command decode(typename T::Command cmd, const int* addr);
-+
-+    // Check whether a command is ready to be scheduled
-+    bool check(typename T::Command cmd, const int* addr, long clk);
-+
-+    // Check whether a command is a row hit
-+    bool check_row_hit(typename T::Command cmd, const int* addr);
-+
-+    // Check whether a row is open
-+    bool check_row_open(typename T::Command cmd, const int* addr);
-+
-+    // Return the earliest clock when a command is ready to be scheduled
-+    long get_next(typename T::Command cmd, const int* addr);
-+
-+    // Update the timing/state of the tree, signifying that a command has been issued
-+    void update(typename T::Command cmd, const int* addr, long clk);
-+    // Update statistics:
-+
-+    // Update the number of requests it serves currently
-+    void update_serving_requests(const int* addr, int delta, long clk);
-+
-+    // TIANSHI: current serving requests count
-+    int cur_serving_requests = 0;
-+    long begin_of_serving = -1;
-+    long end_of_serving = -1;
-+    long begin_of_cur_reqcnt = -1;
-+    long begin_of_refreshing = -1;
-+    long end_of_refreshing = -1;
-+    std::vector<std::pair<long, long>> refresh_intervals;
-+
-+    // register statistics
-+    void regStats(const std::string& identifier);
-+
-+    void finish(long dram_cycles);
-+
-+private:
-+    // Constructor
-+    DRAM(){}
-+
-+    // Timing
-+    long cur_clk = 0;
-+    long next[int(T::Command::MAX)]; // the earliest time in the future when a command could be ready
-+    deque<long> prev[int(T::Command::MAX)]; // the most recent history of when commands were issued
-+
-+    // Lookup table for which commands must be preceded by which other commands (i.e., "prerequisite")
-+    // E.g., a read command to a closed bank must be preceded by an activate command
-+    function<typename T::Command(DRAM<T>*, typename T::Command cmd, int)>* prereq;
-+
-+    // SAUGATA: added table for row hits
-+    // Lookup table for whether a command is a row hit
-+    // E.g., a read command to a closed bank must be preceded by an activate command
-+    function<bool(DRAM<T>*, typename T::Command cmd, int)>* rowhit;
-+    function<bool(DRAM<T>*, typename T::Command cmd, int)>* rowopen;
-+
-+    // Lookup table between commands and the state transitions they trigger
-+    // E.g., an activate command to a closed bank opens both the bank and the row
-+    function<void(DRAM<T>*, int)>* lambda;
-+
-+    // Lookup table for timing parameters
-+    // E.g., activate->precharge: tRAS@bank, activate->activate: tRC@bank
-+    vector<typename T::TimingEntry>* timing;
-+
-+    // Helper Functions
-+    void update_state(typename T::Command cmd, const int* addr);
-+    void update_timing(typename T::Command cmd, const int* addr, long clk);
-+}; /* class DRAM */
-+
-+
-+// register statistics
-+template <typename T>
-+void DRAM<T>::regStats(const std::string& identifier) {
-+    active_cycles
-+        .name("active_cycles" + identifier + "_" + to_string(id))
-+        .desc("Total active cycles for level " + identifier + "_" + to_string(id))
-+        .precision(0)
-+        ;
-+    refresh_cycles
-+        .name("refresh_cycles" + identifier + "_" + to_string(id))
-+        .desc("(All-bank refresh only, only valid for rank level) The sum of cycles that is under refresh per memory cycle for level " + identifier + "_" + to_string(id))
-+        .precision(0)
-+        .flags(Stats::nozero)
-+        ;
-+    busy_cycles
-+        .name("busy_cycles" + identifier + "_" + to_string(id))
-+        .desc("(All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level " + identifier + "_" + to_string(id))
-+        .precision(0)
-+        ;
-+    active_refresh_overlap_cycles
-+        .name("active_refresh_overlap_cycles" + identifier + "_" + to_string(id))
-+        .desc("(All-bank refresh only, only valid for rank level) The sum of cycles that are both active and under refresh per memory cycle for level " + identifier + "_" + to_string(id))
-+        .precision(0)
-+        .flags(Stats::nozero)
-+        ;
-+    serving_requests
-+        .name("serving_requests" + identifier + "_" + to_string(id))
-+        .desc("The sum of read and write requests that are served in this DRAM element per memory cycle for level " + identifier + "_" + to_string(id))
-+        .precision(0)
-+        ;
-+    average_serving_requests
-+        .name("average_serving_requests" + identifier + "_" + to_string(id))
-+        .desc("The average of read and write requests that are served in this DRAM element per memory cycle for level " + identifier + "_" + to_string(id))
-+        .precision(6)
-+        ;
-+
-+    if (!children.size()) {
-+      return;
-+    }
-+
-+    // recursively register children statistics
-+    for (auto child : children) {
-+      child->regStats(identifier + "_" + to_string(id));
-+    }
-+}
-+
-+template <typename T>
-+void DRAM<T>::finish(long dram_cycles) {
-+  // finalize busy cycles
-+  busy_cycles = active_cycles.value() + refresh_cycles.value() - active_refresh_overlap_cycles.value();
-+
-+  // finalize average serving requests
-+  average_serving_requests = serving_requests.value() / dram_cycles;
-+
-+  if (!children.size()) {
-+    return;
-+  }
-+
-+  for (auto child : children) {
-+    child->finish(dram_cycles);
-+  }
-+}
-+
-+// Constructor
-+template <typename T>
-+DRAM<T>::DRAM(T* spec, typename T::Level level) :
-+    spec(spec), level(level), id(0), parent(NULL)
-+{
-+
-+    state = spec->start[(int)level];
-+    prereq = spec->prereq[int(level)];
-+    rowhit = spec->rowhit[int(level)];
-+    rowopen = spec->rowopen[int(level)];
-+    lambda = spec->lambda[int(level)];
-+    timing = spec->timing[int(level)];
-+
-+    fill_n(next, int(T::Command::MAX), -1); // initialize future
-+    for (int cmd = 0; cmd < int(T::Command::MAX); cmd++) {
-+        int dist = 0;
-+        for (auto& t : timing[cmd])
-+            dist = max(dist, t.dist);
-+
-+        if (dist)
-+            prev[cmd].resize(dist, -1); // initialize history
-+    }
-+
-+    // try to recursively construct my children
-+    int child_level = int(level) + 1;
-+    if (child_level == int(T::Level::Row))
-+        return; // stop recursion: rows are not instantiated as nodes
-+
-+    int child_max = spec->org_entry.count[child_level];
-+    if (!child_max)
-+        return; // stop recursion: the number of children is unspecified
-+
-+    // recursively construct my children
-+    for (int i = 0; i < child_max; i++) {
-+        DRAM<T>* child = new DRAM<T>(spec, typename T::Level(child_level));
-+        child->parent = this;
-+        child->id = i;
-+        children.push_back(child);
-+    }
-+
-+}
-+
-+template <typename T>
-+DRAM<T>::~DRAM()
-+{
-+    for (auto child: children)
-+        delete child;
-+}
-+
-+// Insert
-+template <typename T>
-+void DRAM<T>::insert(DRAM<T>* child)
-+{
-+    child->parent = this;
-+    child->id = children.size();
-+    children.push_back(child);
-+}
-+
-+// Decode
-+template <typename T>
-+typename T::Command DRAM<T>::decode(typename T::Command cmd, const int* addr)
-+{
-+    int child_id = addr[int(level)+1];
-+    if (prereq[int(cmd)]) {
-+        typename T::Command prereq_cmd = prereq[int(cmd)](this, cmd, child_id);
-+        if (prereq_cmd != T::Command::MAX)
-+            return prereq_cmd; // stop recursion: there is a prerequisite at this level
-+    }
-+
-+    if (child_id < 0 || !children.size())
-+        return cmd; // stop recursion: there were no prequisites at any level
-+
-+    // recursively decode at my child
-+    return children[child_id]->decode(cmd, addr);
-+}
-+
-+
-+// Check
-+template <typename T>
-+bool DRAM<T>::check(typename T::Command cmd, const int* addr, long clk)
-+{
-+    if (next[int(cmd)] != -1 && clk < next[int(cmd)])
-+        return false; // stop recursion: the check failed at this level
-+
-+    int child_id = addr[int(level)+1];
-+    if (child_id < 0 || level == spec->scope[int(cmd)] || !children.size())
-+        return true; // stop recursion: the check passed at all levels
-+
-+    // recursively check my child
-+    return children[child_id]->check(cmd, addr, clk);
-+}
-+
-+// SAUGATA: added function to check whether a command is a row hit
-+// Check row hits
-+template <typename T>
-+bool DRAM<T>::check_row_hit(typename T::Command cmd, const int* addr)
-+{
-+    int child_id = addr[int(level)+1];
-+    if (rowhit[int(cmd)]) {
-+        return rowhit[int(cmd)](this, cmd, child_id);  // stop recursion: there is a row hit at this level
-+    }
-+
-+    if (child_id < 0 || !children.size())
-+        return false; // stop recursion: there were no row hits at any level
-+
-+    // recursively check for row hits at my child
-+    return children[child_id]->check_row_hit(cmd, addr);
-+}
-+
-+template <typename T>
-+bool DRAM<T>::check_row_open(typename T::Command cmd, const int* addr)
-+{
-+    int child_id = addr[int(level)+1];
-+    if (rowopen[int(cmd)]) {
-+        return rowopen[int(cmd)](this, cmd, child_id);  // stop recursion: there is a row hit at this level
-+    }
-+
-+    if (child_id < 0 || !children.size())
-+        return false; // stop recursion: there were no row hits at any level
-+
-+    // recursively check for row hits at my child
-+    return children[child_id]->check_row_open(cmd, addr);
-+}
-+
-+template <typename T>
-+long DRAM<T>::get_next(typename T::Command cmd, const int* addr)
-+{
-+    long next_clk = max(cur_clk, next[int(cmd)]);
-+    auto node = this;
-+    for (int l = int(level); l < int(spec->scope[int(cmd)]) && node->children.size() && addr[l + 1] >= 0; l++){
-+        node = node->children[addr[l + 1]];
-+        next_clk = max(next_clk, node->next[int(cmd)]);
-+    }
-+    return next_clk;
-+}
-+
-+// Update
-+template <typename T>
-+void DRAM<T>::update(typename T::Command cmd, const int* addr, long clk)
-+{
-+    cur_clk = clk;
-+    update_state(cmd, addr);
-+    update_timing(cmd, addr, clk);
-+}
-+
-+
-+// Update (State)
-+template <typename T>
-+void DRAM<T>::update_state(typename T::Command cmd, const int* addr)
-+{
-+    int child_id = addr[int(level)+1];
-+    if (lambda[int(cmd)])
-+        lambda[int(cmd)](this, child_id); // update this level
-+
-+    if (level == spec->scope[int(cmd)] || !children.size())
-+        return; // stop recursion: updated all levels
-+
-+    // recursively update my child
-+    children[child_id]->update_state(cmd, addr);
-+}
-+
-+
-+// Update (Timing)
-+template <typename T>
-+void DRAM<T>::update_timing(typename T::Command cmd, const int* addr, long clk)
-+{
-+    // I am not a target node: I am merely one of its siblings
-+    if (id != addr[int(level)]) {
-+        for (auto& t : timing[int(cmd)]) {
-+            if (!t.sibling)
-+                continue; // not an applicable timing parameter
-+
-+            assert (t.dist == 1);
-+
-+            long future = clk + t.val;
-+            next[int(t.cmd)] = max(next[int(t.cmd)], future); // update future
-+        }
-+
-+        return; // stop recursion: only target nodes should be recursed
-+    }
-+
-+    // I am a target node
-+    if (prev[int(cmd)].size()) {
-+        prev[int(cmd)].pop_back();  // FIXME TIANSHI why pop back?
-+        prev[int(cmd)].push_front(clk); // update history
-+    }
-+
-+    for (auto& t : timing[int(cmd)]) {
-+        if (t.sibling)
-+            continue; // not an applicable timing parameter
-+
-+        long past = prev[int(cmd)][t.dist-1];
-+        if (past < 0)
-+            continue; // not enough history
-+
-+        long future = past + t.val;
-+        next[int(t.cmd)] = max(next[int(t.cmd)], future); // update future
-+        // TIANSHI: for refresh statistics
-+        if (spec->is_refreshing(cmd) && spec->is_opening(t.cmd)) {
-+          assert(past == clk);
-+          begin_of_refreshing = clk;
-+          end_of_refreshing = max(end_of_refreshing, next[int(t.cmd)]);
-+          refresh_cycles += end_of_refreshing - clk;
-+          if (cur_serving_requests > 0) {
-+            refresh_intervals.push_back(make_pair(begin_of_refreshing, end_of_refreshing));
-+          }
-+        }
-+    }
-+
-+    // Some commands have timings that are higher that their scope levels, thus
-+    // we do not stop at the cmd's scope level
-+    if (!children.size())
-+        return; // stop recursion: updated all levels
-+
-+    // recursively update *all* of my children
-+    for (auto child : children)
-+        child->update_timing(cmd, addr, clk);
-+
-+}
-+
-+template <typename T>
-+void DRAM<T>::update_serving_requests(const int* addr, int delta, long clk) {
-+  assert(id == addr[int(level)]);
-+  assert(delta == 1 || delta == -1);
-+  // update total serving requests
-+  if (begin_of_cur_reqcnt != -1 && cur_serving_requests > 0) {
-+    serving_requests += (clk - begin_of_cur_reqcnt) * cur_serving_requests;
-+    active_cycles += clk - begin_of_cur_reqcnt;
-+  }
-+  // update begin of current request number
-+  begin_of_cur_reqcnt = clk;
-+  cur_serving_requests += delta;
-+  assert(cur_serving_requests >= 0);
-+
-+  if (delta == 1 && cur_serving_requests == 1) {
-+    // transform from inactive to active
-+    begin_of_serving = clk;
-+    if (end_of_refreshing > begin_of_serving) {
-+      active_refresh_overlap_cycles += end_of_refreshing - begin_of_serving;
-+    }
-+  } else if (cur_serving_requests == 0) {
-+    // transform from active to inactive
-+    assert(begin_of_serving != -1);
-+    assert(delta == -1);
-+    active_cycles += clk - begin_of_cur_reqcnt;
-+    end_of_serving = clk;
-+
-+    for (const auto& ref: refresh_intervals) {
-+      active_refresh_overlap_cycles += min(end_of_serving, ref.second) - ref.first;
-+    }
-+    refresh_intervals.clear();
-+  }
-+
-+  int child_id = addr[int(level) + 1];
-+  // We only count the level bank or the level higher than bank
-+  if (child_id < 0 || !children.size() || (int(level) > int(T::Level::Bank)) ) {
-+    return;
-+  }
-+  children[child_id]->update_serving_requests(addr, delta, clk);
-+}
-+
-+} /* namespace ramulator */
-+
-+#endif /* __DRAM_H */
-diff --git a/ext/ramulator/Ramulator/src/DSARP.cpp b/ext/ramulator/Ramulator/src/DSARP.cpp
-new file mode 100644
-index 0000000..803f96a
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DSARP.cpp
-@@ -0,0 +1,526 @@
-+/*
-+ * DSARP.cpp
-+ *
-+ * This a re-implementation of the refresh mechanisms proposed in Chang et al.,
-+ * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA
-+ * 2014.
-+ *
-+ *  Created on: Mar 16, 2015
-+ *      Author: kevincha
-+ */
-+
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+#include <math.h>
-+#include "DSARP.h"
-+#include "DRAM.h"
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string DSARP::standard_name = "DSARP";
-+string DSARP::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Sa", "Ro", "Co"};
-+
-+map<string, enum DSARP::Org> DSARP::org_map = {
-+  {"DSARP_8Gb_x8", DSARP::Org::DSARP_8Gb_x8},
-+  {"DSARP_16Gb_x9", DSARP::Org::DSARP_16Gb_x8},
-+  {"DSARP_32Gb_x8", DSARP::Org::DSARP_32Gb_x8},
-+};
-+
-+map<string, enum DSARP::Speed> DSARP::speed_map = {
-+  {"DSARP_1333", DSARP::Speed::DSARP_1333},
-+};
-+
-+DSARP::DSARP(Org org, Speed speed, Type type, int n_sa) :
-+  type(type),
-+  org_entry(org_table[int(org)]),
-+  speed_entry(speed_table[int(speed)]),
-+  read_latency(speed_entry.nCL + speed_entry.nBL),
-+  n_sa(n_sa)
-+{
-+  init_speed();
-+  init_prereq();
-+  init_rowhit(); // SAUGATA: added row hit function
-+  init_rowopen();
-+  init_lambda();
-+  init_timing();
-+
-+  // All mechanisms are built on top of REFpb, except for REFab
-+  b_ref_rank = false;
-+  switch(int(type)){
-+    case int(Type::REFAB):
-+      standard_name = "REFAB";
-+      b_ref_rank = true;
-+      break;
-+    case int(Type::REFPB): standard_name = "REFPB"; break;
-+    case int(Type::DARP):  standard_name = "DARP"; break;
-+    case int(Type::SARP):  standard_name = "SARP"; break;
-+    case int(Type::DSARP): standard_name = "DSARP"; break;
-+  }
-+
-+  // Update the SA count (is power of 2, within [1, 128]) and row count
-+  assert(n_sa && n_sa <= 128 && (n_sa & (n_sa-1)) == 0);
-+  org_entry.count[int(Level::SubArray)] = n_sa;
-+  long tmp = long(org_entry.dq) * org_entry.count[int(Level::Bank)] *
-+    n_sa * org_entry.count[int(Level::Column)];
-+  org_entry.count[int(Level::Row)] = long(org_entry.size) * (1<<20) / tmp;
-+
-+  // Change the translation for refresh requests
-+  if (!b_ref_rank)
-+    translate[int(Request::Type::REFRESH)] = Command::REFPB;
-+}
-+
-+DSARP::DSARP(const string& org_str, const string& speed_str, Type type, int n_sa) :
-+  DSARP(org_map[org_str], speed_map[speed_str], type, n_sa) {}
-+
-+void DSARP::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void DSARP::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+
-+void DSARP::init_speed()
-+{
-+  /* Numbers are in DRAM cycles */
-+
-+  // The numbers for RFCab are extrapolated based on past and current DRAM
-+  // generation since they are not available yet. Details on the extrapolation
-+  // are in the paper.
-+  const static int RFCAB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-+    {234}, {354}, {594},
-+  };
-+
-+  // These are extrapolated using the RFCab/REFpb ratio from the LPDDR standard, which is 2.16.
-+  const static int RFCPB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-+    {109}, {164}, {275}
-+  };
-+
-+  // High temperature mode (32ms retention time)
-+  const static int REFI_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-+    {2600},
-+  };
-+
-+  const static int REFIPB_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-+    {325},
-+  };
-+
-+  int speed = 0, density = 0;
-+  switch (speed_entry.rate) {
-+    case 1333: speed = 0; break;
-+    default: assert(false);
-+  };
-+  switch (org_entry.size >> 10){
-+    case 8: density = 0; break;
-+    case 16: density = 1; break;
-+    case 32: density = 2; break;
-+    default: assert(false && "Unknown density");
-+  }
-+
-+  speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-+  speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-+  speed_entry.nREFI = REFI_TABLE[int(refresh_mode)][speed];
-+  speed_entry.nREFIpb = REFIPB_TABLE[int(refresh_mode)][speed];
-+}
-+
-+void DSARP::init_prereq()
-+{
-+  // RD
-+  prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+    switch (int(node->state)) {
-+      case int(State::PowerUp): return Command::MAX;
-+      case int(State::ActPowerDown): return Command::PDX;
-+      case int(State::PrePowerDown): return Command::PDX;
-+      case int(State::SelfRefresh): return Command::SRX;
-+      default: assert(false);
-+    }};
-+  // Rank transitions to Bank
-+  prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+    switch (int(node->state)) {
-+      case int(State::Closed): return Command::ACT;
-+      case int(State::Opened):
-+        // Really is the subarray state. If the subarray matches, check the row ID
-+        if (node->row_state.find(id) != node->row_state.end())
-+          return Command::MAX;
-+        return Command::PRE;
-+      default: assert(false);
-+    }};
-+  // Bank transitions to Subarray
-+  prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+    switch (int(node->state)) {
-+      case int(State::Closed): return Command::ACT;
-+      case int(State::Opened):
-+        // Actual row state
-+        if (node->row_state.find(id) != node->row_state.end())
-+          return cmd;
-+        return Command::PRE;
-+      default: assert(false);
-+    }};
-+
-+  // WR
-+  prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+  prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+  prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-+
-+  // REF -- on all banks
-+  prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+    for (auto bank : node->children) {
-+      if (bank->state == State::Closed)
-+        continue;
-+      return Command::PREA;
-+    }
-+    return Command::REF;};
-+
-+  // REF -- per bank
-+  prereq[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+    if (node->state == State::Closed) return Command::REFPB;
-+    else return Command::PRE;};
-+
-+  // PD
-+  prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+    switch (int(node->state)) {
-+      case int(State::PowerUp): return Command::PDE;
-+      case int(State::ActPowerDown): return Command::PDE;
-+      case int(State::PrePowerDown): return Command::PDE;
-+      case int(State::SelfRefresh): return Command::SRX;
-+      default: assert(false);
-+    }};
-+
-+  // SR
-+  prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+    switch (int(node->state)) {
-+      case int(State::PowerUp): return Command::SRE;
-+      case int(State::ActPowerDown): return Command::PDX;
-+      case int(State::PrePowerDown): return Command::PDX;
-+      case int(State::SelfRefresh): return Command::SRE;
-+      default: assert(false);
-+    }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void DSARP::init_rowhit()
-+{
-+  // RD
-+  rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+      switch (int(node->state)){
-+          case int(State::Closed): return false;
-+          case int(State::Opened):
-+              if (node->row_state.find(id) != node->row_state.end()) return true;
-+              else return false;
-+          default: assert(false);
-+      }};
-+  // WR
-+  rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-+}
-+
-+void DSARP::init_rowopen()
-+{
-+  // RD
-+  rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<DSARP>* node, Command cmd, int id) {
-+      switch (int(node->state)){
-+          case int(State::Closed): return false;
-+          case int(State::Opened): return true;
-+          default: assert(false);
-+      }};
-+  // WR
-+  rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-+}
-+
-+void DSARP::init_lambda()
-+{
-+  // RANK
-+  lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<DSARP>* node, int id) {
-+    node->row_state.clear();
-+    for (auto bank : node->children) {
-+      bank->state = State::Closed;
-+      bank->row_state.clear();
-+      for (auto sa : bank->children){
-+        sa->state = State::Closed;
-+        sa->row_state.clear();}}};
-+  lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<DSARP>* node, int id) {};
-+
-+  // Power down related commands
-+  lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, int id) {
-+    for (auto bank : node->children) {
-+      if (bank->state == State::Closed)
-+        continue;
-+      node->state = State::ActPowerDown;
-+      return;
-+    }
-+    node->state = State::PrePowerDown;};
-+  lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::PowerUp;};
-+  lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::SelfRefresh;};
-+  lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::PowerUp;};
-+
-+  // Open a row
-+  lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::Opened;
-+    node->row_state[id] = State::Opened;};
-+  lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::Opened;
-+    node->row_state[id] = State::Opened;};
-+
-+  // Close a bank
-+  lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::Closed;
-+    node->row_state.clear();
-+    for (auto sa : node->children){
-+      sa->state = State::Closed;
-+      sa->row_state.clear();}};
-+
-+  lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<DSARP>* node, int id) {};
-+  lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<DSARP>* node, int id) {};
-+
-+  // Make sure the bank is closed after the column command
-+  lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::Closed;
-+    node->row_state.clear();};
-+
-+  lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::Closed;
-+    node->row_state.clear();};
-+
-+  // Nothing much, just make sure the bank is closed
-+  lambda[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<DSARP>* node, int id) {
-+    assert(node->state == State::Closed);
-+    node->row_state.clear();};
-+
-+  // COL
-+  lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::Closed;
-+    node->row_state.clear();};
-+  lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<DSARP>* node, int id) {
-+    node->state = State::Closed;
-+    node->row_state.clear();};
-+
-+  // PowerDown -- this has not been tested
-+  lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<DSARP>* node, int id) {
-+    for (auto bank : node->children)
-+      for (auto sa : bank->children) {
-+        if (sa->state == State::Closed)
-+          continue;
-+        node->state = State::ActPowerDown;
-+        return;
-+      }
-+    node->state = State::PrePowerDown;};
-+}
-+
-+void DSARP::init_timing()
-+{
-+  SpeedEntry& s = speed_entry;
-+  vector<TimingEntry> *t;
-+
-+  /*** Channel ***/
-+  t = timing[int(Level::Channel)];
-+
-+  // CAS <-> CAS
-+  t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+  t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+  t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+  t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+  t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+  t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+  t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+  /*** Rank ***/
-+  t = timing[int(Level::Rank)];
-+
-+  // CAS <-> CAS
-+  t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+  t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+  t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+  t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+  t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+  t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+  t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+
-+  // READ to WRITE
-+  t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+  t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+  t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+
-+  // WRITE to READ
-+  t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+  t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+  t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+  t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+  // CAS <-> CAS (between sibling ranks)
-+  t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+  t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+  t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+  t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+  t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+  t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+  t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+
-+  t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+  t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+  t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+  t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+  t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+  t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+  t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+  t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+  // CAS <-> PREA
-+  t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+  t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+  // CAS <-> PD
-+  t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+  t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+  t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+  t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+  t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+  t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+  t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+  t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+  // RAS <-> RAS
-+  t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+  t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+  t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+  t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRPab});
-+
-+  // RAS <-> REF
-+  t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-+  t[int(Command::PREA)].push_back({Command::REF, 1, s.nRPab});
-+  t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-+
-+  // RAS <-> PD
-+  t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+  t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+  t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+  t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+  // RAS <-> SR
-+  t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRPpb});
-+  t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRPab});
-+  t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+  // REF <-> REF
-+  t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-+  t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-+  t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-+
-+  // REF <-> PD
-+  t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+  t[int(Command::REFPB)].push_back({Command::PDE, 1, 1});
-+  t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+  t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-+
-+  // REF <-> SR
-+  t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+  t[int(Command::SRX)].push_back({Command::REFPB, 1, s.nXS});
-+
-+  // PD <-> PD
-+  t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+  t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+  // PD <-> SR
-+  t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+  t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+  // SR <-> SR
-+  t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+  t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+  // REFPB
-+  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb });
-+
-+  /*** Bank ***/
-+  t = timing[int(Level::Bank)];
-+
-+  // CAS <-> RAS
-+  t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+  t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+  t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+  t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+  t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+  t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+  t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-+  t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-+
-+  // RAS <-> RAS
-+  t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+  t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+  t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-+  t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-+
-+  // Cannot overlap REFPB
-+  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb });
-+
-+  // B/w banks
-+  t[int(Command::REFPB)].push_back( { Command::REFPB, 1, s.nRFCpb, true});
-+  t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-+  t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-+
-+  // REFPB -- these are used when SARP is not enabled
-+  if (!(type == Type::DSARP || type == Type::SARP)) {
-+    t[int(Command::REFPB)].push_back( { Command::ACT, 1, s.nRFCpb });
-+    t[int(Command::REFPB)].push_back( { Command::RD, 1, s.nRFCpb });
-+    t[int(Command::REFPB)].push_back( { Command::RDA, 1, s.nRFCpb });
-+    t[int(Command::REFPB)].push_back( { Command::WR, 1, s.nRFCpb });
-+    t[int(Command::REFPB)].push_back( { Command::WRA, 1, s.nRFCpb });
-+    t[int(Command::REFPB)].push_back( { Command::PRE, 1, s.nRFCpb });
-+    t[int(Command::REFPB)].push_back( { Command::PREA, 1, s.nRFCpb });
-+  }
-+
-+  /*** SubArray ***/
-+  if (type == Type::DSARP || type == Type::SARP) {
-+    t = timing[int(Level::SubArray)];
-+
-+    // between different subarrays -> Increase RRD
-+    t[int(Command::ACT)].push_back({Command::REFPB, 1,
-+        (int)ceil(((double)s.nRRD)*nRRD_factor), true});
-+    t[int(Command::REFPB)].push_back({Command::ACT, 1,
-+        (int)ceil(((double)s.nRRD)*nRRD_factor), true});
-+
-+    // Same subarray
-+    t[int(Command::REF)].push_back( { Command::ACT, 1, s.nRFCab });
-+    t[int(Command::REFPB)].push_back( { Command::ACT, 1, s.nRFCpb });
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back( { Command::RD, 1, s.nRCD });
-+    t[int(Command::ACT)].push_back( { Command::RDA, 1, s.nRCD });
-+    t[int(Command::ACT)].push_back( { Command::WR, 1, s.nRCD });
-+    t[int(Command::ACT)].push_back( { Command::WRA, 1, s.nRCD });
-+
-+    t[int(Command::RD)].push_back( { Command::PRE, 1, s.nRTP });
-+    t[int(Command::WR)].push_back(
-+        { Command::PRE, 1, s.nCWL + s.nBL + s.nWR });
-+
-+    t[int(Command::RDA)].push_back( { Command::ACT, 1, s.nRTP + s.nRPpb });
-+    t[int(Command::WRA)].push_back(
-+        { Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb });
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back( { Command::ACT, 1, s.nRC });
-+    t[int(Command::ACT)].push_back( { Command::PRE, 1, s.nRAS });
-+    t[int(Command::PRE)].push_back( { Command::ACT, 1, s.nRPpb });
-+    t[int(Command::PRE)].push_back( { Command::REFPB, 1, s.nRPpb });
-+    t[int(Command::PRE)].push_back( { Command::REF, 1, s.nRPpb });
-+
-+    // Enforcing timings such that there's no subarray parallelism
-+    // between sibling subarrays for demand requests
-+    t[int(Command::ACT)].push_back( { Command::ACT, 1, s.nRC, true });
-+    t[int(Command::PRE)].push_back( { Command::ACT, 1, s.nRPpb, true });
-+    t[int(Command::RDA)].push_back( { Command::ACT, 1, s.nRTP + s.nRPpb,
-+        true });
-+    t[int(Command::WRA)].push_back(
-+        { Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb, true });
-+  }
-+}
-diff --git a/ext/ramulator/Ramulator/src/DSARP.h b/ext/ramulator/Ramulator/src/DSARP.h
-new file mode 100644
-index 0000000..be02e71
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/DSARP.h
-@@ -0,0 +1,273 @@
-+/*
-+ * DSARP.h
-+ *
-+ * This a re-implementation of the refresh mechanisms proposed in Chang et al.,
-+ * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA
-+ * 2014.
-+ *
-+ * Note: the re-implementation of DSARP has not been widely tested across
-+ * different benchmarks and parameters. However, timing violations of
-+ * SARP/DSARP have been checked.
-+ *
-+ * Usage: The "type" determines the refresh mechanisms.
-+ * Examples:
-+ * DSARP::Org test_org = DSARP::Org::DSARP_8Gb_x8;
-+ *
-+ * DSARP* dsddr3_ab = new DSARP(test_org,
-+ * DSARP::Speed::DSARP_1333, DSARP::Type::REFAB, 8);
-+ *
-+ * DSARP* dsddr3_pb = new DSARP(test_org,
-+ * DSARP::Speed::DSARP_1333, DSARP::Type::REFPB, 8);
-+ *
-+ * DSARP* dsddr3_darp = new DSARP(test_org,
-+ * DSARP::Speed::DSARP_1333, DSARP::Type::DARP, 8);
-+ *
-+ * DSARP* dsddr3_sarp = new DSARP(test_org,
-+ * DSARP::Speed::DSARP_1333, DSARP::Type::SARP, 8);
-+ *
-+ * DSARP* dsddr3_dsarp = new DSARP(test_org,
-+ * DSARP::Speed::DSARP_1333, DSARP::Type::DSARP, 8);
-+ *
-+ *  Created on: Mar 16, 2015
-+ *      Author: kevincha
-+ */
-+
-+#ifndef DSARP_H_
-+#define DSARP_H_
-+
-+#include <vector>
-+#include <functional>
-+#include "DRAM.h"
-+#include "Request.h"
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class DSARP
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    enum class Type;
-+    DSARP(Org org, Speed speed, Type type, int n_sa);
-+    DSARP(const string& org_str, const string& speed_str, Type type, int n_sa);
-+
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+
-+    enum class Type : int
-+    {
-+        REFAB, REFPB, DARP, SARP, DSARP, MAX
-+    } type;
-+
-+    /* Level */
-+    // NOTE: Although there's subarray, there's no SALP at all. This is used
-+    // for parallelizing REF and demand accesses.
-+    enum class Level : int
-+    {
-+      Channel, Rank, Bank, SubArray, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /* Command */
-+    enum class Command : int
-+    {
-+        ACT, PRE, PREA,
-+        RD,  WR,  RDA,  WRA,
-+        REF, REFPB, PDE, PDX, SRE, SRX,
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA",
-+        "RD",  "WR",  "RDA",  "WRA",
-+        "REF", "REFPB",
-+        "PDE", "PDX", "SRE", "SRX"
-+    };
-+
-+    // SubArray scope for REFPB to propagate the timings
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Bank,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+            case int(Command::REFPB):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<DSARP>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<DSARP>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<DSARP>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    };
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<DSARP>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        // These are the configurations used in the original paper, essentially DDR3
-+        DSARP_8Gb_x8,
-+        DSARP_16Gb_x8,
-+        DSARP_32Gb_x8,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        // IMPORTANT: Do not change the count for channel/rank, where is set to
-+        // 0 now. 0 means that this a flexible configuration that is not part
-+        // of the spec, but rather something to change at a higher level
-+        // (main.cpp).
-+        {8<<10, 8,  {0, 0, 8, 0, 1<<16, 1<<11}},
-+        {16<<10, 8, {0, 0, 8, 0, 1<<17, 1<<11}},
-+        {32<<10, 8, {0, 0, 8, 0, 1<<18, 1<<11}},
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        DSARP_1333,
-+        MAX
-+    };
-+
-+    enum class RefreshMode : int
-+    {
-+        Refresh_1X,
-+        MAX
-+    } refresh_mode = RefreshMode::Refresh_1X;
-+
-+    int prefetch_size = 16; // 16n prefetch DDR
-+    int channel_width = 32;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS;
-+        int nCL, nRCD, nRPpb, nRPab, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRD, nFAW;
-+        int nRFCab, nRFCpb, nREFI, nREFIpb;
-+        int nPD, nXP, nXPDLL;
-+        int nCKESR, nXS, nXSDLL;
-+        //int nCKE, nXP; // CKE value n/a
-+        //int nSR, nXSR; // tXSR = tRFCab + 7.5ns
-+    } speed_table[int(Speed::MAX)] = {
-+      {1333,
-+      (400.0/3)*5, (3/0.4)/5,
-+       4, 4, 2,
-+       9, 9, 8, 9, 7,
-+       24, 33,
-+       5, 5, 10,
-+       5, 30,
-+       0, 0, 0, 0, // set in DSARP.cpp
-+       4, 4, 16,
-+       5, 114, 512},
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+    // Number of subarrays -- mainly for SARP. Doesn't affect others.
-+    int n_sa;
-+
-+    // Refresh rank?
-+    bool b_ref_rank;
-+
-+    // Increase RRD b/w REF and ACT when they go to the same bank (SARP)
-+    double nRRD_factor = 1.138;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /* DSARP_H_ */
-diff --git a/ext/ramulator/Ramulator/src/GDDR5.cpp b/ext/ramulator/Ramulator/src/GDDR5.cpp
-new file mode 100644
-index 0000000..45a17e9
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/GDDR5.cpp
-@@ -0,0 +1,357 @@
-+#include "GDDR5.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string GDDR5::standard_name = "GDDR5";
-+string GDDR5::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-+
-+
-+map<string, enum GDDR5::Org> GDDR5::org_map = {
-+    {"GDDR5_512Mb_x16", GDDR5::Org::GDDR5_512Mb_x16}, {"GDDR5_512Mb_x32", GDDR5::Org::GDDR5_512Mb_x32},
-+    {"GDDR5_1Gb_x16", GDDR5::Org::GDDR5_1Gb_x16}, {"GDDR5_1Gb_x32", GDDR5::Org::GDDR5_1Gb_x32},
-+    {"GDDR5_2Gb_x16", GDDR5::Org::GDDR5_2Gb_x16}, {"GDDR5_2Gb_x32", GDDR5::Org::GDDR5_2Gb_x32},
-+    {"GDDR5_4Gb_x16", GDDR5::Org::GDDR5_4Gb_x16}, {"GDDR5_4Gb_x32", GDDR5::Org::GDDR5_4Gb_x32},
-+    {"GDDR5_8Gb_x16", GDDR5::Org::GDDR5_8Gb_x16}, {"GDDR5_8Gb_x32", GDDR5::Org::GDDR5_8Gb_x32},
-+};
-+
-+map<string, enum GDDR5::Speed> GDDR5::speed_map = {
-+    {"GDDR5_4000", GDDR5::Speed::GDDR5_4000}, {"GDDR5_4500", GDDR5::Speed::GDDR5_4500},
-+    {"GDDR5_5000", GDDR5::Speed::GDDR5_5000}, {"GDDR5_5500", GDDR5::Speed::GDDR5_5500},
-+    {"GDDR5_6000", GDDR5::Speed::GDDR5_6000}, {"GDDR5_6500", GDDR5::Speed::GDDR5_6500},
-+    {"GDDR5_7000", GDDR5::Speed::GDDR5_7000},
-+};
-+
-+GDDR5::GDDR5(Org org, Speed speed) : 
-+    org_entry(org_table[int(org)]), 
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+GDDR5::GDDR5(const string& org_str, const string& speed_str) :
-+    GDDR5(org_map[org_str], speed_map[speed_str]) 
-+{
-+}
-+
-+void GDDR5::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void GDDR5::set_rank_number(int rank) {
-+  assert((rank == 1) && "GDDR5 rank number is fixed to 1.");
-+}
-+
-+void GDDR5::init_speed()
-+{
-+    const int REFIL_TABLE[int(Speed::MAX)] = {3900, 4388, 4875, 5363, 5850, 6338, 6825};
-+    const int REFIS_TABLE[int(Speed::MAX)] = {1900, 2138, 2375, 2613, 2850, 3088, 3325};
-+    const int RFC_TABLE[5][int(Speed::MAX)] = {
-+        // using DDR3 values
-+        {90, 102, 113, 124, 135, 147, 158},
-+        {110, 124, 138, 152, 165, 179, 193},
-+        {160, 180, 200, 220, 240, 260, 280},
-+        {260, 293, 325, 358, 390, 423, 455},
-+        {350, 394, 438, 482, 525, 569, 613}
-+    };
-+    int speed = 0, density = 0;
-+    switch (speed_entry.rate){
-+        case 4000: speed = 0; break;
-+        case 4500: speed = 1; break;
-+        case 5000: speed = 2; break;
-+        case 5500: speed = 3; break;
-+        case 6000: speed = 4; break;
-+        case 6500: speed = 5; break;
-+        case 7000: speed = 6; break;
-+        default: assert(0);
-+    }
-+    switch (org_entry.size >> 9){
-+        case 1: density = 0; break;
-+        case 2: density = 1; break;
-+        case 4: density = 2; break;
-+        case 8: density = 3; break;
-+        case 16: density = 4; break;
-+        default: assert(0);
-+    }
-+    if (org_entry.size <= 1024) speed_entry.nREFI = REFIL_TABLE[speed];
-+    else speed_entry.nREFI = REFIS_TABLE[speed];
-+    speed_entry.nRFC = RFC_TABLE[density][speed];
-+}
-+
-+
-+void GDDR5::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank : bg->children) {
-+                if (bank->state == State::Closed)
-+                    continue;
-+                return Command::PREA;
-+            }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void GDDR5::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void GDDR5::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void GDDR5::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<GDDR5>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<GDDR5>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<GDDR5>* node, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank : bg->children) {
-+                bank->state = State::Closed;
-+                bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<GDDR5>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<GDDR5>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<GDDR5>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<GDDR5>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<GDDR5>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<GDDR5>* node, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank : bg->children) {
-+                if (bank->state == State::Closed)
-+                    continue;
-+                node->state = State::ActPowerDown;
-+                return;
-+            }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<GDDR5>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<GDDR5>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<GDDR5>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void GDDR5::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/ 
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/ 
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXPN});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXPN});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXPN});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXPN});
-+    
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::ACT, 32, s.n32AW});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-+    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nPPD});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXPN});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXPN});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXPN});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXPN});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+    
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXPN});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXPN});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+    
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+
-+    // Bank group level
-+    t = timing[int(Level::BankGroup)];
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-+
-+    /*** Bank ***/ 
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCDR});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCDR});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCDW});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCDW});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+}
-diff --git a/ext/ramulator/Ramulator/src/GDDR5.h b/ext/ramulator/Ramulator/src/GDDR5.h
-new file mode 100644
-index 0000000..23e929d
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/GDDR5.h
-@@ -0,0 +1,213 @@
-+#ifndef __GDDR5_H
-+#define __GDDR5_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class GDDR5
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    GDDR5(Org org, Speed speed);
-+    GDDR5(const string& org_str, const string& speed_str);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+
-+    /*** Level ***/
-+    enum class Level : int
-+    { 
-+        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    { 
-+        ACT, PRE, PREA, 
-+        RD,  WR,  RDA,  WRA, 
-+        REF, PDE, PDX,  SRE, SRX, 
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA", 
-+        "RD",  "WR",  "RDA",  "WRA", 
-+        "REF", "PDE", "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<GDDR5>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<GDDR5>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<GDDR5>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<GDDR5>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        GDDR5_512Mb_x16, GDDR5_512Mb_x32,
-+        GDDR5_1Gb_x16,   GDDR5_1Gb_x32,
-+        GDDR5_2Gb_x16,   GDDR5_2Gb_x32,
-+        GDDR5_4Gb_x16,   GDDR5_4Gb_x32,
-+        GDDR5_8Gb_x16,   GDDR5_8Gb_x32,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        // fixed to have 1 rank
-+        // in GDDR5 the column address is unique for a burst. e.g. 64 column addresses correspond with
-+        // 256 column addresses actually. So we multiply 8 to the original address bit number in JEDEC standard
-+        {  512, 16, {0, 1, 4, 2, 1<<12, 1<<(7+3)}}, {  512, 32, {0, 1, 4, 2, 1<<12, 1<<(6+3)}},
-+        {1<<10, 16, {0, 1, 4, 4, 1<<12, 1<<(7+3)}}, {1<<10, 32, {0, 1, 4, 4, 1<<12, 1<<(6+3)}},
-+        {2<<10, 16, {0, 1, 4, 4, 1<<13, 1<<(7+3)}}, {2<<10, 32, {0, 1, 4, 4, 1<<13, 1<<(6+3)}},
-+        {4<<10, 16, {0, 1, 4, 4, 1<<14, 1<<(7+3)}}, {2<<10, 32, {0, 1, 4, 4, 1<<14, 1<<(6+3)}},
-+        {8<<10, 16, {0, 1, 4, 4, 1<<14, 1<<(8+3)}}, {8<<10, 32, {0, 1, 4, 4, 1<<14, 1<<(7+3)}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        GDDR5_4000, GDDR5_4500,
-+        GDDR5_5000, GDDR5_5500,
-+        GDDR5_6000, GDDR5_6500,
-+        GDDR5_7000,
-+        MAX
-+    };
-+
-+    int prefetch_size = 8; // 8n prefetch QDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCDS, nCCDL;
-+        int nCL, nRCDR, nRCDW, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nPPD, nRTP, nWTR, nWR;
-+        int nRRD, nFAW, n32AW;
-+        int nRFC, nREFI;
-+        int nPD, nXPN, nLK;
-+        int nCKESR, nXS, nXSDLL;
-+    } speed_table[int(Speed::MAX)] = {
-+        {4000,  8*500/4,  8.0/8, 2, 2, 3, 12, 12, 10, 12, 3, 28, 40, 1, 2, 5, 12,  6, 23, 184, 0, 0, 10, 10, 0, 0, 0, 0},
-+        {4500,  9*500/4,  8.0/9, 2, 2, 3, 14, 14, 12, 14, 4, 32, 46, 2, 2, 6, 14,  7, 26, 207, 0, 0, 10, 10, 0, 0, 0, 0},
-+        {5000, 10*500/4, 8.0/10, 2, 2, 3, 15, 15, 13, 15, 4, 35, 50, 2, 2, 7, 15,  7, 29, 230, 0, 0, 10, 10, 0, 0, 0, 0},
-+        {5500, 11*500/4, 8.0/11, 2, 2, 3, 17, 17, 14, 17, 5, 39, 56, 2, 2, 7, 17,  8, 32, 253, 0, 0, 10, 10, 0, 0, 0, 0},
-+        {6000, 12*500/4, 8.0/12, 2, 2, 3, 18, 18, 15, 18, 5, 42, 60, 2, 2, 8, 18,  9, 35, 276, 0, 0, 10, 10, 0, 0, 0, 0},
-+        {6500, 13*500/4, 8.0/13, 2, 2, 3, 20, 20, 17, 20, 5, 46, 66, 2, 2, 9, 20,  9, 38, 299, 0, 0, 10, 10, 0, 0, 0, 0},
-+        {7000, 14*500/4, 8.0/14, 2, 2, 3, 21, 21, 18, 21, 6, 49, 70, 2, 2, 9, 21, 10, 41, 322, 0, 0, 10, 10, 0, 0, 0, 0}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__GDDR5_H*/
-diff --git a/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp b/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp
-new file mode 100644
-index 0000000..780c12e
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Gem5Wrapper.cpp
-@@ -0,0 +1,68 @@
-+#include <map>
-+
-+#include "Gem5Wrapper.h"
-+#include "Config.h"
-+#include "Request.h"
-+#include "MemoryFactory.h"
-+#include "Memory.h"
-+#include "DDR3.h"
-+#include "DDR4.h"
-+#include "LPDDR3.h"
-+#include "LPDDR4.h"
-+#include "GDDR5.h"
-+#include "WideIO.h"
-+#include "WideIO2.h"
-+#include "HBM.h"
-+#include "SALP.h"
-+
-+using namespace ramulator;
-+
-+static map<string, function<MemoryBase *(const Config&, int, bool)> > name_to_func = {
-+    {"DDR3", &MemoryFactory<DDR3>::create},
-+    {"DDR4", &MemoryFactory<DDR4>::create},
-+    {"LPDDR3", &MemoryFactory<LPDDR3>::create},
-+    {"LPDDR4", &MemoryFactory<LPDDR4>::create},
-+    {"GDDR5", &MemoryFactory<GDDR5>::create}, 
-+    {"WideIO", &MemoryFactory<WideIO>::create},
-+    {"WideIO2", &MemoryFactory<WideIO2>::create},
-+    {"HBM", &MemoryFactory<HBM>::create},
-+    {"SALP-1", &MemoryFactory<SALP>::create},
-+    {"SALP-2", &MemoryFactory<SALP>::create},
-+    {"SALP-MASA", &MemoryFactory<SALP>::create},
-+};
-+
-+
-+Gem5Wrapper::Gem5Wrapper(const Config& configs, int cacheline)
-+{
-+    const string& std_name = configs["standard"];
-+    assert(name_to_func.find(std_name) != name_to_func.end() && "unrecognized standard name");
-+    mem = name_to_func[std_name](configs, cacheline, false);
-+    tCK = mem->clk_ns();
-+    // daz3:  one wrapper
-+    tickCount = 0;
-+}
-+
-+
-+Gem5Wrapper::~Gem5Wrapper() {
-+    delete mem;
-+}
-+
-+void Gem5Wrapper::tick()
-+{
-+    // mem->tick();
-+    // daz3
-+    if(tickCount % 2 == 0)
-+    {
-+        mem->tick();
-+    }
-+    tickCount++;
-+}
-+
-+bool Gem5Wrapper::send(Request req)
-+{
-+  return mem->send(req);
-+}
-+
-+void Gem5Wrapper::finish(void) {
-+    mem->finish();
-+}
-diff --git a/ext/ramulator/Ramulator/src/Gem5Wrapper.h b/ext/ramulator/Ramulator/src/Gem5Wrapper.h
-new file mode 100644
-index 0000000..0745d38
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Gem5Wrapper.h
-@@ -0,0 +1,33 @@
-+#ifndef __GEM5_WRAPPER_H
-+#define __GEM5_WRAPPER_H
-+
-+#include <string>
-+
-+#include "Config.h"
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class Request;
-+class MemoryBase;
-+
-+class Gem5Wrapper 
-+{
-+private:
-+    MemoryBase *mem;
-+// daz3: one wrapper
-+    long tickCount;
-+public:
-+    double tCK;
-+    Gem5Wrapper(const Config& configs, int cacheline);
-+    ~Gem5Wrapper();
-+    void tick();
-+    bool send(Request req);
-+    void finish(void);
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__GEM5_WRAPPER_H*/
-diff --git a/ext/ramulator/Ramulator/src/HBM.cpp b/ext/ramulator/Ramulator/src/HBM.cpp
-new file mode 100644
-index 0000000..8ba7ef6
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/HBM.cpp
-@@ -0,0 +1,360 @@
-+#include "HBM.h"
-+#include "DRAM.h"
-+
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string HBM::standard_name = "HBM";
-+string HBM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Bg", "Ba", "Ro", "Co"};
-+
-+map<string, enum HBM::Org> HBM::org_map = {
-+    {"HBM_1Gb", HBM::Org::HBM_1Gb},
-+    {"HBM_2Gb", HBM::Org::HBM_2Gb},
-+    {"HBM_4Gb", HBM::Org::HBM_4Gb},
-+};
-+
-+map<string, enum HBM::Speed> HBM::speed_map = {
-+    {"HBM_1Gbps", HBM::Speed::HBM_1Gbps},
-+};
-+
-+HBM::HBM(Org org, Speed speed)
-+    : org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+HBM::HBM(const string& org_str, const string& speed_str) :
-+    HBM(org_map[org_str], speed_map[speed_str])
-+{
-+}
-+
-+void HBM::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void HBM::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+
-+void HBM::init_speed()
-+{
-+    const static int RFC_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-+        {55, 80, 130}
-+    };
-+    const static int REFI1B_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-+        {64, 128, 256}
-+    };
-+    const static int XS_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-+        {60, 85, 135}
-+    };
-+
-+    int speed = 0, density = 0;
-+    switch (speed_entry.rate) {
-+        case 1000: speed = 0; break;
-+        default: assert(false);
-+    };
-+    switch (org_entry.size >> 10){
-+        case 1: density = 0; break;
-+        case 2: density = 1; break;
-+        case 4: density = 2; break;
-+        default: assert(false);
-+    }
-+    speed_entry.nRFC = RFC_TABLE[speed][density];
-+    speed_entry.nREFI1B = REFI1B_TABLE[speed][density];
-+    speed_entry.nXS = XS_TABLE[speed][density];
-+}
-+
-+
-+void HBM::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                else return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank: bg->children) {
-+                if (bank->state == State::Closed)
-+                    continue;
-+                return Command::PREA;
-+            }
-+        return Command::REF;};
-+
-+    // REFSB
-+    prereq[int(Level::Bank)][int(Command::REFSB)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        if (node->state == State::Closed) return Command::REFSB;
-+        return Command::PRE;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void HBM::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void HBM::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void HBM::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<HBM>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<HBM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<HBM>* node, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank : bg->children) {
-+                bank->state = State::Closed;
-+                bank->row_state.clear();
-+            }};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<HBM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<HBM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<HBM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<HBM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<HBM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<HBM>* node, int id) {
-+        for (auto bg : node->children)
-+            for (auto bank : bg->children) {
-+                if (bank->state == State::Closed)
-+                    continue;
-+                node->state = State::ActPowerDown;
-+                return;
-+            }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<HBM>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<HBM>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<HBM>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void HBM::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDS});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDS});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDS});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDS});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDS});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDS});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDS});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDS});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCDS + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRS});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRS});
-+
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDS});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+    /*** Bank Group ***/
-+    t = timing[int(Level::BankGroup)];
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCDL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCDL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCDL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCDL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCDL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTRL});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTRL});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDL});
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCDR});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCDR});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCDW});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCDW});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // REFSB
-+    t[int(Command::PRE)].push_back({Command::REFSB, 1, s.nRP});
-+    t[int(Command::REFSB)].push_back({Command::REFSB, 1, s.nRFC});
-+    t[int(Command::REFSB)].push_back({Command::ACT, 1, s.nRFC});
-+}
-diff --git a/ext/ramulator/Ramulator/src/HBM.h b/ext/ramulator/Ramulator/src/HBM.h
-new file mode 100644
-index 0000000..76501be
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/HBM.h
-@@ -0,0 +1,201 @@
-+#ifndef __HBM_H
-+#define __HBM_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class HBM
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    HBM(Org org, Speed speed);
-+    HBM(const string& org_str, const string& speed_str);
-+
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+
-+    /* Level */
-+    enum class Level : int
-+    {
-+        Channel, Rank, BankGroup, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /* Command */
-+    enum class Command : int
-+    {
-+        ACT, PRE,   PREA,
-+        RD,  WR,    RDA, WRA,
-+        REF, REFSB, PDE, PDX,  SRE, SRX,
-+        MAX
-+    };
-+
-+    // REFSB and REF is not compatible, choose one or the other.
-+    // REFSB can be issued to banks in any order, as long as REFI1B
-+    // is satisfied for all banks
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE",   "PREA",
-+        "RD",  "WR",    "RDA",  "WRA",
-+        "REF", "REFSB", "PDE",  "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+            case int(Command::REFSB):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::MAX, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prereq */
-+    function<Command(DRAM<HBM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<HBM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<HBM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    };
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<HBM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    { // per channel density here. Each stack comes with 8 channels
-+        HBM_1Gb,
-+        HBM_2Gb,
-+        HBM_4Gb,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {1<<10, 128, {0, 0, 4, 2, 1<<13, 1<<(6+1)}},
-+        {2<<10, 128, {0, 0, 4, 2, 1<<14, 1<<(6+1)}},
-+        {4<<10, 128, {0, 0, 4, 4, 1<<14, 1<<(6+1)}},
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        HBM_1Gbps,
-+        MAX
-+    };
-+
-+    int prefetch_size = 4; // burst length could be 2 and 4 (choose 4 here), 2n prefetch
-+    int channel_width = 128;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCDS, nCCDL;
-+        int nCL, nRCDR, nRCDW, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTRS, nWTRL, nWR;
-+        int nRRDS, nRRDL, nFAW;
-+        int nRFC, nREFI, nREFI1B;
-+        int nPD, nXP;
-+        int nCKESR, nXS;
-+    } speed_table[int(Speed::MAX)] = {
-+        {1000, 500, 2.0, 2, 2, 3, 7, 7, 6, 7, 4, 17, 24, 7, 2, 4, 8, 4, 5, 20, 0, 1950, 0, 5, 5, 5, 0}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__HBM_H*/
-diff --git a/ext/ramulator/Ramulator/src/LPDDR3.cpp b/ext/ramulator/Ramulator/src/LPDDR3.cpp
-new file mode 100644
-index 0000000..63f47a5
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/LPDDR3.cpp
-@@ -0,0 +1,378 @@
-+#include "LPDDR3.h"
-+#include "DRAM.h"
-+
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string LPDDR3::standard_name = "LPDDR3";
-+string LPDDR3::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum LPDDR3::Org> LPDDR3::org_map = {
-+    {"LPDDR3_4Gb_x16", LPDDR3::Org::LPDDR3_4Gb_x16}, {"LPDDR3_4Gb_x32", LPDDR3::Org::LPDDR3_4Gb_x32},
-+    {"LPDDR3_6Gb_x16", LPDDR3::Org::LPDDR3_6Gb_x16}, {"LPDDR3_6Gb_x32", LPDDR3::Org::LPDDR3_6Gb_x32},
-+    {"LPDDR3_8Gb_x16", LPDDR3::Org::LPDDR3_8Gb_x16}, {"LPDDR3_8Gb_x32", LPDDR3::Org::LPDDR3_8Gb_x32},
-+    {"LPDDR3_12Gb_x16", LPDDR3::Org::LPDDR3_12Gb_x16}, {"LPDDR3_12Gb_x32", LPDDR3::Org::LPDDR3_12Gb_x32},
-+    {"LPDDR3_16Gb_x16", LPDDR3::Org::LPDDR3_16Gb_x16}, {"LPDDR3_16Gb_x32", LPDDR3::Org::LPDDR3_16Gb_x32},
-+};
-+
-+map<string, enum LPDDR3::Speed> LPDDR3::speed_map = {
-+    {"LPDDR3_1333", LPDDR3::Speed::LPDDR3_1333},
-+    {"LPDDR3_1600", LPDDR3::Speed::LPDDR3_1600},
-+    {"LPDDR3_1866", LPDDR3::Speed::LPDDR3_1866},
-+    {"LPDDR3_2133", LPDDR3::Speed::LPDDR3_2133},
-+};
-+
-+LPDDR3::LPDDR3(Org org, Speed speed)
-+    : org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+LPDDR3::LPDDR3(const string& org_str, const string& speed_str) :
-+    LPDDR3(org_map[org_str], speed_map[speed_str])
-+{
-+}
-+
-+void LPDDR3::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void LPDDR3::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void LPDDR3::init_speed()
-+{
-+    // 12Gb/16Gb RFCab/RFCpb TBD
-+
-+    const static int RFCPB_TABLE[3][4] = {
-+        {40, 48, 56, 64},
-+        {60, 72, 84, 96},
-+        {60, 72, 84, 96}
-+    };
-+
-+    const static int RFCAB_TABLE[3][4] = {
-+        {87, 104, 122, 139},
-+        {140, 168, 196, 224},
-+        {140, 168, 196, 224}
-+    };
-+
-+    const static int XSR_TABLE[3][4] = {
-+        {94, 112, 131, 150},
-+        {147, 176, 206, 235},
-+        {147, 176, 206, 235}
-+    };
-+
-+    int speed = 0, density = 0;
-+    switch (speed_entry.rate) {
-+        case 1333: speed = 0; break;
-+        case 1600: speed = 1; break;
-+        case 1866: speed = 2; break;
-+        case 2133: speed = 3; break;
-+        default: assert(false);
-+    };
-+    switch (org_entry.size >> 10){
-+        case 4: density = 0; break;
-+        case 6: density = 1; break;
-+        case 8: density = 2; break;
-+        default: assert(false && "12Gb/16Gb is still TBD");
-+    }
-+    speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-+    speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-+    speed_entry.nXSR = XSR_TABLE[density][speed];
-+}
-+
-+
-+void LPDDR3::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PRA;
-+        }
-+        return Command::REF;};
-+
-+    // REFPB
-+    prereq[int(Level::Bank)][int(Command::REFPB)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+      if (node->state == State::Closed) return Command::REFPB;
-+        else return Command::PRE;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PD;
-+            case int(State::ActPowerDown): return Command::PD;
-+            case int(State::PrePowerDown): return Command::PD;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SREF;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREF;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void LPDDR3::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void LPDDR3::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void LPDDR3::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<LPDDR3>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<LPDDR3>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<LPDDR3>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR3>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR3>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<LPDDR3>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<LPDDR3>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<LPDDR3>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<LPDDR3>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<LPDDR3>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR3>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<LPDDR3>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void LPDDR3::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    // section 4.7.3 table 11
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    // CAS <-> PRA
-+    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-+    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRPab});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-+    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRPab});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-+    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRPab});
-+    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-+    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-+    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-+    t[int(Command::REFPB)].push_back({Command::PD, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-+    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-+
-+    // PD <-> PD
-+    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-+    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-+    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-+
-+    // SR <-> SR
-+    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-+    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-+    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-+
-+    // between different banks
-+    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-+    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-+
-+    // REFSB
-+    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-+    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-+}
-diff --git a/ext/ramulator/Ramulator/src/LPDDR3.h b/ext/ramulator/Ramulator/src/LPDDR3.h
-new file mode 100644
-index 0000000..6f95a61
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/LPDDR3.h
-@@ -0,0 +1,210 @@
-+#ifndef __LPDDR3_H
-+#define __LPDDR3_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class LPDDR3
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    LPDDR3(Org org, Speed speed);
-+    LPDDR3(const string& org_str, const string& speed_str);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+
-+    /* Level */
-+    enum class Level : int
-+    { 
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /* Command */
-+    enum class Command : int
-+    { 
-+        ACT, PRE, PRA, 
-+        RD,  WR,  RDA,  WRA, 
-+        REF, REFPB, PD, PDX,  SREF, SREFX, 
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PRA", 
-+        "RD",  "WR",  "RDA",  "WRA", 
-+        "REF", "REFPB", "PD", "PDX",  "SREF", "SREFX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+            case int(Command::REFPB):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PD, Command::SREF
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<LPDDR3>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<LPDDR3>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<LPDDR3>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<LPDDR3>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        LPDDR3_4Gb_x16, LPDDR3_4Gb_x32,
-+        LPDDR3_6Gb_x16, LPDDR3_6Gb_x32,
-+        LPDDR3_8Gb_x16, LPDDR3_8Gb_x32,
-+        LPDDR3_12Gb_x16, LPDDR3_12Gb_x32,
-+        LPDDR3_16Gb_x16, LPDDR3_16Gb_x32,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {4<<10, 16, {0, 0, 8, 1<<14, 1<<11}}, {4<<10, 32, {0, 0, 8, 1<<14, 1<<10}},
-+        {6<<10, 16, {0, 0, 8, 3<<13, 1<<11}}, {6<<10, 32, {0, 0, 8, 3<<13, 1<<10}},
-+        {8<<10, 16, {0, 0, 8, 1<<15, 1<<11}}, {8<<10, 32, {0, 0, 8, 1<<15, 1<<10}},
-+        {12<<10, 16, {0, 0, 8, 3<<13, 1<<12}}, {12<<10, 32, {0, 0, 8, 3<<13, 1<<11}},
-+        {16<<10, 16, {0, 0, 8, 1<<15, 1<<12}}, {16<<10, 32, {0, 0, 8, 1<<15, 1<<11}},
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        LPDDR3_1333,
-+        LPDDR3_1600,
-+        LPDDR3_1866,
-+        LPDDR3_2133,
-+        MAX
-+    };
-+
-+    int prefetch_size = 8; // 16n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS, nDQSCK;
-+        int nCL, nRCD, nRPpb, nRPab, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRD, nFAW;
-+        int nRFCab, nRFCpb, nREFI;
-+        int nCKE, nXP; // CKE is PD, LPDDR3 has no DLL
-+        int nCKESR, nXSR; // tXSR = tRFCab + 10ns
-+    } speed_table[int(Speed::MAX)] = {
-+        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2, 2, 10, 12, 12, 14, 6, 28, 40, 5, 5, 10,  7, 34, 0, 0, 2600, 5, 5, 10, 0},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 2, 12, 15, 15, 17, 6, 34, 48, 6, 6, 12,  8, 40, 0, 0, 3120, 6, 6, 12, 0},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 3, 14, 17, 17, 20, 8, 40, 56, 7, 7, 14, 10, 47, 0, 0, 3640, 7, 7, 14, 0},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 3, 16, 20, 20, 23, 8, 45, 64, 8, 8, 16, 11, 54, 0, 0, 4160, 8, 8, 16, 0}
-+    }, speed_entry;
-+
-+    // LPDDR3 defines {fast, typical, slow} timing for tRCD and tRP. (typ)
-+    // WL as diff. values for set A/B (A)
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__LPDDR3_H*/
-diff --git a/ext/ramulator/Ramulator/src/LPDDR4.cpp b/ext/ramulator/Ramulator/src/LPDDR4.cpp
-new file mode 100644
-index 0000000..d0510c2
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/LPDDR4.cpp
-@@ -0,0 +1,379 @@
-+#include "LPDDR4.h"
-+#include "DRAM.h"
-+
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string LPDDR4::standard_name = "LPDDR4";
-+string LPDDR4::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum LPDDR4::Org> LPDDR4::org_map = {
-+    {"LPDDR4_4Gb_x16", LPDDR4::Org::LPDDR4_4Gb_x16},
-+    {"LPDDR4_6Gb_x16", LPDDR4::Org::LPDDR4_6Gb_x16},
-+    {"LPDDR4_8Gb_x16", LPDDR4::Org::LPDDR4_8Gb_x16},
-+};
-+
-+map<string, enum LPDDR4::Speed> LPDDR4::speed_map = {
-+    {"LPDDR4_1600", LPDDR4::Speed::LPDDR4_1600},
-+    {"LPDDR4_2400", LPDDR4::Speed::LPDDR4_2400},
-+    {"LPDDR4_3200", LPDDR4::Speed::LPDDR4_3200},
-+};
-+
-+LPDDR4::LPDDR4(Org org, Speed speed)
-+    : org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+LPDDR4::LPDDR4(const string& org_str, const string& speed_str) :
-+    LPDDR4(org_map[org_str], speed_map[speed_str])
-+{
-+}
-+
-+void LPDDR4::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void LPDDR4::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+
-+void LPDDR4::init_speed()
-+{
-+    // 12Gb/16Gb RFCab/RFCpb TBD
-+    // Numbers are in DRAM cycles
-+    const static int RFCPB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-+        {48,  72,  96},
-+        {72, 108, 144},
-+        {72, 108, 144}
-+    };
-+
-+    const static int RFCAB_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-+        {104, 156, 208},
-+        {144, 216, 288},
-+        {144, 216, 288}
-+    };
-+
-+    const static int REFI_TABLE[int(RefreshMode::MAX)][int(Speed::MAX)] = {
-+        {3124, 4685, 6247},
-+        {1563, 2344, 3125},
-+        { 782, 1172, 1563}
-+    };
-+
-+    const static int XSR_TABLE[int(Org::MAX)][int(Speed::MAX)] = {
-+        {110, 165, 220},
-+        {150, 225, 300},
-+        {150, 225, 300},
-+    };
-+
-+    int speed = 0, density = 0;
-+    switch (speed_entry.rate) {
-+        case 1600: speed = 0; break;
-+        case 2400: speed = 1; break;
-+        case 3200: speed = 2; break;
-+        default: assert(false);
-+    };
-+    switch (org_entry.size >> 10){
-+        case 2: density = 0; break;
-+        case 3: density = 1; break;
-+        case 4: density = 2; break;
-+        default: assert(false && "12Gb/16Gb is still TBD");
-+    }
-+    speed_entry.nRFCpb = RFCPB_TABLE[density][speed];
-+    speed_entry.nRFCab = RFCAB_TABLE[density][speed];
-+    speed_entry.nREFI = REFI_TABLE[int(refresh_mode)][speed];
-+    speed_entry.nXSR = XSR_TABLE[density][speed];
-+}
-+
-+
-+void LPDDR4::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PREA;
-+        }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SREF;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREF;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void LPDDR4::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void LPDDR4::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void LPDDR4::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<LPDDR4>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<LPDDR4>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<LPDDR4>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<LPDDR4>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<LPDDR4>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<LPDDR4>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<LPDDR4>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<LPDDR4>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<LPDDR4>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<LPDDR4>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<LPDDR4>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<LPDDR4>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void LPDDR4::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 - s.nCWL});
-+
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR + 1});
-+
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    // CAS <-> PREA
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRPab});
-+    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nPPD});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRPab});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-+    t[int(Command::PREA)].push_back({Command::SREF, 1, s.nRPab});
-+    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-+    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-+    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::REFPB)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-+    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nCKE});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-+    t[int(Command::SREFX)].push_back({Command::PDE, 1, s.nXSR});
-+
-+    // SR <-> SR
-+    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nSR});
-+    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRPpb});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-+    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-+
-+    // between different banks
-+    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-+    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-+
-+    // REFPB
-+    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-+    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-+}
-diff --git a/ext/ramulator/Ramulator/src/LPDDR4.h b/ext/ramulator/Ramulator/src/LPDDR4.h
-new file mode 100644
-index 0000000..d8b736b
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/LPDDR4.h
-@@ -0,0 +1,224 @@
-+#ifndef __LPDDR4_H
-+#define __LPDDR4_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class LPDDR4
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    LPDDR4(Org org, Speed speed);
-+    LPDDR4(const string& org_str, const string& speed_str);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+
-+    /* Level */
-+    enum class Level : int
-+    { 
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /* Command */
-+    enum class Command : int
-+    { 
-+        ACT, PRE, PREA, 
-+        RD,  WR,  RDA,  WRA, 
-+        REF, REFPB, PDE, PDX, SREF, SREFX, 
-+        MAX
-+    };
-+    // Due to multiplexing on the cmd/addr bus:
-+    //      ACT, RD, WR, RDA, WRA take 4 cycles
-+    //      PRE, PREA, REF, REFPB, PDE, PDX, SREF, SREFX take 2 cycles
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA", 
-+        "RD",  "WR",  "RDA",  "WRA", 
-+        "REF", "REFPB", "PDE", "PDX", "SREF", "SREFX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+            case int(Command::REFPB):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SREF
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<LPDDR4>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<LPDDR4>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<LPDDR4>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<LPDDR4>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        // this is per-die density, actual per-chan density is half
-+        LPDDR4_4Gb_x16,
-+        LPDDR4_6Gb_x16,
-+        LPDDR4_8Gb_x16,
-+        // LPDDR4_12Gb_x16, // tRFC TBD
-+        // LPDDR4_16Gb_x16, // tRFC TBD
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-+        {3<<10, 16, {0, 0, 8, 3<<13, 1<<10}},
-+        {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        LPDDR4_1600,
-+        LPDDR4_2400,
-+        LPDDR4_3200,
-+        MAX
-+    };
-+
-+    enum class RefreshMode : int
-+    {
-+        Refresh_1X,
-+        Refresh_2X,
-+        Refresh_4X,
-+        MAX
-+    } refresh_mode = RefreshMode::Refresh_1X;
-+
-+    int prefetch_size = 16; // 16n prefetch DDR
-+    int channel_width = 32;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS, nDQSCK;
-+        int nCL, nRCD, nRPpb, nRPab, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nPPD, nRRD, nFAW;
-+        int nRFCab, nRFCpb, nREFI;
-+        int nCKE, nXP; // CKE value n/a
-+        int nSR, nXSR; // tXSR = tRFCab + 7.5ns
-+    } speed_table[int(Speed::MAX)] = {
-+        // LPDDR4 is 16n prefetch. Latencies in JESD209-4 counts from and to 
-+        // the end of each command, I've converted them as if all commands take
-+        // only 1 cycle like other standards
-+        // CL-RCD-RPpb are set to the same value althrough CL is not explicitly specified.
-+        // CWL is made up, half of CL.
-+        // calculated from 10.2 core timing table 89
-+        {1600, 400.0*2, 2.5/2, 8, 8, 2, 1, 15+3, 15, 15-2, 17-2,  8+3, 34, 47,  8+2,  8, 15-1, 4,  8, 32, 0, 0, 0, 0,  6, 12, 0},
-+        {2400, 400.0*3, 2.5/3, 8, 8, 2, 2, 22+3, 22, 22-2, 26-2, 11+3, 51, 71,  9+2, 12, 22-1, 4, 12, 48, 0, 0, 0, 0,  9, 18, 0},
-+        {3200, 400.0*4, 2.5/4, 8, 8, 2, 3, 29+3, 29, 29-2, 34-2, 15+3, 68, 95, 12+2, 16, 29-1, 4, 16, 64, 0, 0, 0, 0, 12, 24, 0}
-+    }, speed_entry;
-+
-+    // LPDDR4 defines {fast, typical, slow} timing for tRCD and tRP. (typ)
-+    // WL as diff. values for set A/B (A)
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__LPDDR4_H*/
-diff --git a/ext/ramulator/Ramulator/src/Main.cpp b/ext/ramulator/Ramulator/src/Main.cpp
-new file mode 100644
-index 0000000..e46b49e
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Main.cpp
-@@ -0,0 +1,277 @@
-+#include "Processor.h"
-+#include "Config.h"
-+#include "Controller.h"
-+#include "SpeedyController.h"
-+#include "Memory.h"
-+#include "DRAM.h"
-+#include "Statistics.h"
-+#include <cstdio>
-+#include <cstdlib>
-+#include <cstring>
-+#include <stdlib.h>
-+#include <functional>
-+#include <map>
-+
-+/* Standards */
-+#include "Gem5Wrapper.h"
-+#include "DDR3.h"
-+#include "DDR4.h"
-+#include "DSARP.h"
-+#include "GDDR5.h"
-+#include "LPDDR3.h"
-+#include "LPDDR4.h"
-+#include "WideIO.h"
-+#include "WideIO2.h"
-+#include "HBM.h"
-+#include "SALP.h"
-+#include "ALDRAM.h"
-+#include "TLDRAM.h"
-+#include "STTMRAM.h"
-+#include "PCM.h"
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+bool ramulator::warmup_complete = false;
-+
-+template<typename T>
-+void run_dramtrace(const Config& configs, Memory<T, Controller>& memory, const char* tracename) {
-+
-+    /* initialize DRAM trace */
-+    Trace trace(tracename);
-+
-+    /* run simulation */
-+    bool stall = false, end = false;
-+    int reads = 0, writes = 0, clks = 0;
-+    long addr = 0;
-+    Request::Type type = Request::Type::READ;
-+    map<int, int> latencies;
-+    auto read_complete = [&latencies](Request& r){latencies[r.depart - r.arrive]++;};
-+
-+    Request req(addr, type, read_complete);
-+
-+    while (!end || memory.pending_requests()){
-+        if (!end && !stall){
-+            end = !trace.get_dramtrace_request(addr, type);
-+        }
-+
-+        if (!end){
-+            req.addr = addr;
-+            req.type = type;
-+            stall = !memory.send(req);
-+            if (!stall){
-+                if (type == Request::Type::READ) reads++;
-+                else if (type == Request::Type::WRITE) writes++;
-+            }
-+        }
-+        else {
-+            memory.set_high_writeq_watermark(0.0f); // make sure that all write requests in the
-+                                                    // write queue are drained
-+        }
-+
-+        memory.tick();
-+        clks ++;
-+        Stats::curTick++; // memory clock, global, for Statistics
-+    }
-+    // This a workaround for statistics set only initially lost in the end
-+    memory.finish();
-+    Stats::statlist.printall();
-+
-+}
-+
-+template <typename T>
-+void run_cputrace(const Config& configs, Memory<T, Controller>& memory, const std::vector<const char *>& files)
-+{
-+    int cpu_tick = configs.get_cpu_tick();
-+    int mem_tick = configs.get_mem_tick();
-+    auto send = bind(&Memory<T, Controller>::send, &memory, placeholders::_1);
-+    Processor proc(configs, files, send, memory);
-+
-+    long warmup_insts = configs.get_warmup_insts();
-+    bool is_warming_up = (warmup_insts != 0);
-+
-+    for(long i = 0; is_warming_up; i++){
-+        proc.tick();
-+        Stats::curTick++;
-+        if (i % cpu_tick == (cpu_tick - 1))
-+            for (int j = 0; j < mem_tick; j++)
-+                memory.tick();
-+
-+        is_warming_up = false;
-+        for(int c = 0; c < proc.cores.size(); c++){
-+            if(proc.cores[c]->get_insts() < warmup_insts)
-+                is_warming_up = true;
-+        }
-+
-+        if (is_warming_up && proc.has_reached_limit()) {
-+            printf("WARNING: The end of the input trace file was reached during warmup. "
-+                    "Consider changing warmup_insts in the config file. \n");
-+            break;
-+        }
-+
-+    }
-+
-+    warmup_complete = true;
-+    printf("Warmup complete! Resetting stats...\n");
-+    Stats::reset_stats();
-+    proc.reset_stats();
-+    assert(proc.get_insts() == 0);
-+
-+    printf("Starting the simulation...\n");
-+
-+    int tick_mult = cpu_tick * mem_tick;
-+    for (long i = 0; ; i++) {
-+        if (((i % tick_mult) % mem_tick) == 0) { // When the CPU is ticked cpu_tick times,
-+                                                 // the memory controller should be ticked mem_tick times
-+            proc.tick();
-+            Stats::curTick++; // processor clock, global, for Statistics
-+
-+            if (configs.calc_weighted_speedup()) {
-+                if (proc.has_reached_limit()) {
-+                    break;
-+                }
-+            } else {
-+                if (configs.is_early_exit()) {
-+                    if (proc.finished())
-+                    break;
-+                } else {
-+                if (proc.finished() && (memory.pending_requests() == 0))
-+                    break;
-+                }
-+            }
-+        }
-+
-+        if (((i % tick_mult) % cpu_tick) == 0) // TODO_hasan: Better if the processor ticks the memory controller
-+            memory.tick();
-+
-+    }
-+    // This a workaround for statistics set only initially lost in the end
-+    memory.finish();
-+    Stats::statlist.printall();
-+}
-+
-+template<typename T>
-+void start_run(const Config& configs, T* spec, const vector<const char*>& files) {
-+  // initiate controller and memory
-+  int C = configs.get_channels(), R = configs.get_ranks();
-+  // Check and Set channel, rank number
-+  spec->set_channel_number(C);
-+  spec->set_rank_number(R);
-+  std::vector<Controller<T>*> ctrls;
-+  for (int c = 0 ; c < C ; c++) {
-+    DRAM<T>* channel = new DRAM<T>(spec, T::Level::Channel);
-+    channel->id = c;
-+    channel->regStats("");
-+    Controller<T>* ctrl = new Controller<T>(configs, channel, false); // gagan : enable_debug set to false
-+    ctrls.push_back(ctrl);
-+  }
-+  Memory<T, Controller> memory(configs, ctrls);
-+
-+  assert(files.size() != 0);
-+  if (configs["trace_type"] == "CPU") {
-+    run_cputrace(configs, memory, files);
-+  } else if (configs["trace_type"] == "DRAM") {
-+    run_dramtrace(configs, memory, files[0]);
-+  }
-+}
-+
-+int main(int argc, const char *argv[])
-+{
-+    if (argc < 2) {
-+        printf("Usage: %s <configs-file> --mode=cpu,dram [--stats <filename>] <trace-filename1> <trace-filename2>\n"
-+            "Example: %s ramulator-configs.cfg --mode=cpu cpu.trace cpu.trace\n", argv[0], argv[0]);
-+        return 0;
-+    }
-+
-+    Config configs(argv[1]);
-+
-+    const std::string& standard = configs["standard"];
-+    assert(standard != "" || "DRAM standard should be specified.");
-+
-+    const char *trace_type = strstr(argv[2], "=");
-+    trace_type++;
-+    if (strcmp(trace_type, "cpu") == 0) {
-+      configs.add("trace_type", "CPU");
-+    } else if (strcmp(trace_type, "dram") == 0) {
-+      configs.add("trace_type", "DRAM");
-+    } else {
-+      printf("invalid trace type: %s\n", trace_type);
-+      assert(false);
-+    }
-+
-+    int trace_start = 3;
-+    string stats_out;
-+    if (strcmp(argv[trace_start], "--stats") == 0) {
-+      Stats::statlist.output(argv[trace_start+1]);
-+      stats_out = argv[trace_start+1];
-+      trace_start += 2;
-+    } else {
-+      Stats::statlist.output(standard+".stats");
-+      stats_out = standard + string(".stats");
-+    }
-+
-+    // A separate file defines mapping for easy config.
-+    if (strcmp(argv[trace_start], "--mapping") == 0) {
-+      configs.add("mapping", argv[trace_start+1]);
-+      trace_start += 2;
-+    } else {
-+      configs.add("mapping", "defaultmapping");
-+    }
-+
-+    std::vector<const char*> files(&argv[trace_start], &argv[argc]);
-+    configs.set_core_num(argc - trace_start);
-+
-+    if (standard == "DDR3") {
-+      DDR3* ddr3 = new DDR3(configs["org"], configs["speed"]);
-+      start_run(configs, ddr3, files);
-+    } else if (standard == "DDR4") {
-+      DDR4* ddr4 = new DDR4(configs["org"], configs["speed"]);
-+      start_run(configs, ddr4, files);
-+    } else if (standard == "SALP-MASA") {
-+      SALP* salp8 = new SALP(configs["org"], configs["speed"], "SALP-MASA", configs.get_subarrays());
-+      start_run(configs, salp8, files);
-+    } else if (standard == "LPDDR3") {
-+      LPDDR3* lpddr3 = new LPDDR3(configs["org"], configs["speed"]);
-+      start_run(configs, lpddr3, files);
-+    } else if (standard == "LPDDR4") {
-+      // total cap: 2GB, 1/2 of others
-+      LPDDR4* lpddr4 = new LPDDR4(configs["org"], configs["speed"]);
-+      start_run(configs, lpddr4, files);
-+    } else if (standard == "GDDR5") {
-+      GDDR5* gddr5 = new GDDR5(configs["org"], configs["speed"]);
-+      start_run(configs, gddr5, files);
-+    } else if (standard == "HBM") {
-+      HBM* hbm = new HBM(configs["org"], configs["speed"]);
-+      start_run(configs, hbm, files);
-+    } else if (standard == "WideIO") {
-+      // total cap: 1GB, 1/4 of others
-+      WideIO* wio = new WideIO(configs["org"], configs["speed"]);
-+      start_run(configs, wio, files);
-+    } else if (standard == "WideIO2") {
-+      // total cap: 2GB, 1/2 of others
-+      WideIO2* wio2 = new WideIO2(configs["org"], configs["speed"], configs.get_channels());
-+      wio2->channel_width *= 2;
-+      start_run(configs, wio2, files);
-+    } else if (standard == "STTMRAM") {
-+      STTMRAM* sttmram = new STTMRAM(configs["org"], configs["speed"]);
-+      start_run(configs, sttmram, files);
-+    } else if (standard == "PCM") {
-+      PCM* pcm = new PCM(configs["org"], configs["speed"]);
-+      start_run(configs, pcm, files);
-+    }
-+    // Various refresh mechanisms
-+      else if (standard == "DSARP") {
-+      DSARP* dsddr3_dsarp = new DSARP(configs["org"], configs["speed"], DSARP::Type::DSARP, configs.get_subarrays());
-+      start_run(configs, dsddr3_dsarp, files);
-+    } else if (standard == "ALDRAM") {
-+      ALDRAM* aldram = new ALDRAM(configs["org"], configs["speed"]);
-+      start_run(configs, aldram, files);
-+    } else if (standard == "TLDRAM") {
-+      TLDRAM* tldram = new TLDRAM(configs["org"], configs["speed"], configs.get_subarrays());
-+      start_run(configs, tldram, files);
-+    }
-+
-+    printf("Simulation done. Statistics written to %s\n", stats_out.c_str());
-+
-+    return 0;
-+}
-diff --git a/ext/ramulator/Ramulator/src/Memory.h b/ext/ramulator/Ramulator/src/Memory.h
-new file mode 100644
-index 0000000..9fefa03
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Memory.h
-@@ -0,0 +1,870 @@
-+#ifndef __MEMORY_H
-+#define __MEMORY_H
-+
-+#include "Config.h"
-+#include "DRAM.h"
-+#include "Request.h"
-+#include "Controller.h"
-+#include "SpeedyController.h"
-+#include "Statistics.h"
-+#include "GDDR5.h"
-+#include "HBM.h"
-+#include "LPDDR3.h"
-+#include "LPDDR4.h"
-+#include "WideIO2.h"
-+#include "DSARP.h"
-+#include <vector>
-+#include <functional>
-+#include <cmath>
-+#include <cassert>
-+#include <tuple>
-+
-+using namespace std;
-+
-+typedef vector<unsigned int> MapSrcVector;
-+typedef map<unsigned int, MapSrcVector > MapSchemeEntry;
-+typedef map<unsigned int, MapSchemeEntry> MapScheme;
-+
-+namespace ramulator
-+{
-+
-+class MemoryBase{
-+public:
-+    MemoryBase() {}
-+    virtual ~MemoryBase() {}
-+    virtual double clk_ns() = 0;
-+    virtual void tick() = 0;
-+    virtual bool send(Request req) = 0;
-+    virtual int pending_requests() = 0;
-+    virtual void finish(void) = 0;
-+    virtual long page_allocator(long addr, int coreid) = 0;
-+    virtual void record_core(int coreid) = 0;
-+    virtual void set_high_writeq_watermark(const float watermark) = 0;
-+    virtual void set_low_writeq_watermark(const float watermark) = 0;
-+};
-+
-+template <class T, template<typename> class Controller = Controller >
-+class Memory : public MemoryBase
-+{
-+protected:
-+  ScalarStat dram_capacity;
-+  ScalarStat num_dram_cycles;
-+  ScalarStat num_incoming_requests;
-+  VectorStat num_read_requests;
-+  VectorStat num_write_requests;
-+  ScalarStat ramulator_active_cycles;
-+  VectorStat incoming_requests_per_channel;
-+  VectorStat incoming_read_reqs_per_channel;
-+  // gagan : demand and prefetch read reqs
-+  VectorStat incoming_demand_read_reqs_per_channel;
-+  VectorStat incoming_prefetch_read_reqs_per_channel;
-+  VectorStat prefetch_to_demand_read_promotion;
-+
-+  ScalarStat physical_page_replacement;
-+  ScalarStat maximum_bandwidth;
-+  ScalarStat in_queue_req_num_sum;
-+  ScalarStat in_queue_read_req_num_sum;
-+  ScalarStat in_queue_write_req_num_sum;
-+  ScalarStat in_queue_req_num_avg;
-+  ScalarStat in_queue_read_req_num_avg;
-+  ScalarStat in_queue_write_req_num_avg;
-+
-+#ifndef INTEGRATED_WITH_GEM5
-+  VectorStat record_read_requests;
-+  VectorStat record_write_requests;
-+#endif
-+
-+  long max_address;
-+  MapScheme mapping_scheme;
-+  
-+public:
-+    enum class Type {
-+        ChRaBaRoCo,
-+        RoBaRaCoCh,
-+        RoRaBaChCo,//daz3
-+        RoRaBaChCo_XOR,
-+        RoRaBaChCo_XOR_chint,
-+	intel_quad_chan,
-+        RoRaBaChCo_XOR_new,	  
-+        MAX,
-+	  } type = Type::RoRaBaChCo;
-+    //daz3
-+    // } type = Type::RoBaRaCoCh;
-+
-+    enum class Translation {
-+      None,
-+      Random,
-+      MAX,
-+    } translation = Translation::None;
-+
-+    std::map<string, Translation> name_to_translation = {
-+      {"None", Translation::None},
-+      {"Random", Translation::Random},
-+    };
-+
-+    vector<int> free_physical_pages;
-+    long free_physical_pages_remaining;
-+    map<pair<int, long>, long> page_translation;
-+
-+    vector<Controller<T>*> ctrls;
-+    T * spec;
-+    vector<int> addr_bits;
-+    string mapping_file;
-+    bool use_mapping_file;
-+    bool dump_mapping;
-+    
-+    int tx_bits;
-+
-+    Memory(const Config& configs, vector<Controller<T>*> ctrls)
-+        : ctrls(ctrls),
-+          spec(ctrls[0]->channel->spec),
-+          addr_bits(int(T::Level::MAX))
-+    {
-+        // make sure 2^N channels/ranks
-+        // TODO support channel number that is not powers of 2
-+        int *sz = spec->org_entry.count;
-+        assert((sz[0] & (sz[0] - 1)) == 0);
-+        assert((sz[1] & (sz[1] - 1)) == 0);
-+        // validate size of one transaction
-+        int tx = (spec->prefetch_size * spec->channel_width / 8);
-+        tx_bits = calc_log2(tx);
-+        assert((1<<tx_bits) == tx);
-+        
-+        // Parsing mapping file and initialize mapping table
-+        use_mapping_file = false;
-+        dump_mapping = false;
-+        if (spec->standard_name.substr(0, 4) == "DDR3"){
-+            if (configs["mapping"] != "defaultmapping"){
-+              init_mapping_with_file(configs["mapping"]);
-+              // dump_mapping = true;
-+              use_mapping_file = true;
-+            }
-+        }
-+        // If hi address bits will not be assigned to Rows
-+        // then the chips must not be LPDDRx 6Gb, 12Gb etc.
-+        if (type != Type::RoBaRaCoCh && spec->standard_name.substr(0, 5) == "LPDDR")
-+            assert((sz[int(T::Level::Row)] & (sz[int(T::Level::Row)] - 1)) == 0);
-+
-+        max_address = spec->channel_width / 8;
-+
-+        for (unsigned int lev = 0; lev < addr_bits.size(); lev++) {
-+          addr_bits[lev] = calc_log2(sz[lev]);
-+            max_address *= sz[lev];
-+        }
-+
-+        addr_bits[int(T::Level::MAX) - 1] -= calc_log2(spec->prefetch_size);
-+
-+        // Initiating translation
-+        if (configs.contains("translation")) {
-+          translation = name_to_translation[configs["translation"]];
-+        }
-+        if (translation != Translation::None) {
-+          // construct a list of available pages
-+          // TODO: this should not assume a 4KB page!
-+          free_physical_pages_remaining = max_address >> 12;
-+
-+          free_physical_pages.resize(free_physical_pages_remaining, -1);
-+        }
-+
-+        dram_capacity
-+            .name("dram_capacity")
-+            .desc("Number of bytes in simulated DRAM")
-+            .precision(0)
-+            ;
-+        dram_capacity = max_address;
-+
-+        num_dram_cycles
-+            .name("dram_cycles")
-+            .desc("Number of DRAM cycles simulated")
-+            .precision(0)
-+            ;
-+        num_incoming_requests
-+            .name("incoming_requests")
-+            .desc("Number of incoming requests to DRAM")
-+            .precision(0)
-+            ;
-+        num_read_requests
-+            .init(configs.get_core_num())
-+            .name("read_requests")
-+            .desc("Number of incoming read requests to DRAM per core")
-+            .precision(0)
-+            ;
-+        num_write_requests
-+            .init(configs.get_core_num())
-+            .name("write_requests")
-+            .desc("Number of incoming write requests to DRAM per core")
-+            .precision(0)
-+            ;
-+        incoming_requests_per_channel
-+            .init(sz[int(T::Level::Channel)])
-+            .name("incoming_requests_per_channel")
-+            .desc("Number of incoming requests to each DRAM channel")
-+            ;
-+        incoming_read_reqs_per_channel
-+            .init(sz[int(T::Level::Channel)])
-+            .name("incoming_read_reqs_per_channel")
-+            .desc("Number of incoming read requests to each DRAM channel")
-+            ;
-+	// gagan : demand read reqs
-+	incoming_demand_read_reqs_per_channel
-+            .init(sz[int(T::Level::Channel)])
-+            .name("incoming_demand_read_reqs_per_channel")
-+            .desc("Number of incoming demand read requests to each DRAM channel")
-+            ;
-+	// gagan : prefetch read reqs
-+	incoming_prefetch_read_reqs_per_channel
-+            .init(sz[int(T::Level::Channel)])
-+            .name("incoming_prefetch_read_reqs_per_channel")
-+            .desc("Number of incoming prefetch read requests to each DRAM channel")
-+            ;
-+	// gagab : prefecth req to demand req promotion
-+	prefetch_to_demand_read_promotion
-+            .init(sz[int(T::Level::Channel)])
-+            .name("prefetch_to_demand_read_promotion")
-+            .desc("Number of incoming prefetch read requests promoted to demand request")
-+            ;
-+        ramulator_active_cycles
-+            .name("ramulator_active_cycles")
-+            .desc("The total number of cycles that the DRAM part is active (serving R/W)")
-+            .precision(0)
-+            ;
-+        physical_page_replacement
-+            .name("physical_page_replacement")
-+            .desc("The number of times that physical page replacement happens.")
-+            .precision(0)
-+            ;
-+        maximum_bandwidth
-+            .name("maximum_bandwidth")
-+            .desc("The theoretical maximum bandwidth (Bps)")
-+            .precision(0)
-+            ;
-+        in_queue_req_num_sum
-+            .name("in_queue_req_num_sum")
-+            .desc("Sum of read/write queue length")
-+            .precision(0)
-+            ;
-+        in_queue_read_req_num_sum
-+            .name("in_queue_read_req_num_sum")
-+            .desc("Sum of read queue length")
-+            .precision(0)
-+            ;
-+        in_queue_write_req_num_sum
-+            .name("in_queue_write_req_num_sum")
-+            .desc("Sum of write queue length")
-+            .precision(0)
-+            ;
-+        in_queue_req_num_avg
-+            .name("in_queue_req_num_avg")
-+            .desc("Average of read/write queue length per memory cycle")
-+            .precision(6)
-+            ;
-+        in_queue_read_req_num_avg
-+            .name("in_queue_read_req_num_avg")
-+            .desc("Average of read queue length per memory cycle")
-+            .precision(6)
-+            ;
-+        in_queue_write_req_num_avg
-+            .name("in_queue_write_req_num_avg")
-+            .desc("Average of write queue length per memory cycle")
-+            .precision(6)
-+            ;
-+#ifndef INTEGRATED_WITH_GEM5
-+        record_read_requests
-+            .init(configs.get_core_num())
-+            .name("record_read_requests")
-+            .desc("record read requests for this core when it reaches request limit or to the end")
-+            ;
-+
-+        record_write_requests
-+            .init(configs.get_core_num())
-+            .name("record_write_requests")
-+            .desc("record write requests for this core when it reaches request limit or to the end")
-+            ;
-+#endif
-+
-+    }
-+
-+    ~Memory()
-+    {
-+        for (auto ctrl: ctrls)
-+            delete ctrl;
-+        delete spec;
-+    }
-+
-+    double clk_ns()
-+    {
-+        return spec->speed_entry.tCK;
-+    }
-+
-+    void record_core(int coreid) {
-+#ifndef INTEGRATED_WITH_GEM5
-+      record_read_requests[coreid] = num_read_requests[coreid];
-+      record_write_requests[coreid] = num_write_requests[coreid];
-+#endif
-+      for (auto ctrl : ctrls) {
-+        ctrl->record_core(coreid);
-+      }
-+    }
-+
-+    void tick()
-+    {
-+        ++num_dram_cycles;
-+        int cur_que_req_num = 0;
-+        int cur_que_readreq_num = 0;
-+        int cur_que_writereq_num = 0;
-+        for (auto ctrl : ctrls) {
-+          cur_que_req_num += ctrl->readq.size() + ctrl->writeq.size() + ctrl->pending.size();
-+          cur_que_readreq_num += ctrl->readq.size() + ctrl->pending.size();
-+          cur_que_writereq_num += ctrl->writeq.size();
-+        }
-+        in_queue_req_num_sum += cur_que_req_num;
-+        in_queue_read_req_num_sum += cur_que_readreq_num;
-+        in_queue_write_req_num_sum += cur_que_writereq_num;
-+
-+        bool is_active = false;
-+        for (auto ctrl : ctrls) {
-+          is_active = is_active || ctrl->is_active();
-+          ctrl->tick();
-+        }
-+        if (is_active) {
-+          ramulator_active_cycles++;
-+        }
-+    }
-+
-+bool send(Request req)
-+    {
-+      bool promote = false;
-+        req.addr_vec.resize(addr_bits.size());
-+        long addr = req.addr;
-+        int coreid = req.coreid;
-+
-+	int column, channel, bank, bankgroup, rank, row, tempA, tempB, channel_mask, channel_mask_temp;
-+	long addr_copy;
-+
-+        // Each transaction size is 2^tx_bits, so first clear the lowest tx_bits bits
-+        clear_lower_bits(addr, tx_bits);
-+
-+        if (use_mapping_file){
-+            apply_mapping(addr, req.addr_vec);
-+        }
-+        else {
-+            switch(int(type)){
-+                case int(Type::ChRaBaRoCo):
-+                    for (int i = addr_bits.size() - 1; i >= 0; i--)
-+                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-+                    break;
-+                case int(Type::RoBaRaCoCh):
-+                    req.addr_vec[0] = slice_lower_bits(addr, addr_bits[0]);
-+                    req.addr_vec[addr_bits.size() - 1] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-+                    for (int i = 1; i <= int(T::Level::Row); i++)
-+                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-+                    break;
-+                // daz3
-+                case int(Type::RoRaBaChCo):
-+                    req.addr_vec[addr_bits.size() - 1] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-+                    req.addr_vec[0] = slice_lower_bits(addr, addr_bits[0]);
-+                    for (int i = 2; i < int(T::Level::Row); i++)
-+                    {
-+                        req.addr_vec[i] = slice_lower_bits(addr, addr_bits[i]);
-+                    }
-+                    req.addr_vec[1] = slice_lower_bits(addr, addr_bits[1]);
-+                    req.addr_vec[addr_bits.size() - 2] = slice_lower_bits(addr, addr_bits[addr_bits.size() - 2]);
-+                    break;
-+	    case int(Type::RoRaBaChCo_XOR):
-+		//std::cout << std::hex << "Addr: " << addr << "\n";
-+		//std::cout << "bitwidths: ";
-+		//for(int i = 0; i < addr_bits.size(); ++i)
-+		//  std::cout << std::dec << addr_bits[i] << " ";
-+
-+		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-+		channel = slice_lower_bits(addr, addr_bits[0]);
-+		bank = slice_lower_bits(addr, addr_bits[3]);
-+		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-+		rank = slice_lower_bits(addr, addr_bits[1]);
-+		row = slice_lower_bits(addr, addr_bits[4]);
-+
-+		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-+		
-+		tempA = row & ((1 << addr_bits[2]) - 1);
-+		tempB = (row >> 2) & ((1 << addr_bits[3]) - 1);
-+
-+		bankgroup = bankgroup ^ tempA;
-+		bank = bank ^ tempB;
-+
-+		req.addr_vec[0] = channel;
-+		req.addr_vec[1] = rank;
-+		req.addr_vec[2] = bankgroup;
-+		req.addr_vec[3] = bank;
-+		req.addr_vec[4] = row;
-+		req.addr_vec[5] = column;
-+
-+		//std::cout << "address mapping:\n";
-+		//for(int i = 0; i < 6; ++i)
-+		//  std::cout << std::dec << req.addr_vec[i] << "\n";
-+		//std::cout << "\n";
-+		break;
-+	    case int(Type::RoRaBaChCo_XOR_chint):
-+		/*
-+		std::cout << std::hex << "Addr: " << addr << "\n";
-+		std::cout << "bitwidths: ";
-+		for(int i = 0; i < addr_bits.size(); ++i)
-+		  std::cout << std::dec << addr_bits[i] << " ";
-+		std::cout << "\n";
-+		*/
-+		
-+		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-+		channel = slice_lower_bits(addr, addr_bits[0]);
-+		bank = slice_lower_bits(addr, addr_bits[3]);
-+		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-+		rank = slice_lower_bits(addr, addr_bits[1]);
-+		row = slice_lower_bits(addr, addr_bits[4]);
-+
-+		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-+		
-+		tempA = row & ((1 << addr_bits[2]) - 1);
-+		tempB = (row >> 2) & ((1 << addr_bits[3]) - 1);
-+
-+		bankgroup = bankgroup ^ tempA;
-+		bank = bank ^ tempB;
-+
-+		channel_mask_temp = column;
-+		//std::cout << "channel_mask_temp: " << channel_mask_temp << "\n";
-+		channel_mask_temp >>= (addr_bits[addr_bits.size() - 1] - addr_bits[0]);
-+		//std::cout << "channel_mask_temp: " << channel_mask_temp << "\n";
-+		channel_mask = channel_mask_temp & ((1 << addr_bits[0]) - 1);
-+		//std::cout << "channel_mask: " << channel_mask << "\n";
-+
-+		channel = channel_mask;
-+
-+		req.addr_vec[0] = channel;
-+		req.addr_vec[1] = rank;
-+		req.addr_vec[2] = bankgroup;
-+		req.addr_vec[3] = bank;
-+		req.addr_vec[4] = row;
-+		req.addr_vec[5] = column;
-+
-+		/*
-+		std::cout << "address mapping:\n";
-+		for(int i = 0; i < 6; ++i)
-+		  std::cout << std::dec << req.addr_vec[i] << "\n";
-+		std::cout << "\n";
-+		*/
-+		break;
-+	    case int(Type::intel_quad_chan):
-+		
-+		/*
-+		std::cout << std::hex << "Addr: " << addr << "\n";
-+		std::cout << "bitwidths: ";
-+		for(int i = 0; i < addr_bits.size(); ++i)
-+		  std::cout << std::dec << addr_bits[i] << " ";
-+		std::cout << "\n";
-+		*/
-+		
-+		addr_copy = addr;
-+		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-+		channel = get_bit_at(addr_copy, 8) ^ get_bit_at(addr_copy, 13) ^ get_bit_at(addr_copy, 15) ^ get_bit_at(addr_copy, 17) ^ get_bit_at(addr_copy, 19) ^ get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 23) ^ get_bit_at(addr_copy, 25)  ^ get_bit_at(addr_copy, 27);
-+		channel = (channel << 1) | (get_bit_at(addr_copy, 7) ^ get_bit_at(addr_copy, 12) ^ get_bit_at(addr_copy, 14) ^ get_bit_at(addr_copy, 16) ^ get_bit_at(addr_copy, 18) ^ get_bit_at(addr_copy, 20) ^ get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 24)  ^ get_bit_at(addr_copy, 26));
-+		// row = [+23][19 to 17]
-+		slice_lower_bits(addr, 10);
-+		// tempA : [19 to 17]
-+		tempA = slice_lower_bits(addr, 3);
-+		// tempB : use 2 bits for banks and 1 bit for ranks
-+		tempB = slice_lower_bits(addr, 3);
-+		row = slice_lower_bits(addr, addr_bits[4] - 3);
-+		row = (row << 3) | tempA;
-+
-+		// rank
-+		if(addr_bits[1] == 1)
-+		  {
-+		    rank = get_bit_at(addr_copy, 15);
-+		  }
-+		else if(addr_bits[1] == 2)
-+		  {
-+		    rank = (get_bit_at(tempB, 0) << 1) | get_bit_at(addr_copy, 15);
-+		  }
-+		else
-+		  {
-+		    std::cout << "Rank bits > 2. Not supported.\n";
-+		    exit(0);
-+		  }
-+
-+		// bank
-+		if(addr_bits[3] == 2)
-+		  {
-+		    bank = ((get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 26)) << 1) | (get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 25));
-+		  }
-+		else if(addr_bits[3] == 4)
-+		  {
-+		    bank = get_bit_at(tempB, 1);
-+		    bank = (bank << 1) | get_bit_at(tempB, 2);
-+		    bank = (bank << 2) | ((get_bit_at(addr_copy, 22) ^ get_bit_at(addr_copy, 26)) << 1) | (get_bit_at(addr_copy, 21) ^ get_bit_at(addr_copy, 25));
-+		  }
-+		else
-+		  {
-+		    std::cout << "Bank bits != {2, 4}. Not supported.\n";
-+		    exit(0);
-+		  }
-+
-+		// bankgroup
-+		if(addr_bits[2] == 2)
-+		  {
-+		    bankgroup = ((get_bit_at(addr_copy, 24) ^ get_bit_at(addr_copy, 20)) << 1) | (get_bit_at(addr_copy, 23) ^ get_bit_at(addr_copy, 26));
-+		  }
-+		else
-+		  {
-+		    std::cout << "Bankgroup bits != 2. Not supported.\n";
-+		    exit(0);
-+		  }
-+
-+		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-+		
-+		req.addr_vec[0] = channel;
-+		req.addr_vec[1] = rank;
-+		req.addr_vec[2] = bankgroup;
-+		req.addr_vec[3] = bank;
-+		req.addr_vec[4] = row;
-+		req.addr_vec[5] = column;
-+
-+		/*
-+		std::cout << "address mapping:\n";
-+		for(int i = 0; i < 6; ++i)
-+		  std::cout << std::dec << req.addr_vec[i] << "\n";
-+		std::cout << "\n";
-+		*/
-+		
-+		break;
-+
-+	    case int(Type::RoRaBaChCo_XOR_new):
-+		/*
-+		std::cout << std::hex << "Addr: " << addr << "\n";
-+		std::cout << "bitwidths: ";
-+		for(int i = 0; i < addr_bits.size(); ++i)
-+		  std::cout << std::dec << addr_bits[i] << " ";
-+		*/
-+
-+		column = slice_lower_bits(addr, addr_bits[addr_bits.size() - 1]);
-+		channel = slice_lower_bits(addr, addr_bits[0]);
-+		rank = slice_lower_bits(addr, addr_bits[1]);
-+		bank = slice_lower_bits(addr, addr_bits[3]);
-+		bankgroup = slice_lower_bits(addr, addr_bits[2]);
-+		row = slice_lower_bits(addr, addr_bits[4]);
-+
-+		//std::cout << std::dec <<  "column: " << column << ", chan: " << channel << ", bank: " << bank << ", bankgroup: " << bankgroup << ", rank: " << rank << ", row: " << row << "\n";
-+		
-+		tempA = row & ((1 << addr_bits[3]) - 1);
-+		tempB = (row >> addr_bits[3]) & ((1 << addr_bits[2]) - 1);
-+
-+		bank = bank ^ tempA;
-+		bankgroup = bankgroup ^ tempB;
-+
-+		req.addr_vec[0] = channel;
-+		req.addr_vec[1] = rank;
-+		req.addr_vec[2] = bankgroup;
-+		req.addr_vec[3] = bank;
-+		req.addr_vec[4] = row;
-+		req.addr_vec[5] = column;
-+
-+		/*
-+		std::cout << "address mapping:\n";
-+		for(int i = 0; i < 6; ++i)
-+		  std::cout << std::dec << req.addr_vec[i] << "\n";
-+		std::cout << "\n";
-+		*/
-+		break;
-+                default:
-+                    assert(false);
-+            }
-+        }
-+
-+	if(promote == false)
-+	  {
-+	    if(ctrls[req.addr_vec[0]]->enqueue(req)) {
-+	      // tally stats here to avoid double counting for requests that aren't enqueued
-+	      ++num_incoming_requests;
-+	      if (req.type == Request::Type::READ) {
-+		++num_read_requests[coreid];
-+		++incoming_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-+		if(req.is_prefetch)
-+		  ++incoming_prefetch_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-+		else
-+		  ++incoming_demand_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-+	      }
-+	      if (req.type == Request::Type::WRITE) {
-+		++num_write_requests[coreid];
-+	      }
-+	      ++incoming_requests_per_channel[req.addr_vec[int(T::Level::Channel)]];
-+	      return true;
-+	    }
-+	  }
-+	else
-+	  {
-+	    ctrls[req.addr_vec[0]]->promote(req);
-+	    --incoming_prefetch_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-+	    ++incoming_demand_read_reqs_per_channel[req.addr_vec[int(T::Level::Channel)]];
-+	    ++prefetch_to_demand_read_promotion[req.addr_vec[int(T::Level::Channel)]];
-+	    return true;
-+	  }
-+
-+        return false;
-+    }
-+    
-+    void init_mapping_with_file(string filename){
-+        ifstream file(filename);
-+        assert(file.good() && "Bad mapping file");
-+        // possible line types are:
-+        // 0. Empty line
-+        // 1. Direct bit assignment   : component N   = x
-+        // 2. Direct range assignment : component N:M = x:y
-+        // 3. XOR bit assignment      : component N   = x y z ...
-+        // 4. Comment line            : # comment here
-+        string line;
-+        char delim[] = " \t";
-+        while (getline(file, line)) {
-+            short capture_flags = 0;
-+            int level = -1;
-+            int target_bit = -1, target_bit2 = -1;
-+            int source_bit = -1, source_bit2 = -1;
-+            // cout << "Processing: " << line << endl;
-+            bool is_range = false;
-+            while (true) { // process next word
-+                size_t start = line.find_first_not_of(delim);
-+                if (start == string::npos) // no more words
-+                    break;
-+                size_t end = line.find_first_of(delim, start);
-+                string word = line.substr(start, end - start);
-+                
-+                if (word.at(0) == '#')// starting a comment
-+                    break;
-+                
-+                size_t col_index;
-+                int source_min, target_min, target_max;
-+                switch (capture_flags){
-+                    case 0: // capturing the component name
-+                        // fetch component level from channel spec
-+                        for (int i = 0; i < int(T::Level::MAX); i++)
-+                            if (word.find(T::level_str[i]) != string::npos) {
-+                                level = i;
-+                                capture_flags ++;
-+                            }
-+                        break;
-+
-+                    case 1: // capturing target bit(s)
-+                        col_index = word.find(":");
-+                        if ( col_index != string::npos ){
-+                            target_bit2 = stoi(word.substr(col_index+1));
-+                            word = word.substr(0,col_index);
-+                            is_range = true;
-+                        }
-+                        target_bit = stoi(word);
-+                        capture_flags ++;
-+                        break;
-+
-+                    case 2: //this should be the delimiter
-+                        assert(word.find("=") != string::npos);
-+                        capture_flags ++;
-+                        break;
-+
-+                    case 3:
-+                        if (is_range){
-+                            col_index = word.find(":");
-+                            source_bit  = stoi(word.substr(0,col_index));
-+                            source_bit2 = stoi(word.substr(col_index+1));
-+                            assert(source_bit2 - source_bit == target_bit2 - target_bit);
-+                            source_min = min(source_bit, source_bit2);
-+                            target_min = min(target_bit, target_bit2);
-+                            target_max = max(target_bit, target_bit2);
-+                            while (target_min <= target_max){
-+                                mapping_scheme[level][target_min].push_back(source_min);
-+                                // cout << target_min << " <- " << source_min << endl;
-+                                source_min ++;
-+                                target_min ++;
-+                            }
-+                        }
-+                        else {
-+                            source_bit = stoi(word);
-+                            mapping_scheme[level][target_bit].push_back(source_bit);
-+                        }
-+                }
-+                if (end == string::npos) { // this is the last word
-+                    break;
-+                }
-+                line = line.substr(end);
-+            }
-+        }
-+        if (dump_mapping)
-+            dump_mapping_scheme();
-+    }
-+    
-+    void dump_mapping_scheme(){
-+        cout << "Mapping Scheme: " << endl;
-+        for (MapScheme::iterator mapit = mapping_scheme.begin(); mapit != mapping_scheme.end(); mapit++)
-+        {
-+            int level = mapit->first;
-+            for (MapSchemeEntry::iterator entit = mapit->second.begin(); entit != mapit->second.end(); entit++){
-+                cout << T::level_str[level] << "[" << entit->first << "] := ";
-+                cout << "PhysicalAddress[" << *(entit->second.begin()) << "]";
-+                entit->second.erase(entit->second.begin());
-+                for (MapSrcVector::iterator it = entit->second.begin() ; it != entit->second.end(); it ++)
-+                    cout << " xor PhysicalAddress[" << *it << "]";
-+                cout << endl;
-+            }
-+        }
-+    }
-+    
-+    void apply_mapping(long addr, std::vector<int>& addr_vec){
-+        int *sz = spec->org_entry.count;
-+        int addr_total_bits = sizeof(addr_vec)*8;
-+        int addr_bits [int(T::Level::MAX)];
-+        for (int i = 0 ; i < int(T::Level::MAX) ; i ++)
-+        {
-+            if ( i != int(T::Level::Row))
-+            {
-+                addr_bits[i] = calc_log2(sz[i]);
-+                addr_total_bits -= addr_bits[i];
-+            }
-+        }
-+        // Row address is an integer.
-+        addr_bits[int(T::Level::Row)] = min((int)sizeof(int)*8, max(addr_total_bits, calc_log2(sz[int(T::Level::Row)])));
-+
-+        // printf("Address: %lx => ",addr);
-+        for (unsigned int lvl = 0; lvl < int(T::Level::MAX); lvl++)
-+        {
-+            unsigned int lvl_bits = addr_bits[lvl];
-+            addr_vec[lvl] = 0;
-+            for (unsigned int bitindex = 0 ; bitindex < lvl_bits ; bitindex++){
-+                bool bitvalue = false;
-+                for (MapSrcVector::iterator it = mapping_scheme[lvl][bitindex].begin() ;
-+                    it != mapping_scheme[lvl][bitindex].end(); it ++)
-+                {
-+                    bitvalue = bitvalue xor get_bit_at(addr, *it);
-+                }
-+                addr_vec[lvl] |= (bitvalue << bitindex);
-+            }
-+            // printf("%s: %x, ",T::level_str[lvl].c_str(),addr_vec[lvl]);
-+        }
-+        // printf("\n");
-+    }
-+
-+    int pending_requests()
-+    {
-+        int reqs = 0;
-+        for (auto ctrl: ctrls)
-+            reqs += ctrl->readq.size() + ctrl->writeq.size() + ctrl->otherq.size() + ctrl->actq.size() + ctrl->pending.size();
-+        return reqs;
-+    }
-+
-+    void set_high_writeq_watermark(const float watermark) {
-+        for (auto ctrl: ctrls)
-+            ctrl->set_high_writeq_watermark(watermark);
-+    }
-+
-+    void set_low_writeq_watermark(const float watermark) {
-+    for (auto ctrl: ctrls)
-+        ctrl->set_low_writeq_watermark(watermark);
-+    }
-+
-+    void finish(void) {
-+      dram_capacity = max_address;
-+      int *sz = spec->org_entry.count;
-+      maximum_bandwidth = spec->speed_entry.rate * 1e6 * spec->channel_width * sz[int(T::Level::Channel)] / 8;
-+      long dram_cycles = num_dram_cycles.value();
-+      for (auto ctrl : ctrls) {
-+        long read_req = long(incoming_read_reqs_per_channel[ctrl->channel->id].value());
-+	long demand_read_req = long(incoming_demand_read_reqs_per_channel[ctrl->channel->id].value());
-+	long prefetch_read_req = long(incoming_prefetch_read_reqs_per_channel[ctrl->channel->id].value());
-+        ctrl->finish(read_req, demand_read_req, prefetch_read_req, dram_cycles);
-+      }
-+
-+      // finalize average queueing requests
-+      in_queue_req_num_avg = in_queue_req_num_sum.value() / dram_cycles;
-+      in_queue_read_req_num_avg = in_queue_read_req_num_sum.value() / dram_cycles;
-+      in_queue_write_req_num_avg = in_queue_write_req_num_sum.value() / dram_cycles;
-+    }
-+
-+    long page_allocator(long addr, int coreid) {
-+        long virtual_page_number = addr >> 12;
-+
-+        switch(int(translation)) {
-+            case int(Translation::None): {
-+              return addr;
-+            }
-+            case int(Translation::Random): {
-+                auto target = make_pair(coreid, virtual_page_number);
-+                if(page_translation.find(target) == page_translation.end()) {
-+                    // page doesn't exist, so assign a new page
-+                    // make sure there are physical pages left to be assigned
-+
-+                    // if physical page doesn't remain, replace a previous assigned
-+                    // physical page.
-+                    if (!free_physical_pages_remaining) {
-+                      physical_page_replacement++;
-+                      long phys_page_to_read = lrand() % free_physical_pages.size();
-+                      assert(free_physical_pages[phys_page_to_read] != -1);
-+                      page_translation[target] = phys_page_to_read;
-+                    } else {
-+                        // assign a new page
-+                        long phys_page_to_read = lrand() % free_physical_pages.size();
-+                        // if the randomly-selected page was already assigned
-+                        if(free_physical_pages[phys_page_to_read] != -1) {
-+                            long starting_page_of_search = phys_page_to_read;
-+
-+                            do {
-+                                // iterate through the list until we find a free page
-+                                // TODO: does this introduce serious non-randomness?
-+                                ++phys_page_to_read;
-+                                phys_page_to_read %= free_physical_pages.size();
-+                            }
-+                            while((phys_page_to_read != starting_page_of_search) && free_physical_pages[phys_page_to_read] != -1);
-+                        }
-+
-+                        assert(free_physical_pages[phys_page_to_read] == -1);
-+
-+                        page_translation[target] = phys_page_to_read;
-+                        free_physical_pages[phys_page_to_read] = coreid;
-+                        --free_physical_pages_remaining;
-+                    }
-+                }
-+
-+                // SAUGATA TODO: page size should not always be fixed to 4KB
-+                return (page_translation[target] << 12) | (addr & ((1 << 12) - 1));
-+            }
-+            default:
-+                assert(false);
-+        }
-+
-+    }
-+
-+private:
-+
-+    int calc_log2(int val){
-+        int n = 0;
-+        while ((val >>= 1))
-+            n ++;
-+        return n;
-+    }
-+    int slice_lower_bits(long& addr, int bits)
-+    {
-+        int lbits = addr & ((1<<bits) - 1);
-+        addr >>= bits;
-+        return lbits;
-+    }
-+    bool get_bit_at(long addr, int bit)
-+    {
-+        return (((addr >> bit) & 1) == 1);
-+    }
-+    void clear_lower_bits(long& addr, int bits)
-+    {
-+        addr >>= bits;
-+    }
-+    long lrand(void) {
-+        if(sizeof(int) < sizeof(long)) {
-+            return static_cast<long>(rand()) << (sizeof(int) * 8) | rand();
-+        }
-+
-+        return rand();
-+    }
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__MEMORY_H*/
-diff --git a/ext/ramulator/Ramulator/src/MemoryFactory.cpp b/ext/ramulator/Ramulator/src/MemoryFactory.cpp
-new file mode 100644
-index 0000000..2d2f774
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/MemoryFactory.cpp
-@@ -0,0 +1,80 @@
-+#include "MemoryFactory.h"
-+#include "LPDDR4.h"
-+#include "WideIO.h"
-+#include "WideIO2.h"
-+#include "HBM.h"
-+#include "SALP.h"
-+
-+using namespace ramulator;
-+
-+namespace ramulator
-+{
-+
-+template <>
-+void MemoryFactory<LPDDR4>::validate(int channels, int ranks, const Config& configs) {
-+    assert(channels >= 2 && "LPDDR4 requires 2, 4, 8 ... channels");
-+}
-+
-+template <>
-+void MemoryFactory<WideIO>::validate(int channels, int ranks, const Config& configs) {
-+    assert(channels == 4 && "WideIO comes with 4 channels");
-+}
-+
-+template <>
-+void MemoryFactory<WideIO2>::validate(int channels, int ranks, const Config& configs) {
-+    assert((channels == 4 || channels == 8) && "WideIO2 comes with 4 or 8 channels");
-+    assert((ranks == 1 || ranks == 2) && "WideIO2 comes with 1 or 2 ranks");
-+}
-+
-+template <>
-+void MemoryFactory<HBM>::validate(int channels, int ranks, const Config& configs) {
-+    assert(channels == 8 && "HBM comes with 8 channels");
-+}
-+
-+template <>
-+MemoryBase *MemoryFactory<WideIO2>::create(const Config& configs, int cacheline, bool enable_debug) {
-+    int channels = stoi(configs["channels"], NULL, 0);
-+    int ranks = stoi(configs["ranks"], NULL, 0);
-+    validate(channels, ranks, configs);
-+
-+    const string& org_name = configs["org"];
-+    const string& speed_name = configs["speed"];
-+
-+    WideIO2 *spec = new WideIO2(org_name, speed_name, channels);
-+
-+    extend_channel_width(spec, cacheline);
-+
-+    return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-+}
-+
-+
-+template <>
-+MemoryBase *MemoryFactory<SALP>::create(const Config& configs, int cacheline, bool enable_debug) {
-+    int channels = stoi(configs["channels"], NULL, 0);
-+    int ranks = stoi(configs["ranks"], NULL, 0);
-+    int subarrays = stoi(configs["subarrays"], NULL, 0);
-+    validate(channels, ranks, configs);
-+
-+    const string& std_name = configs["standard"];
-+    const string& org_name = configs["org"];
-+    const string& speed_name = configs["speed"];
-+
-+    SALP *spec = new SALP(org_name, speed_name, std_name, subarrays);
-+
-+    extend_channel_width(spec, cacheline);
-+
-+    return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-+}
-+
-+}
-+
-+// This function can be used by autoconf AC_CHECK_LIB since
-+// apparently it can't detect C++ functions.
-+// Basically just an entry in the symbol table
-+extern "C"
-+{
-+    void libramulator_is_present(void)
-+    {
-+        ;
-+    }
-+}
-diff --git a/ext/ramulator/Ramulator/src/MemoryFactory.h b/ext/ramulator/Ramulator/src/MemoryFactory.h
-new file mode 100644
-index 0000000..f85d773
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/MemoryFactory.h
-@@ -0,0 +1,86 @@
-+#ifndef __MEMORY_FACTORY_H
-+#define __MEMORY_FACTORY_H
-+
-+#include <map>
-+#include <string>
-+#include <cassert>
-+
-+#include "Config.h"
-+#include "Memory.h"
-+
-+#include "WideIO2.h"
-+#include "SALP.h"
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+template <typename T>
-+class MemoryFactory {
-+public:
-+    static void extend_channel_width(T* spec, int cacheline)
-+    {
-+        int channel_unit = spec->prefetch_size * spec->channel_width / 8;
-+        int gang_number = cacheline / channel_unit;
-+        
-+        assert(gang_number >= 1 && 
-+            "cacheline size must be greater or equal to minimum channel width");
-+        
-+        assert(cacheline == gang_number * channel_unit &&
-+            "cacheline size must be a multiple of minimum channel width");
-+        
-+        spec->channel_width *= gang_number;
-+    }
-+
-+    static Memory<T> *populate_memory(const Config& configs, T *spec, int channels, int ranks, bool enable_debug) {
-+        int& default_ranks = spec->org_entry.count[int(T::Level::Rank)];
-+        int& default_channels = spec->org_entry.count[int(T::Level::Channel)];
-+
-+        if (default_channels == 0) default_channels = channels;
-+        if (default_ranks == 0) default_ranks = ranks;
-+
-+        vector<Controller<T> *> ctrls;
-+        for (int c = 0; c < channels; c++){
-+            DRAM<T>* channel = new DRAM<T>(spec, T::Level::Channel);
-+            channel->id = c;
-+            channel->regStats("");
-+            ctrls.push_back(new Controller<T>(configs, channel, enable_debug));
-+        }
-+        
-+        // daz3
-+        std::cout << "Ramulator::channels " << channels << ", ::ranks " << ranks << ", ::enable_debug" << enable_debug << std::endl;
-+
-+        return new Memory<T>(configs, ctrls);
-+    }
-+
-+    static void validate(int channels, int ranks, const Config& configs) {
-+        assert(channels > 0 && ranks > 0);
-+    }
-+
-+    static MemoryBase *create(const Config& configs, int cacheline, bool enable_debug)
-+    {
-+        int channels = stoi(configs["channels"], NULL, 0);
-+        int ranks = stoi(configs["ranks"], NULL, 0);
-+        
-+        validate(channels, ranks, configs);
-+
-+        const string& org_name = configs["org"];
-+        const string& speed_name = configs["speed"];
-+
-+        T *spec = new T(org_name, speed_name);
-+
-+        extend_channel_width(spec, cacheline);
-+
-+        return (MemoryBase *)populate_memory(configs, spec, channels, ranks, enable_debug);
-+    }
-+};
-+
-+template <>
-+  MemoryBase *MemoryFactory<WideIO2>::create(const Config& configs, int cacheline, bool enable_debug);
-+template <>
-+  MemoryBase *MemoryFactory<SALP>::create(const Config& configs, int cacheline, bool enable_debug);
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__MEMORY_FACTORY_H*/
-diff --git a/ext/ramulator/Ramulator/src/PCM.cpp b/ext/ramulator/Ramulator/src/PCM.cpp
-new file mode 100644
-index 0000000..309ace8
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/PCM.cpp
-@@ -0,0 +1,348 @@
-+/*
-+*
-+* The timing parameters used in this file are provided by the following study:
-+* Benjamin C. Lee, Engin Ipek, Onur Mutlu, and Doug Burger. 2009.
-+* Architecting phase change memory as a scalable dram alternative.
-+* In Proceedings of the 36th annual international symposium on Computer architecture (ISCA '09).
-+* ACM, New York, NY, USA, 2-13.
-+* DOI: https://doi.org/10.1145/1555754.1555758
-+*
-+*/
-+#include "PCM.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string PCM::standard_name = "PCM";
-+string PCM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum PCM::Org> PCM::org_map = {
-+    {"PCM_512Mb_x4", PCM::Org::PCM_512Mb_x4}, {"PCM_512Mb_x8", PCM::Org::PCM_512Mb_x8}, {"PCM_512Mb_x16", PCM::Org::PCM_512Mb_x16},
-+    {"PCM_1Gb_x4", PCM::Org::PCM_1Gb_x4}, {"PCM_1Gb_x8", PCM::Org::PCM_1Gb_x8}, {"PCM_1Gb_x16", PCM::Org::PCM_1Gb_x16},
-+    {"PCM_2Gb_x4", PCM::Org::PCM_2Gb_x4}, {"PCM_2Gb_x8", PCM::Org::PCM_2Gb_x8}, {"PCM_2Gb_x16", PCM::Org::PCM_2Gb_x16},
-+    {"PCM_4Gb_x4", PCM::Org::PCM_4Gb_x4}, {"PCM_4Gb_x8", PCM::Org::PCM_4Gb_x8}, {"PCM_4Gb_x16", PCM::Org::PCM_4Gb_x16},
-+    {"PCM_8Gb_x4", PCM::Org::PCM_8Gb_x4}, {"PCM_8Gb_x8", PCM::Org::PCM_8Gb_x8}, {"PCM_8Gb_x16", PCM::Org::PCM_8Gb_x16},
-+};
-+
-+map<string, enum PCM::Speed> PCM::speed_map = {
-+    {"PCM_800D", PCM::Speed::PCM_800D}
-+};
-+
-+
-+PCM::PCM(Org org, Speed speed) :
-+    org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+PCM::PCM(const string& org_str, const string& speed_str) :
-+    PCM(org_map[org_str], speed_map[speed_str])
-+{
-+}
-+
-+void PCM::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void PCM::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void PCM::init_speed()
-+{
-+    // nRRD, nFAW
-+    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nFAW = (page==1) ? 16 : 20; break;
-+        default: assert(false);
-+    }
-+
-+    // nRFC, nXS
-+    int chip = org_entry.size;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRFC = 0; break;
-+        default: assert(false);
-+    }
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-+        default: assert(false);
-+    }
-+}
-+
-+
-+void PCM::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PREA;
-+        }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void PCM::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void PCM::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void PCM::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<PCM>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<PCM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<PCM>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<PCM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<PCM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<PCM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<PCM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<PCM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<PCM>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<PCM>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<PCM>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<PCM>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void PCM::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRDact});
-+    t[int(Command::PRE)].push_back({Command::PRE, 1, s.nRRDact});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+}
-diff --git a/ext/ramulator/Ramulator/src/PCM.h b/ext/ramulator/Ramulator/src/PCM.h
-new file mode 100644
-index 0000000..785d07d
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/PCM.h
-@@ -0,0 +1,211 @@
-+/*
-+*
-+* The timing parameters used in this file are provided by the following study:
-+* Benjamin C. Lee, Engin Ipek, Onur Mutlu, and Doug Burger. 2009.
-+* Architecting phase change memory as a scalable dram alternative.
-+* In Proceedings of the 36th annual international symposium on Computer architecture (ISCA '09).
-+* ACM, New York, NY, USA, 2-13.
-+* DOI: https://doi.org/10.1145/1555754.1555758
-+*
-+*/
-+#ifndef __PCM_H
-+#define __PCM_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <map>
-+#include <string>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class PCM
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    PCM(Org org, Speed speed);
-+    PCM(const string& org_str, const string& speed_str);
-+
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    /*** Level ***/
-+    enum class Level : int
-+    {
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    {
-+        ACT, PRE, PREA,
-+        RD,  WR,  RDA,  WRA,
-+        REF, PDE, PDX,  SRE, SRX,
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA",
-+        "RD",  "WR",  "RDA",  "WRA",
-+        "REF", "PDE", "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<PCM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<PCM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<PCM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    };
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<PCM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        PCM_512Mb_x4, PCM_512Mb_x8, PCM_512Mb_x16,
-+        PCM_1Gb_x4,   PCM_1Gb_x8,   PCM_1Gb_x16,
-+        PCM_2Gb_x4,   PCM_2Gb_x8,   PCM_2Gb_x16,
-+        PCM_4Gb_x4,   PCM_4Gb_x8,   PCM_4Gb_x16,
-+        PCM_8Gb_x4,   PCM_8Gb_x8,   PCM_8Gb_x16,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-+        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-+        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-+        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-+        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        PCM_800D,
-+        MAX
-+    };
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRDact, nRRDpre, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL;
-+        int nCKESR, nXS, nXSDLL;
-+    } speed_table[int(Speed::MAX)] = {
-+        {800,  (400.0/3)*3, 2.5, 4, 4, 2,  5,  22,  60,  5, 22, 60, 3, 3,  6, 2, 11, 0, 0, 3900, 0, 3, 10, 4, 0, 512},
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__PCM_H*/
-diff --git a/ext/ramulator/Ramulator/src/Processor.cpp b/ext/ramulator/Ramulator/src/Processor.cpp
-new file mode 100644
-index 0000000..bd94e55
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Processor.cpp
-@@ -0,0 +1,473 @@
-+#include "Processor.h"
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+Processor::Processor(const Config& configs,
-+    vector<const char*> trace_list,
-+    function<bool(Request)> send_memory,
-+    MemoryBase& memory)
-+    : ipcs(trace_list.size(), -1),
-+    early_exit(configs.is_early_exit()),
-+    no_core_caches(!configs.has_core_caches()),
-+    no_shared_cache(!configs.has_l3_cache()),
-+    cachesys(new CacheSystem(configs, send_memory)),
-+    llc(l3_size, l3_assoc, l3_blocksz,
-+         mshr_per_bank * trace_list.size(),
-+         Cache::Level::L3, cachesys) {
-+
-+  assert(cachesys != nullptr);
-+  int tracenum = trace_list.size();
-+  assert(tracenum > 0);
-+  printf("tracenum: %d\n", tracenum);
-+  for (int i = 0 ; i < tracenum ; ++i) {
-+    printf("trace_list[%d]: %s\n", i, trace_list[i]);
-+  }
-+  if (no_shared_cache) {
-+    for (int i = 0 ; i < tracenum ; ++i) {
-+      cores.emplace_back(new Core(
-+          configs, i, trace_list[i], send_memory, nullptr,
-+          cachesys, memory));
-+    }
-+  } else {
-+    for (int i = 0 ; i < tracenum ; ++i) {
-+      cores.emplace_back(new Core(configs, i, trace_list[i],
-+          std::bind(&Cache::send, &llc, std::placeholders::_1),
-+          &llc, cachesys, memory));
-+    }
-+  }
-+  for (int i = 0 ; i < tracenum ; ++i) {
-+    cores[i]->callback = std::bind(&Processor::receive, this,
-+        placeholders::_1);
-+  }
-+
-+  // regStats
-+  cpu_cycles.name("cpu_cycles")
-+            .desc("cpu cycle number")
-+            .precision(0)
-+            ;
-+  cpu_cycles = 0;
-+}
-+
-+void Processor::tick() {
-+  cpu_cycles++;
-+
-+  if((int(cpu_cycles.value()) % 50000000) == 0)
-+      printf("CPU heartbeat, cycles: %d \n", (int(cpu_cycles.value())));
-+
-+  if (!(no_core_caches && no_shared_cache)) {
-+    cachesys->tick();
-+  }
-+  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-+    Core* core = cores[i].get();
-+    core->tick();
-+  }
-+}
-+
-+void Processor::receive(Request& req) {
-+  if (!no_shared_cache) {
-+    llc.callback(req);
-+  } else if (!cores[0]->no_core_caches) {
-+    // Assume all cores have caches or don't have caches
-+    // at the same time.
-+    for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-+      Core* core = cores[i].get();
-+      core->caches[0]->callback(req);
-+    }
-+  }
-+  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-+    Core* core = cores[i].get();
-+    core->receive(req);
-+  }
-+}
-+
-+bool Processor::finished() {
-+  if (early_exit) {
-+    for (unsigned int i = 0 ; i < cores.size(); ++i) {
-+      if (cores[i]->finished()) {
-+        for (unsigned int j = 0 ; j < cores.size() ; ++j) {
-+          ipc += cores[j]->calc_ipc();
-+        }
-+        return true;
-+      }
-+    }
-+    return false;
-+  } else {
-+    for (unsigned int i = 0 ; i < cores.size(); ++i) {
-+      if (!cores[i]->finished()) {
-+        return false;
-+      }
-+      if (ipcs[i] < 0) {
-+        ipcs[i] = cores[i]->calc_ipc();
-+        ipc += ipcs[i];
-+      }
-+    }
-+    return true;
-+  }
-+}
-+
-+bool Processor::has_reached_limit() {
-+  for (unsigned int i = 0 ; i < cores.size() ; ++i) {
-+    if (!cores[i]->has_reached_limit()) {
-+      return false;
-+    }
-+  }
-+  return true;
-+}
-+
-+long Processor::get_insts() {
-+    long insts_total = 0;
-+    for (unsigned int i = 0 ; i < cores.size(); i++) {
-+        insts_total += cores[i]->get_insts();
-+    }
-+
-+    return insts_total;
-+}
-+
-+void Processor::reset_stats() {
-+    for (unsigned int i = 0 ; i < cores.size(); i++) {
-+        cores[i]->reset_stats();
-+    }
-+
-+    ipc = 0;
-+
-+    for (unsigned int i = 0; i < ipcs.size(); i++)
-+        ipcs[i] = -1;
-+}
-+
-+Core::Core(const Config& configs, int coreid,
-+    const char* trace_fname, function<bool(Request)> send_next,
-+    Cache* llc, std::shared_ptr<CacheSystem> cachesys, MemoryBase& memory)
-+    : id(coreid), no_core_caches(!configs.has_core_caches()),
-+    no_shared_cache(!configs.has_l3_cache()),
-+    llc(llc), trace(trace_fname), memory(memory)
-+{
-+  // set expected limit instruction for calculating weighted speedup
-+  expected_limit_insts = configs.get_expected_limit_insts();
-+  trace.expected_limit_insts = expected_limit_insts;
-+
-+  // Build cache hierarchy
-+  if (no_core_caches) {
-+    send = send_next;
-+  } else {
-+    // L2 caches[0]
-+    caches.emplace_back(new Cache(
-+        l2_size, l2_assoc, l2_blocksz, l2_mshr_num,
-+        Cache::Level::L2, cachesys));
-+    // L1 caches[1]
-+    caches.emplace_back(new Cache(
-+        l1_size, l1_assoc, l1_blocksz, l1_mshr_num,
-+        Cache::Level::L1, cachesys));
-+    send = bind(&Cache::send, caches[1].get(), placeholders::_1);
-+    if (llc != nullptr) {
-+      caches[0]->concatlower(llc);
-+    }
-+    caches[1]->concatlower(caches[0].get());
-+
-+    first_level_cache = caches[1].get();
-+  }
-+  if (no_core_caches) {
-+    more_reqs = trace.get_filtered_request(
-+        bubble_cnt, req_addr, req_type);
-+    req_addr = memory.page_allocator(req_addr, id);
-+  } else {
-+    more_reqs = trace.get_unfiltered_request(
-+        bubble_cnt, req_addr, req_type);
-+    req_addr = memory.page_allocator(req_addr, id);
-+  }
-+
-+  
-+  // regStats
-+  record_cycs.name("record_cycs_core_" + to_string(id))
-+             .desc("Record cycle number for calculating weighted speedup. (Only valid when expected limit instruction number is non zero in config file.)")
-+             .precision(0)
-+             ;
-+
-+  record_insts.name("record_insts_core_" + to_string(id))
-+              .desc("Retired instruction number when record cycle number. (Only valid when expected limit instruction number is non zero in config file.)")
-+              .precision(0)
-+              ;
-+
-+  memory_access_cycles.name("memory_access_cycles_core_" + to_string(id))
-+                      .desc("memory access cycles in memory time domain")
-+                      .precision(0)
-+                      ;
-+  memory_access_cycles = 0;
-+  cpu_inst.name("cpu_instructions_core_" + to_string(id))
-+          .desc("cpu instruction number")
-+          .precision(0)
-+          ;
-+  cpu_inst = 0;
-+}
-+
-+
-+double Core::calc_ipc()
-+{
-+    printf("[%d]retired: %ld, clk, %ld\n", id, retired, clk);
-+    return (double) retired / clk;
-+}
-+
-+void Core::tick()
-+{
-+    clk++;
-+
-+    if(first_level_cache != nullptr)
-+        first_level_cache->tick();
-+
-+    retired += window.retire();
-+
-+    if (expected_limit_insts == 0 && !more_reqs) return;
-+
-+    // bubbles (non-memory operations)
-+    int inserted = 0;
-+    while (bubble_cnt > 0) {
-+        if (inserted == window.ipc) return;
-+        if (window.is_full()) return;
-+
-+        window.insert(true, -1);
-+        inserted++;
-+        bubble_cnt--;
-+        cpu_inst++;
-+        if (long(cpu_inst.value()) == expected_limit_insts && !reached_limit) {
-+          record_cycs = clk;
-+          record_insts = long(cpu_inst.value());
-+          memory.record_core(id);
-+          reached_limit = true;
-+        }
-+    }
-+
-+    if (req_type == Request::Type::READ) {
-+        // read request
-+        if (inserted == window.ipc) return;
-+        if (window.is_full()) return;
-+
-+        Request req(req_addr, req_type, callback, id);
-+        if (!send(req)) return;
-+
-+        window.insert(false, req_addr);
-+        cpu_inst++;
-+    }
-+    else {
-+        // write request
-+        assert(req_type == Request::Type::WRITE);
-+        Request req(req_addr, req_type, callback, id);
-+        if (!send(req)) return;
-+        cpu_inst++;
-+    }
-+    if (long(cpu_inst.value()) == expected_limit_insts && !reached_limit) {
-+      record_cycs = clk;
-+      record_insts = long(cpu_inst.value());
-+      memory.record_core(id);
-+      reached_limit = true;
-+    }
-+
-+    if (no_core_caches) {
-+      more_reqs = trace.get_filtered_request(
-+          bubble_cnt, req_addr, req_type);
-+      if (req_addr != -1) {
-+        req_addr = memory.page_allocator(req_addr, id);
-+      }
-+    } else {
-+      more_reqs = trace.get_unfiltered_request(
-+          bubble_cnt, req_addr, req_type);
-+      if (req_addr != -1) {
-+        req_addr = memory.page_allocator(req_addr, id);
-+      }
-+    }
-+    if (!more_reqs) {
-+      if (!reached_limit) { // if the length of this trace is shorter than expected length, then record it when the whole trace finishes, and set reached_limit to true.
-+        // Hasan: overriding this behavior. We start the trace from the
-+        // beginning until the requested amount of instructions are
-+        // simulated. This should never be reached now.
-+        assert((expected_limit_insts == 0) && "Shouldn't be reached when expected_limit_insts > 0 since we start over the trace");
-+        record_cycs = clk;
-+        record_insts = long(cpu_inst.value());
-+        memory.record_core(id);
-+        reached_limit = true;
-+      }
-+    }
-+}
-+
-+bool Core::finished()
-+{
-+    return !more_reqs && window.is_empty();
-+}
-+
-+bool Core::has_reached_limit() {
-+  return reached_limit;
-+}
-+
-+long Core::get_insts() {
-+    return long(cpu_inst.value());
-+}
-+
-+void Core::receive(Request& req)
-+{
-+    window.set_ready(req.addr, ~(l1_blocksz - 1l));
-+    if (req.arrive != -1 && req.depart > last) {
-+      memory_access_cycles += (req.depart - max(last, req.arrive));
-+      last = req.depart;
-+    }
-+}
-+
-+void Core::reset_stats() {
-+    clk = 0;
-+    retired = 0;
-+    cpu_inst = 0;
-+}
-+
-+bool Window::is_full()
-+{
-+    return load == depth;
-+}
-+
-+bool Window::is_empty()
-+{
-+    return load == 0;
-+}
-+
-+
-+void Window::insert(bool ready, long addr)
-+{
-+    assert(load <= depth);
-+
-+    ready_list.at(head) = ready;
-+    addr_list.at(head) = addr;
-+
-+    head = (head + 1) % depth;
-+    load++;
-+}
-+
-+
-+long Window::retire()
-+{
-+    assert(load <= depth);
-+
-+    if (load == 0) return 0;
-+
-+    int retired = 0;
-+    while (load > 0 && retired < ipc) {
-+        if (!ready_list.at(tail))
-+            break;
-+
-+        tail = (tail + 1) % depth;
-+        load--;
-+        retired++;
-+    }
-+
-+    return retired;
-+}
-+
-+
-+void Window::set_ready(long addr, int mask)
-+{
-+    if (load == 0) return;
-+
-+    for (int i = 0; i < load; i++) {
-+        int index = (tail + i) % depth;
-+        if ((addr_list.at(index) & mask) != (addr & mask))
-+            continue;
-+        ready_list.at(index) = true;
-+    }
-+}
-+
-+
-+
-+Trace::Trace(const char* trace_fname) : file(trace_fname), trace_name(trace_fname)
-+{
-+    if (!file.good()) {
-+        std::cerr << "Bad trace file: " << trace_fname << std::endl;
-+        exit(1);
-+    }
-+}
-+
-+bool Trace::get_unfiltered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type)
-+{
-+    string line;
-+    getline(file, line);
-+    if (file.eof()) {
-+      file.clear();
-+      file.seekg(0, file.beg);
-+      getline(file, line);
-+      //return false;
-+    }
-+    size_t pos, end;
-+    bubble_cnt = std::stoul(line, &pos, 10);
-+    pos = line.find_first_not_of(' ', pos+1);
-+    req_addr = std::stoul(line.substr(pos), &end, 0);
-+
-+    pos = line.find_first_not_of(' ', pos+end);
-+
-+    if (pos == string::npos || line.substr(pos)[0] == 'R')
-+        req_type = Request::Type::READ;
-+    else if (line.substr(pos)[0] == 'W')
-+        req_type = Request::Type::WRITE;
-+    else assert(false);
-+    return true;
-+}
-+
-+bool Trace::get_filtered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type)
-+{
-+    static bool has_write = false;
-+    static long write_addr;
-+    static int line_num = 0;
-+    if (has_write){
-+        bubble_cnt = 0;
-+        req_addr = write_addr;
-+        req_type = Request::Type::WRITE;
-+        has_write = false;
-+        return true;
-+    }
-+    string line;
-+    getline(file, line);
-+    line_num ++;
-+    if (file.eof() || line.size() == 0) {
-+        file.clear();
-+        file.seekg(0, file.beg);
-+        line_num = 0;
-+
-+        if(expected_limit_insts == 0) {
-+            has_write = false;
-+            return false;
-+        }
-+        else { // starting over the input trace file
-+            getline(file, line);
-+            line_num++;
-+        }
-+    }
-+
-+    size_t pos, end;
-+    bubble_cnt = std::stoul(line, &pos, 10);
-+
-+    pos = line.find_first_not_of(' ', pos+1);
-+    req_addr = stoul(line.substr(pos), &end, 0);
-+    req_type = Request::Type::READ;
-+
-+    pos = line.find_first_not_of(' ', pos+end);
-+    if (pos != string::npos){
-+        has_write = true;
-+        write_addr = stoul(line.substr(pos), NULL, 0);
-+    }
-+    return true;
-+}
-+
-+bool Trace::get_dramtrace_request(long& req_addr, Request::Type& req_type)
-+{
-+    string line;
-+    getline(file, line);
-+    if (file.eof()) {
-+        return false;
-+    }
-+    size_t pos;
-+    req_addr = std::stoul(line, &pos, 16);
-+
-+    pos = line.find_first_not_of(' ', pos+1);
-+
-+    if (pos == string::npos || line.substr(pos)[0] == 'R')
-+        req_type = Request::Type::READ;
-+    else if (line.substr(pos)[0] == 'W')
-+        req_type = Request::Type::WRITE;
-+    else assert(false);
-+    return true;
-+}
-diff --git a/ext/ramulator/Ramulator/src/Processor.h b/ext/ramulator/Ramulator/src/Processor.h
-new file mode 100644
-index 0000000..0cdc464
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Processor.h
-@@ -0,0 +1,149 @@
-+#ifndef __PROCESSOR_H
-+#define __PROCESSOR_H
-+
-+#include "Cache.h"
-+#include "Config.h"
-+#include "Memory.h"
-+#include "Request.h"
-+#include "Statistics.h"
-+#include <iostream>
-+#include <vector>
-+#include <fstream>
-+#include <string>
-+#include <ctype.h>
-+#include <functional>
-+
-+namespace ramulator 
-+{
-+
-+class Trace {
-+public:
-+    Trace(const char* trace_fname);
-+    // trace file format 1:
-+    // [# of bubbles(non-mem instructions)] [read address(dec or hex)] <optional: write address(evicted cacheline)>
-+    bool get_unfiltered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type);
-+    bool get_filtered_request(long& bubble_cnt, long& req_addr, Request::Type& req_type);
-+    // trace file format 2:
-+    // [address(hex)] [R/W]
-+    bool get_dramtrace_request(long& req_addr, Request::Type& req_type);
-+
-+    long expected_limit_insts = 0;
-+
-+private:
-+    std::ifstream file;
-+    std::string trace_name;
-+};
-+
-+
-+class Window {
-+public:
-+    int ipc = 4;
-+    int depth = 128;
-+
-+    Window() : ready_list(depth), addr_list(depth, -1) {}
-+    bool is_full();
-+    bool is_empty();
-+    void insert(bool ready, long addr);
-+    long retire();
-+    void set_ready(long addr, int mask);
-+
-+private:
-+    int load = 0;
-+    int head = 0;
-+    int tail = 0;
-+    std::vector<bool> ready_list;
-+    std::vector<long> addr_list;
-+};
-+
-+
-+class Core {
-+public:
-+    long clk = 0;
-+    long retired = 0;
-+    int id = 0;
-+    function<bool(Request)> send;
-+
-+    Core(const Config& configs, int coreid,
-+        const char* trace_fname,
-+        function<bool(Request)> send_next, Cache* llc,
-+        std::shared_ptr<CacheSystem> cachesys, MemoryBase& memory);
-+    void tick();
-+    void receive(Request& req);
-+    void reset_stats();
-+    double calc_ipc();
-+    bool finished();
-+    bool has_reached_limit();
-+    long get_insts(); // the number of the instructions issued to the core
-+    function<void(Request&)> callback;
-+
-+    bool no_core_caches = true;
-+    bool no_shared_cache = true;
-+    int l1_size = 1 << 15;
-+    int l1_assoc = 1 << 3;
-+    int l1_blocksz = 1 << 6;
-+    int l1_mshr_num = 16;
-+
-+    int l2_size = 1 << 18;
-+    int l2_assoc = 1 << 3;
-+    int l2_blocksz = 1 << 6;
-+    int l2_mshr_num = 16;
-+    std::vector<std::shared_ptr<Cache>> caches;
-+    Cache* llc;
-+
-+    ScalarStat record_cycs;
-+    ScalarStat record_insts;
-+    long expected_limit_insts;
-+    // This is set true iff expected number of instructions has been executed or all instructions are executed.
-+    bool reached_limit = false;
-+
-+private:
-+    Trace trace;
-+    Window window;
-+
-+    long bubble_cnt;
-+    long req_addr = -1;
-+    Request::Type req_type;
-+    bool more_reqs;
-+    long last = 0;
-+
-+    Cache* first_level_cache = nullptr;
-+
-+    ScalarStat memory_access_cycles;
-+    ScalarStat cpu_inst;
-+    MemoryBase& memory;
-+};
-+
-+class Processor {
-+public:
-+    Processor(const Config& configs, vector<const char*> trace_list,
-+        function<bool(Request)> send, MemoryBase& memory);
-+    void tick();
-+    void receive(Request& req);
-+    void reset_stats();
-+    bool finished();
-+    bool has_reached_limit();
-+    long get_insts(); // the total number of instructions issued to all cores
-+
-+    std::vector<std::unique_ptr<Core>> cores;
-+    std::vector<double> ipcs;
-+    double ipc = 0;
-+
-+    // When early_exit is true, the simulation exits when the earliest trace finishes.
-+    bool early_exit;
-+
-+    bool no_core_caches = true;
-+    bool no_shared_cache = true;
-+
-+    int l3_size = 1 << 23;
-+    int l3_assoc = 1 << 3;
-+    int l3_blocksz = 1 << 6;
-+    int mshr_per_bank = 16;
-+
-+    std::shared_ptr<CacheSystem> cachesys;
-+    Cache llc;
-+
-+    ScalarStat cpu_cycles;
-+};
-+
-+}
-+#endif /* __PROCESSOR_H */
-diff --git a/ext/ramulator/Ramulator/src/Refresh.cpp b/ext/ramulator/Ramulator/src/Refresh.cpp
-new file mode 100644
-index 0000000..b3b59ce
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Refresh.cpp
-@@ -0,0 +1,255 @@
-+/*
-+ * Refresh.cpp
-+ *
-+ * Mainly DSARP specialization at the moment.
-+ *
-+ *  Created on: Mar 17, 2015
-+ *      Author: kevincha
-+ */
-+
-+#include <stdlib.h>
-+
-+#include "Refresh.h"
-+#include "Controller.h"
-+#include "DRAM.h"
-+#include "DSARP.h"
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+namespace ramulator {
-+
-+/**** DSARP specialization ****/
-+template<>
-+Refresh<DSARP>::Refresh(Controller<DSARP>* ctrl) : ctrl(ctrl) {
-+  clk = refreshed = 0;
-+  max_rank_count = ctrl->channel->children.size();
-+  max_bank_count = ctrl->channel->spec->org_entry.count[(int)DSARP::Level::Bank];
-+  max_sa_count = ctrl->channel->spec->org_entry.count[(int)DSARP::Level::SubArray];
-+
-+  // Init refresh counters
-+  for (int r = 0; r < max_rank_count; r++) {
-+    bank_ref_counters.push_back(0);
-+    bank_refresh_backlog.push_back(new vector<int>(max_bank_count, 0));
-+    vector<int> sa_counters(ctrl->channel->spec->org_entry.count[(int)DSARP::Level::SubArray], 0);
-+    subarray_ref_counters.push_back(sa_counters);
-+  }
-+
-+  level_chan = (int)DSARP::Level::Channel;
-+  level_rank = (int)DSARP::Level::Rank;
-+  level_bank = (int)DSARP::Level::Bank;
-+  level_sa   = (int)DSARP::Level::SubArray;
-+}
-+
-+template<>
-+void Refresh<DSARP>::early_inject_refresh() {
-+  // Only enabled during reads
-+  if (ctrl->write_mode)
-+    return;
-+
-+  // OoO bank-level refresh
-+  vector<bool> is_bank_occupied(max_rank_count * max_bank_count, false);
-+  Controller<DSARP>::Queue& rdq = ctrl->readq;
-+
-+  // Figure out which banks are idle in order to refresh one of them
-+  for (auto req: rdq.q)
-+  {
-+    assert(req.addr_vec[level_chan] == ctrl->channel->id);
-+    int ridx = req.addr_vec[level_rank] * max_bank_count;
-+    int bidx = req.addr_vec[level_bank];
-+    is_bank_occupied[ridx+bidx] = true;
-+  }
-+
-+  // Try to pick an idle bank to refresh per rank
-+  for (int r = 0; r < max_rank_count; r++) {
-+    // Randomly pick a bank to examine
-+    int bidx_start = rand() % max_bank_count;
-+
-+    for (int b = 0; b < max_bank_count; b++)
-+    {
-+      int bidx = (bidx_start + b) % max_bank_count;
-+      // Idle cycle only
-+      if (is_bank_occupied[(r * max_bank_count) + bidx])
-+        continue;
-+
-+      // Pending refresh
-+      bool pending_ref = false;
-+      for (Request req : ctrl->otherq.q)
-+        if (req.type == Request::Type::REFRESH
-+            && req.addr_vec[level_chan] == ctrl->channel->id
-+            && req.addr_vec[level_rank] == r && req.addr_vec[level_bank] == bidx)
-+          pending_ref = true;
-+      if (pending_ref)
-+        continue;
-+
-+      // Only pull in refreshes when we are almost running out of credits
-+      if ((*(bank_refresh_backlog[r]))[bidx] >= backlog_early_pull_threshold ||
-+          ctrl->otherq.q.size() >= ctrl->otherq.max)
-+        continue;
-+
-+      // Refresh now
-+      refresh_target(ctrl, r, bidx, subarray_ref_counters[r][bidx]);
-+      // One credit for delaying a future ref
-+      (*(bank_refresh_backlog[r]))[bidx]++;
-+      subarray_ref_counters[r][bidx] = (subarray_ref_counters[r][bidx]+1) % max_sa_count;
-+      break;
-+    }
-+  }
-+}
-+
-+template<>
-+void Refresh<DSARP>::inject_refresh(bool b_ref_rank) {
-+  // Rank-level refresh
-+  if (b_ref_rank)
-+    for (auto rank : ctrl->channel->children)
-+      refresh_target(ctrl, rank->id, -1, -1);
-+  // Bank-level refresh. Simultaneously issue to all ranks (better performance than staggered refreshes).
-+  else {
-+    for (auto rank : ctrl->channel->children) {
-+      int rid = rank->id;
-+      int bid = bank_ref_counters[rid];
-+
-+      // Behind refresh schedule by 1 ref
-+      (*(bank_refresh_backlog[rid]))[bid]--;
-+
-+      // Next time, refresh the next bank in the same bank
-+      bank_ref_counters[rid] = (bank_ref_counters[rid] + 1) % max_bank_count;
-+
-+      // Check to see if we can skip a refresh
-+      if (ctrl->channel->spec->type == DSARP::Type::DARP ||
-+        ctrl->channel->spec->type == DSARP::Type::DSARP) {
-+
-+        bool ref_now = false;
-+        // 1. Any pending refrehes?
-+        bool pending_ref = false;
-+        for (Request req : ctrl->otherq.q) {
-+          if (req.type == Request::Type::REFRESH) {
-+            pending_ref = true;
-+            break;
-+          }
-+        }
-+
-+        // 2. Track readq
-+        if (!pending_ref && ctrl->readq.size() == 0)
-+          ref_now = true;
-+
-+        // 3. Track log status. If we are too behind the schedule, then we need to refresh now.
-+        if ((*(bank_refresh_backlog[rid]))[bid] <= backlog_min)
-+          ref_now = true;
-+
-+        // Otherwise skip refresh
-+        if (!ref_now)
-+          continue;
-+      }
-+
-+      refresh_target(ctrl, rid, bid, subarray_ref_counters[rid][bid]);
-+      // Get 1 ref credit
-+      (*(bank_refresh_backlog[rid]))[bid]++;
-+      // Next time, refresh the next sa in the same bank
-+      subarray_ref_counters[rid][bid] = (subarray_ref_counters[rid][bid]+1) % max_sa_count;
-+    }
-+  }
-+  refreshed = clk;
-+}
-+
-+// first = wrq.count; second = bank idx
-+typedef pair<int, int> wrq_idx;
-+bool wrq_comp (wrq_idx l, wrq_idx r)
-+{
-+  return l.first < r.first;
-+}
-+
-+// WRP
-+template<>
-+void Refresh<DSARP>::wrp() {
-+  for (int ref_rid = 0; ref_rid < max_rank_count; ref_rid++)
-+  {
-+    // Pending refresh in the rank?
-+    bool pending_ref = false;
-+    for (Request req : ctrl->otherq.q) {
-+      if (req.type == Request::Type::REFRESH && req.addr_vec[level_rank] == ref_rid) {
-+        pending_ref = true;
-+        break;
-+      }
-+    }
-+    if (pending_ref)
-+      continue;
-+
-+    // Find the bank with the lowest number of writes+reads
-+    vector<wrq_idx> sorted_bank_demand;
-+    for (int b = 0; b < max_bank_count; b++)
-+      sorted_bank_demand.push_back(wrq_idx(0,b));
-+    // Filter out all the writes to this rank
-+    int total_wr = 0;
-+    for (auto req : ctrl->writeq.q) {
-+      if (req.addr_vec[level_rank] == ref_rid) {
-+        sorted_bank_demand[req.addr_vec[level_bank]].first++;
-+        total_wr++;
-+      }
-+    }
-+    // If there's no write, just skip.
-+    if (total_wr == 0)
-+      continue;
-+
-+    // Add read
-+    for (auto req : ctrl->readq.q)
-+      if (req.addr_vec[level_rank] == ref_rid)
-+        sorted_bank_demand[req.addr_vec[level_bank]].first++;
-+
-+    // Sort based on the entries
-+    std::sort(sorted_bank_demand.begin(), sorted_bank_demand.end(), wrq_comp);
-+
-+    // Randomly select an idle bank to refresh
-+    int top_idle_idx = 0;
-+    for (int i = 0; i < max_bank_count; i++) {
-+      if (sorted_bank_demand[i].second != 0) {
-+        top_idle_idx = i;
-+        break;
-+      }
-+    }
-+
-+    // Select a bank to ref
-+    int ref_bid_idx = (top_idle_idx == 0) ? 0 : rand() % top_idle_idx;
-+    int ref_bid = sorted_bank_demand[ref_bid_idx].second;
-+
-+    // Make sure we don't exceed the credit
-+    if ((*(bank_refresh_backlog[ref_rid]))[ref_bid] < backlog_max
-+        && ctrl->otherq.q.size() < ctrl->otherq.max) {
-+      refresh_target(ctrl, ref_rid, ref_bid, subarray_ref_counters[ref_rid][ref_bid]);
-+      // Get 1 ref credit
-+      (*(bank_refresh_backlog[ref_rid]))[ref_bid]++;
-+      subarray_ref_counters[ref_rid][ref_bid] = (subarray_ref_counters[ref_rid][ref_bid]+1) % max_sa_count;
-+    }
-+  }
-+}
-+
-+// OoO refresh of DSARP
-+template<>
-+void Refresh<DSARP>::tick_ref() {
-+  clk++;
-+
-+  bool b_ref_rank = ctrl->channel->spec->b_ref_rank;
-+  int refresh_interval =
-+      (b_ref_rank) ?
-+          ctrl->channel->spec->speed_entry.nREFI :
-+          ctrl->channel->spec->speed_entry.nREFIpb;
-+
-+  // DARP
-+  if (ctrl->channel->spec->type == DSARP::Type::DARP ||
-+    ctrl->channel->spec->type == DSARP::Type::DSARP) {
-+    // Write-Refresh Parallelization. Issue refreshes when the controller enters writeback mode
-+    if (!ctrl_write_mode && ctrl->write_mode)
-+      wrp();
-+    // Record write mode
-+    ctrl_write_mode = ctrl->write_mode;
-+    // Inject early to pull in some refreshes during read mode
-+    early_inject_refresh();
-+  }
-+
-+  // Time to schedule a refresh and also try to skip some refreshes
-+  if ((clk - refreshed) >= refresh_interval)
-+    inject_refresh(b_ref_rank);
-+}
-+/**** End DSARP specialization ****/
-+
-+} /* namespace ramulator */
-diff --git a/ext/ramulator/Ramulator/src/Refresh.h b/ext/ramulator/Ramulator/src/Refresh.h
-new file mode 100644
-index 0000000..66d0304
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Refresh.h
-@@ -0,0 +1,173 @@
-+/*
-+ * Refresh.h
-+ *
-+ * This is a refresh scheduler. A list of refresh policies implemented:
-+ *
-+ * 1. All-bank refresh
-+ * 2. Per-bank refresh (only DSARP memory module has been completed to work with REFpb).
-+ *     The other modules (LPDDRx) have not been updated to pass a knob to turn on/off REFpb.
-+ * 3. A re-implementation of DSARP from the refresh mechanisms proposed in Chang et al.,
-+ * "Improving DRAM Performance by Parallelizing Refreshes with Accesses", HPCA 2014.
-+ *
-+ *  Created on: Mar 17, 2015
-+ *      Author: kevincha
-+ */
-+
-+#ifndef __REFRESH_H_
-+#define __REFRESH_H_
-+
-+#include <stddef.h>
-+#include <cassert>
-+#include <iostream>
-+#include <vector>
-+
-+#include "Request.h"
-+#include "DSARP.h"
-+#include "ALDRAM.h"
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+namespace ramulator {
-+
-+template <typename T>
-+class Controller;
-+
-+template <typename T>
-+class Refresh {
-+public:
-+  Controller<T>* ctrl;
-+  long clk, refreshed;
-+  // daz3
-+  typedef struct _ref_cnt {
-+      int rank_id;
-+      long refreshed;
-+      _ref_cnt(int _id, long _refreshed) {
-+          rank_id = _id;
-+          refreshed = _refreshed;
-+      }
-+  }RefCounter;
-+  vector<RefCounter> refreshed_counters;
-+
-+  // Per-bank refresh counter to track the refresh progress for each rank
-+  vector<int> bank_ref_counters;
-+  int max_rank_count, max_bank_count;
-+  int level_chan, level_rank, level_bank, level_sa;
-+
-+  // ctor
-+  Refresh(Controller<T>* ctrl) : ctrl(ctrl) {
-+    clk = refreshed = 0;
-+    max_rank_count = ctrl->channel->children.size();
-+    max_bank_count = ctrl->channel->spec->org_entry.count[(int)T::Level::Bank];
-+
-+    // Init refresh counters
-+    for (int r = 0; r < max_rank_count; r++) {
-+      bank_ref_counters.push_back(0);
-+      bank_refresh_backlog.push_back(new vector<int>(max_bank_count, 0));
-+    }
-+
-+    level_chan = (int)T::Level::Channel;
-+    level_rank = (int)T::Level::Rank;
-+    level_bank = (int)T::Level::Bank;
-+    level_sa   = -1; // Most DRAM doesn't have subarray level
-+
-+    // daz3
-+    int i = 0;
-+    for (auto rank : ctrl->channel->children)
-+    {
-+        refreshed_counters.push_back(RefCounter(rank->id, (long)((ctrl->channel->spec->speed_entry.nREFI/ctrl->channel->spec->speed_entry.tCK)/max_rank_count) * (i+1) - ctrl->channel->spec->speed_entry.nREFI));
-+        i++;
-+    }
-+  }
-+
-+  // dtor
-+  virtual ~Refresh() {
-+    // Clean up backlog
-+    for (unsigned int i = 0; i < bank_refresh_backlog.size(); i++)
-+      delete bank_refresh_backlog[i];
-+  }
-+
-+  // Basic refresh scheduling for all bank refresh that is applicable to all DRAM types
-+  // void tick_ref() {
-+  //   clk++;
-+  //
-+  //   int refresh_interval = ctrl->channel->spec->speed_entry.nREFI;
-+  //
-+  //   // Time to schedule a refresh
-+  //   if ((clk - refreshed) >= refresh_interval) {
-+  //     inject_refresh(true);
-+  //     // ALDRAM: update timing parameters based on temperatures
-+  //     ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-+  //     ctrl->update_temp(current_temperature);
-+  //   }
-+  // }
-+  // daz3: stackle refresh
-+  void tick_ref() {
-+    clk++;
-+    int refresh_interval = ctrl->channel->spec->speed_entry.nREFI;
-+    // Time to schedule a refresh
-+    for(int i = 0; i < max_rank_count; i++)
-+    {
-+        if ((clk - refreshed_counters[i].refreshed) >= refresh_interval) {
-+            refresh_target(ctrl, refreshed_counters[i].rank_id, -1, -1);
-+            // ALDRAM: update timing parameters based on temperatures
-+            ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-+            ctrl->update_temp(current_temperature);
-+            refreshed_counters[i].refreshed = clk;
-+        }
-+    }
-+  }
-+
-+private:
-+  // Keeping track of refresh status of every bank: + means ahead of schedule, - means behind schedule
-+  vector<vector<int>*> bank_refresh_backlog;
-+  // Keeping track of which subarray to refresh next
-+  vector<vector<int>> subarray_ref_counters;
-+  int max_sa_count = 0;
-+  // As defined in the standards
-+  int backlog_max = 8;
-+  int backlog_min = -8;
-+  int backlog_early_pull_threshold = -6;
-+  bool ctrl_write_mode = false;
-+
-+  // Refresh based on the specified address
-+  void refresh_target(Controller<T>* ctrl, int rank, int bank, int sa)
-+  {
-+    vector<int> addr_vec(int(T::Level::MAX), -1);
-+    addr_vec[0] = ctrl->channel->id;
-+    addr_vec[1] = rank;
-+    addr_vec[2] = bank;
-+    addr_vec[3] = sa;
-+    Request req(addr_vec, Request::Type::REFRESH, NULL);
-+    bool res = ctrl->enqueue(req);
-+    assert(res);
-+  }
-+
-+  // Inject refresh at either rank or bank level
-+  void inject_refresh(bool b_ref_rank) {
-+    // Rank-level refresh
-+    if (b_ref_rank) {
-+      for (auto rank : ctrl->channel->children)
-+        refresh_target(ctrl, rank->id, -1, -1);
-+    }
-+    // Bank-level refresh. Simultaneously issue to all ranks (better performance than staggered refreshes).
-+    else {
-+      for (auto rank : ctrl->channel->children)
-+        refresh_target(ctrl, rank->id, bank_ref_counters[rank->id], -1);
-+    }
-+    refreshed = clk;
-+  }
-+
-+  // DSARP
-+  void early_inject_refresh();
-+  void wrp();
-+};
-+
-+// Declaration of specialized constructor and tick_ref, so the compiler knows
-+// where to look for these definitions when controller calls them!
-+template<> Refresh<DSARP>::Refresh(Controller<DSARP>* ctrl);
-+template<> void Refresh<DSARP>::tick_ref();
-+
-+} /* namespace ramulator */
-+
-+#endif /* SRC_REFRESH_H_ */
-diff --git a/ext/ramulator/Ramulator/src/Request.h b/ext/ramulator/Ramulator/src/Request.h
-new file mode 100644
-index 0000000..da73396
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Request.h
-@@ -0,0 +1,103 @@
-+#ifndef __REQUEST_H
-+#define __REQUEST_H
-+
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class Request
-+{
-+public:
-+    bool is_first_command;
-+    long addr;
-+    // long addr_row;
-+    vector<int> addr_vec;
-+    // specify which core this request sent from, for virtual address translation
-+    int coreid;
-+
-+    enum class Type
-+    {
-+        READ,
-+        WRITE,
-+        REFRESH,
-+        POWERDOWN,
-+        SELFREFRESH,
-+        EXTENSION,
-+        MAX
-+    } type;
-+
-+    long arrive = -1;
-+    long depart;
-+    function<void(Request&)> callback; // call back with more info
-+    // gagan : is prefetch
-+    bool is_prefetch;
-+
-+ Request(long addr, Type type, int coreid = 0)
-+      : is_first_command(true), addr(addr), coreid(coreid), type(type), callback([](Request& req){}), is_prefetch(false) {}
-+
-+ Request(long addr, Type type, function<void(Request&)> callback,  bool is_prefetch, int coreid = 0)
-+   : is_first_command(true), addr(addr), coreid(coreid), type(type), callback(callback), is_prefetch(is_prefetch) {}
-+
-+ Request(vector<int>& addr_vec, Type type, function<void(Request&)> callback, bool is_prefetch = false, int coreid = 0)
-+      : is_first_command(true), addr_vec(addr_vec), coreid(coreid), type(type), callback(callback) {}
-+
-+    Request()
-+        : is_first_command(true), coreid(0) {}
-+
-+    void print()
-+    {
-+      switch(type)
-+	{
-+	case Request::Type::READ:
-+	  std::cout << "[READ] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-+		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-+	  break;
-+	case Request::Type::WRITE:
-+	  assert(is_prefetch == false);
-+	  std::cout << "[WRITE] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-+		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-+	  break;
-+	case Request::Type::REFRESH:
-+	  assert(is_prefetch == false);
-+	  std::cout << "[REFRESH] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-+		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-+	  break;
-+	case Request::Type::POWERDOWN:
-+	  assert(is_prefetch == false);
-+	  std::cout << "[POWERDOWN] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-+		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-+	  break;
-+	case Request::Type::SELFREFRESH:
-+	  assert(is_prefetch == false);
-+	  std::cout << "[SELFREFRESH] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-+		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-+	  break;
-+	case Request::Type::EXTENSION:
-+	  assert(is_prefetch == false);
-+	  std::cout << "[EXTENSION] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-+		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-+	  break;
-+	case Request::Type::MAX:
-+	  assert(is_prefetch == false);
-+	  std::cout << "[MAX] pa[0x" << std::hex << addr << "] " << std::dec << " r[" << addr_vec[1] << "] bg[" << addr_vec[2] << "] b["
-+		    << addr_vec[3] << "] ch[" << addr_vec[0] << "] row[" << addr_vec[4] << "] col[" << addr_vec[5] << "]" << std::endl;
-+	  break;
-+	default:
-+	  std::cout << "Invalid Request" << std::endl;
-+	}
-+    }
-+
-+    int getRank()
-+    {
-+      return addr_vec[1];
-+    }
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__REQUEST_H*/
-+
-diff --git a/ext/ramulator/Ramulator/src/SALP.cpp b/ext/ramulator/Ramulator/src/SALP.cpp
-new file mode 100644
-index 0000000..843e5f6
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/SALP.cpp
-@@ -0,0 +1,648 @@
-+#include "SALP.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace ramulator;
-+
-+string SALP::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Sa", "Ro", "Co"};
-+
-+map<string, enum SALP::Org> SALP::org_map = {
-+    {"SALP_512Mb_x4", SALP::Org::SALP_512Mb_x4}, {"SALP_512Mb_x8", SALP::Org::SALP_512Mb_x8}, {"SALP_512Mb_x16", SALP::Org::SALP_512Mb_x16},
-+    {"SALP_1Gb_x4", SALP::Org::SALP_1Gb_x4}, {"SALP_1Gb_x8", SALP::Org::SALP_1Gb_x8}, {"SALP_1Gb_x16", SALP::Org::SALP_1Gb_x16},
-+    {"SALP_2Gb_x4", SALP::Org::SALP_2Gb_x4}, {"SALP_2Gb_x8", SALP::Org::SALP_2Gb_x8}, {"SALP_2Gb_x16", SALP::Org::SALP_2Gb_x16},
-+    {"SALP_4Gb_x4", SALP::Org::SALP_4Gb_x4}, {"SALP_4Gb_x8", SALP::Org::SALP_4Gb_x8}, {"SALP_4Gb_x16", SALP::Org::SALP_4Gb_x16},
-+    {"SALP_8Gb_x4", SALP::Org::SALP_8Gb_x4}, {"SALP_8Gb_x8", SALP::Org::SALP_8Gb_x8}, {"SALP_8Gb_x16", SALP::Org::SALP_8Gb_x16},
-+};
-+
-+map<string, enum SALP::Speed> SALP::speed_map = {
-+    {"SALP_800D", SALP::Speed::SALP_800D}, {"SALP_800E", SALP::Speed::SALP_800E},
-+    {"SALP_1066E", SALP::Speed::SALP_1066E}, {"SALP_1066F", SALP::Speed::SALP_1066F}, {"SALP_1066G", SALP::Speed::SALP_1066G},
-+    {"SALP_1333G", SALP::Speed::SALP_1333G}, {"SALP_1333H", SALP::Speed::SALP_1333H},
-+    {"SALP_1600H", SALP::Speed::SALP_1600H}, {"SALP_1600J", SALP::Speed::SALP_1600J}, {"SALP_1600K", SALP::Speed::SALP_1600K},
-+    {"SALP_1866K", SALP::Speed::SALP_1866K}, {"SALP_1866L", SALP::Speed::SALP_1866L},
-+    {"SALP_2133L", SALP::Speed::SALP_2133L}, {"SALP_2133M", SALP::Speed::SALP_2133M},
-+};
-+
-+map<string, enum SALP::Type> SALP::type_map = {
-+    {"SALP-1", SALP::Type::SALP_1},
-+    {"SALP-2", SALP::Type::SALP_2},
-+    {"SALP-MASA", SALP::Type::MASA},
-+};
-+
-+SALP::SALP(Org org, Speed speed, Type type, int n_sa) :
-+    type(type),
-+    n_sa(n_sa),
-+    org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    switch(int(type)){
-+        case int(Type::SALP_1): standard_name = "SALP-1"; break;
-+        case int(Type::SALP_2): standard_name = "SALP-2"; break;
-+        case int(Type::MASA):   standard_name = "SALP-MASA"; break;
-+    }
-+    if (type == Type::SALP_1) {
-+      scope[int(Command::PRE)] = Level::Bank;
-+    }
-+    assert(n_sa && n_sa <= 128 && (n_sa & (n_sa-1)) == 0); // is power of 2, within [1, 128]
-+    org_entry.count[int(Level::SubArray)] = n_sa;
-+    long tmp = long(org_entry.dq) * org_entry.count[int(Level::Bank)] * n_sa * org_entry.count[int(Level::Column)];
-+    org_entry.count[int(Level::Row)] = long(org_entry.size) * (1<<20) / tmp;
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+SALP::SALP(const string& org_str, const string& speed_str, const string& type_str, int n_sa) :
-+    SALP(org_map[org_str], speed_map[speed_str], type_map[type_str], n_sa)
-+{
-+}
-+
-+void SALP::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void SALP::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void SALP::init_speed()
-+{
-+    // nRRD, nFAW
-+    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4; speed_entry.nFAW = (page==1) ? 16 : 20; break;
-+        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6; speed_entry.nFAW = (page==1) ? 20 : 27; break;
-+        case 1333: speed_entry.nRRD = (page==1) ? 4 : 5; speed_entry.nFAW = (page==1) ? 20 : 30; break;
-+        case 1600: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 24 : 32; break;
-+        case 1866: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 26 : 33; break;
-+        case 2133: speed_entry.nRRD = (page==1) ? 5 : 6; speed_entry.nFAW = (page==1) ? 27 : 34; break;
-+        default: assert(false);
-+    }
-+
-+    // nRFC, nXS
-+    int chip = org_entry.size;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44  : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-+        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59  : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-+        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74  : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-+        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88  : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-+        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103 : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-+        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118 : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-+        default: assert(false);
-+    }
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48  : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-+        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64  : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-+        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80  : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-+        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-+        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112 : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-+        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128 : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-+        default: assert(false);
-+    }
-+}
-+
-+
-+void SALP::init_prereq()
-+{
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+
-+    switch(int(type)){
-+        case int(Type::SALP_1):
-+            prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return Command::ACT;
-+                    case int(State::Opened):
-+                        return Command::MAX;
-+                    default: assert(false);}};
-+            prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+              if (node->row_state.find(id) != node->row_state.end()) {
-+                return cmd;
-+              } else if (node->row_state.size()) {
-+                return Command::PRE;
-+              } else {
-+                return Command::PRE_OTHER;
-+              }
-+            };
-+            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-+            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                for (auto bank : node->children) {
-+                    if (bank->state == State::Closed)
-+                        continue;
-+                    return Command::PRER;
-+                }
-+                return Command::REF;};
-+            break;
-+        case int(Type::SALP_2):
-+            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return Command::ACT;
-+                    case int(State::Opened):
-+                        if (node->row_state.find(id) != node->row_state.end()) {
-+                          for (auto sa : node->parent->children) {
-+                              if (sa != node && sa->state == State::Opened) {
-+                                  return Command::PRE_OTHER;
-+                              }
-+                          }
-+                          return cmd;
-+                        } else {
-+                          // if this subarray has another row open, close it
-+                          // first
-+                          return Command::PRE;
-+                        }
-+                    default: assert(false);}};
-+            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-+            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                for (auto bank : node->children)
-+                    for (auto sa : bank->children) {
-+                        if (sa->state == State::Closed)
-+                            continue;
-+                        return Command::PRER;
-+                    }
-+                return Command::REF;};
-+            break;
-+        case int(Type::MASA):
-+            prereq[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return Command::ACT;
-+                    case int(State::Opened):
-+                        if (node->row_state.find(id) != node->row_state.end()) return Command::SASEL;
-+                        else return Command::PRE;
-+                    case int(State::Selected):
-+                        if (node->row_state.find(id) != node->row_state.end()) return cmd;
-+                        else return Command::PRE;
-+                    default: assert(false);
-+                }};
-+            prereq[int(Level::SubArray)][int(Command::WR)] = prereq[int(Level::SubArray)][int(Command::RD)];
-+            prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                for (auto bank : node->children)
-+                    for (auto sa : bank->children){
-+                        if (sa->state == State::Closed)
-+                            continue;
-+                        return Command::PRER;
-+                    }
-+                return Command::REF;};
-+            break;
-+        default: assert(false);
-+    }
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void SALP::init_rowhit()
-+{
-+    switch(int(type)) {
-+        case int(Type::SALP_1):
-+            // RD
-+            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+              switch (int(node->state)) {
-+                case int(State::Closed): return false;
-+                case int(State::Opened):
-+                  if (node->row_state.find(id) != node->row_state.end())  return true;
-+                  else return false;
-+                default: assert(false);
-+              }
-+            };
-+            // WR
-+            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-+            break;
-+        case int(Type::SALP_2):
-+            // RD
-+            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return false;
-+                    case int(State::Opened):
-+                        if (node->row_state.find(id) != node->row_state.end()) return true;
-+                        else return false;
-+                    default: assert(false);
-+                }};
-+            // WR
-+            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-+            break;
-+        case int(Type::MASA):
-+            // RD
-+            rowhit[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return false;
-+                    case int(State::Opened):
-+                        // opened but not selected still counts as a row hit
-+                        if (node->row_state.find(id) != node->row_state.end()) return true;
-+                        else return false;
-+                    case int(State::Selected):
-+                        if (node->row_state.find(id) != node->row_state.end()) return true;
-+                        else return false;
-+                    default: assert(false);
-+                }};
-+            // WR
-+            rowhit[int(Level::SubArray)][int(Command::WR)] = rowhit[int(Level::SubArray)][int(Command::RD)];
-+            break;
-+        default: assert(false);
-+    }
-+}
-+
-+void SALP::init_rowopen()
-+{
-+    switch(int(type)) {
-+        case int(Type::SALP_1):
-+            // RD
-+            rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return false;
-+                    case int(State::Opened): return true;
-+                    default: assert(false);
-+                }};
-+            // WR
-+            rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+            break;
-+        case int(Type::SALP_2):
-+            // RD
-+            rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return false;
-+                    case int(State::Opened): return true;
-+                    default: assert(false);
-+                }};
-+            // WR
-+            rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-+            break;
-+        case int(Type::MASA):
-+            // RD
-+            rowopen[int(Level::SubArray)][int(Command::RD)] = [] (DRAM<SALP>* node, Command cmd, int id) {
-+                switch (int(node->state)){
-+                    case int(State::Closed): return false;
-+                    case int(State::Opened): return true;
-+                    case int(State::Selected): return true;
-+                    default: assert(false);
-+                }};
-+            // WR
-+            rowopen[int(Level::SubArray)][int(Command::WR)] = rowopen[int(Level::SubArray)][int(Command::RD)];
-+            break;
-+        default: assert(false);
-+    }
-+}
-+
-+void SALP::init_lambda()
-+{
-+    switch(int(type)){
-+        case int(Type::SALP_1):
-+            lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Opened;
-+            };
-+            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-+              node->state = State::Opened;
-+              node->row_state[id] = State::Opened;
-+            };
-+            lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                // For SALP_1, we stick to original design that allows
-+                // only one row in a bank open, so here close subarray id
-+                // is equivalent to close the whole bank
-+                node->children[id]->state = State::Closed;
-+                node->children[id]->row_state.clear();
-+                };
-+            lambda[int(Level::Bank)][int(Command::PRE_OTHER)] = lambda[int(Level::Bank)][int(Command::PRE)];
-+            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-+                for (auto bank : node->children) {
-+                    bank->state = State::Closed;
-+                    for (auto sa : bank->children){
-+                        sa->state = State::Closed;
-+                        sa->row_state.clear();}}};
-+            lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                node->children[id]->state = State::Closed;
-+                node->children[id]->row_state.clear();};
-+            lambda[int(Level::Bank)][int(Command::WRA)] = lambda[int(Level::Bank)][int(Command::RDA)];
-+            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-+                for (auto bank : node->children) {
-+                    if (bank->state == State::Closed)
-+                        continue;
-+                    node->state = State::ActPowerDown;
-+                    return;
-+                }
-+                node->state = State::PrePowerDown;};
-+            break;
-+        case int(Type::SALP_2):
-+            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Opened;
-+                node->row_state[id] = State::Opened;};
-+            lambda[int(Level::SubArray)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                node->row_state.clear();};
-+            lambda[int(Level::SubArray)][int(Command::PRE_OTHER)] = lambda[int(Level::SubArray)][int(Command::PRE)];
-+            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-+                for (auto bank : node->children)
-+                    for (auto sa : bank->children) {
-+                        sa->state = State::Closed;
-+                        sa->row_state.clear();}};
-+            lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                node->row_state.clear();};
-+            lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                node->row_state.clear();};
-+            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-+                for (auto bank : node->children)
-+                    for (auto sa : bank->children) {
-+                        if (sa->state == State::Closed)
-+                            continue;
-+                        node->state = State::ActPowerDown;
-+                        return;
-+                    }
-+                node->state = State::PrePowerDown;};
-+            break;
-+        case int(Type::MASA):
-+            lambda[int(Level::SubArray)][int(Command::ACT)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Selected;
-+                node->row_state[id] = State::Opened;
-+                for (auto sa : node->parent->children)
-+                    if (sa != node && sa->state == State::Selected) {
-+                        sa->state = State::Opened;
-+                        break;}};
-+            lambda[int(Level::SubArray)][int(Command::SASEL)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Selected;
-+                for (auto sa : node->parent->children)
-+                    if (sa != node && sa->state == State::Selected) {
-+                        sa->state = State::Opened;
-+                        break;}};
-+            lambda[int(Level::SubArray)][int(Command::PRE)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                node->row_state.clear();};
-+
-+            lambda[int(Level::Rank)][int(Command::PRER)] = [] (DRAM<SALP>* node, int id) {
-+                for (auto bank : node->children)
-+                    for (auto sa : bank->children) {
-+                        sa->state = State::Closed;
-+                        sa->row_state.clear();}};
-+            lambda[int(Level::SubArray)][int(Command::RDA)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                node->row_state.clear();};
-+            lambda[int(Level::SubArray)][int(Command::WRA)] = [] (DRAM<SALP>* node, int id) {
-+                node->state = State::Closed;
-+                node->row_state.clear();};
-+            lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<SALP>* node, int id) {
-+                for (auto bank : node->children)
-+                    for (auto sa : bank->children) {
-+                        if (sa->state == State::Closed)
-+                            continue;
-+                        node->state = State::ActPowerDown;
-+                        return;
-+                    }
-+                node->state = State::PrePowerDown;};
-+            break;
-+        default: assert(false);
-+    }
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<SALP>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<SALP>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<SALP>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+void SALP::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    // CAS <-> PRER
-+    t[int(Command::RD)].push_back({Command::PRER, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRER, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> REF: none (all banks have to be precharged)
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+
-+    t[int(Command::ACT)].push_back({Command::PRER, 1, s.nRAS});
-+    t[int(Command::PRER)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PRER)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PRE_OTHER)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRER, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PRER)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PRE_OTHER)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    switch(int(type)) {
-+        case int(Type::SALP_1):
-+          // memory controller doesn't specify a row to precharge,
-+          // all subarrays are precharged together, so we should check
-+          // whether other activation/column access are still ongoing.
-+          t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+          t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+          t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR,});
-+          t[int(Command::ACT)].push_back({Command::PRE_OTHER, 1, s.nRAS});
-+          t[int(Command::RD)].push_back({Command::PRE_OTHER, 1, s.nRTP});
-+          t[int(Command::WR)].push_back({Command::PRE_OTHER, 1, s.nCWL + s.nBL + s.nWR,});
-+        case int(Type::SALP_2):
-+        case int(Type::MASA):
-+        break;
-+        default: assert(false);
-+    }
-+
-+    /*** SubArray ***/
-+    t = timing[int(Level::SubArray)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+
-+    switch(int(type)) {
-+        case int(Type::SALP_1):
-+        case int(Type::SALP_2):
-+        break;
-+        case int(Type::MASA):
-+          t[int(Command::SASEL)].push_back({Command::RD, 1, s.nSCD});
-+          t[int(Command::SASEL)].push_back({Command::RDA, 1, s.nSCD});
-+          t[int(Command::SASEL)].push_back({Command::WR, 1, s.nSCD});
-+          t[int(Command::SASEL)].push_back({Command::WRA, 1, s.nSCD});
-+        break;
-+        default: assert(false);
-+    }
-+
-+    // sibling subarray constraints
-+    switch(int(type)) {
-+        case int(Type::SALP_1):
-+          t[int(Command::PRE)].push_back({Command::ACT, 1, s.nPA, true});
-+          t[int(Command::PRE_OTHER)].push_back({Command::ACT, 1, s.nPA, true});
-+          // for auto precharge command
-+          t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC - s.nRP + s.nPA, true});
-+          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nPA, true});
-+          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nPA, true});
-+        break;
-+
-+        case int(Type::SALP_2):
-+          t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRCD + s.nRA, true});
-+          t[int(Command::RD)].push_back({Command::ACT, 1, s.nRA, true});
-+          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRA, true});
-+          t[int(Command::WR)].push_back({Command::ACT, 1, s.nWA, true});
-+          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nWA, true});
-+        break;
-+        case int(Type::MASA):
-+          t[int(Command::RD)].push_back({Command::ACT, 1, s.nRA, true});
-+          t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRA, true});
-+          t[int(Command::WR)].push_back({Command::ACT, 1, s.nWA, true});
-+          t[int(Command::WRA)].push_back({Command::ACT, 1, s.nWA, true});
-+
-+          t[int(Command::RD)].push_back({Command::SASEL, 1, s.nRA, true});
-+          t[int(Command::RDA)].push_back({Command::SASEL, 1, s.nRA, true});
-+          t[int(Command::WR)].push_back({Command::SASEL, 1, s.nWA, true});
-+          t[int(Command::WRA)].push_back({Command::SASEL, 1, s.nWA, true});
-+
-+          t[int(Command::RD)].push_back({Command::RD, 1, s.nRA, true});
-+          t[int(Command::RDA)].push_back({Command::RDA, 1, s.nRA, true});
-+          t[int(Command::WR)].push_back({Command::WR, 1, s.nWA, true});
-+          t[int(Command::WRA)].push_back({Command::WRA, 1, s.nWA, true});
-+        break;
-+        default: assert(false);
-+    }
-+    // between sibling subarrays
-+}
-diff --git a/ext/ramulator/Ramulator/src/SALP.h b/ext/ramulator/Ramulator/src/SALP.h
-new file mode 100644
-index 0000000..8eceb5a
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/SALP.h
-@@ -0,0 +1,231 @@
-+#ifndef __SALP_H
-+#define __SALP_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class SALP
-+{
-+public:
-+    string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    enum class Type;
-+    SALP(Org org, Speed speed, Type type = Type::MASA, int n_sa = 8);
-+    SALP(const string& org_str, const string& speed_str, const string& type_str = "SALP-MASA", int n_sa = 8);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    static map<string, enum Type> type_map;
-+
-+    enum class Type : int
-+    {
-+        SALP_1, SALP_2, MASA, MAX
-+    } type;
-+    /*** Level ***/
-+    enum class Level : int
-+    { 
-+        Channel, Rank, Bank, SubArray, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    { 
-+        ACT, SASEL, PRE, PRER, // precharge bank/bank/rank(SALP-1), subarray/bank/rank(SALP-2, MASA)
-+        RD,  WR,    RDA, WRA, // auto-precharge: bank(SALP-1), subarray(SALP-2, MASA)
-+        REF, PDE,   PDX, SRE, SRX, 
-+        PRE_OTHER,
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "SASEL", "PRE", "PRER",
-+        "RD",  "WR",    "RDA", "WRA",
-+        "REF", "PDE",   "PDX", "SRE", "SRX", "PRE_OTHER"
-+    };
-+
-+    // The scope of each command
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::SubArray, Level::SubArray, Level::Rank,
-+        Level::Column, Level::Column,   Level::Column,   Level::Column,
-+        Level::Rank,   Level::Rank,     Level::Rank,     Level::Rank,   Level::Rank, Level::SubArray
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PRER):
-+            case int(Command::PRE_OTHER):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, Selected, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<SALP>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<SALP>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<SALP>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<SALP>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        SALP_512Mb_x4, SALP_512Mb_x8, SALP_512Mb_x16,
-+        SALP_1Gb_x4,   SALP_1Gb_x8,   SALP_1Gb_x16,
-+        SALP_2Gb_x4,   SALP_2Gb_x8,   SALP_2Gb_x16,
-+        SALP_4Gb_x4,   SALP_4Gb_x8,   SALP_4Gb_x16,
-+        SALP_8Gb_x4,   SALP_8Gb_x8,   SALP_8Gb_x16,
-+        MAX
-+    };
-+
-+    int n_sa; // number of subarrays per bank
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {  512,  4, {0, 0, 8, 0, 0, 1<<11}}, {  512,  8, {0, 0, 8, 0, 0, 1<<10}}, {  512, 16, {0, 0, 8, 0, 0, 1<<10}},
-+        {1<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {1<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {1<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-+        {2<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {2<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {2<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-+        {4<<10,  4, {0, 0, 8, 0, 0, 1<<11}}, {4<<10,  8, {0, 0, 8, 0, 0, 1<<10}}, {4<<10, 16, {0, 0, 8, 0, 0, 1<<10}},
-+        {8<<10,  4, {0, 0, 8, 0, 0, 1<<12}}, {8<<10,  8, {0, 0, 8, 0, 0, 1<<11}}, {8<<10, 16, {0, 0, 8, 0, 0, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        SALP_800D,  SALP_800E,
-+        SALP_1066E, SALP_1066F, SALP_1066G,
-+        SALP_1333G, SALP_1333H,
-+        SALP_1600H, SALP_1600J, SALP_1600K,
-+        SALP_1866K, SALP_1866L,
-+        SALP_2133L, SALP_2133M,
-+        MAX
-+    };
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS;
-+        int nCL, nRCD, nRP, nPA, nCWL; // nRP for pre2act same sa, nPA for pre2act diff sa (1 cycle)
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR, nRA, nWA; // nRA = nCL/2, nWA = nCWL + nBL + nWR/2
-+        int nRRD, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL;
-+        int nCKESR, nXS, nXSDLL;
-+        int nSCD;
-+    } speed_table[int(Speed::MAX)] = {
-+        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5, 1,  5, 15, 20, 4, 4,  6, 3, 12, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512, 1},
-+        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6, 1,  5, 15, 21, 4, 4,  6, 3, 12, 0, 0, 0, 3120, 3, 3, 10, 4, 0, 512, 1},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6, 1,  6, 20, 26, 4, 4,  8, 3, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7, 1,  6, 20, 27, 4, 4,  8, 4, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8, 1,  6, 20, 28, 4, 4,  8, 4, 14, 0, 0, 0, 4160, 3, 4, 13, 4, 0, 512, 1},
-+        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8, 1,  7, 24, 32, 5, 5, 10, 4, 16, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512, 1},
-+        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9, 1,  7, 24, 33, 5, 5, 10, 5, 16, 0, 0, 0, 5200, 4, 4, 16, 5, 0, 512, 1},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9, 1,  8, 28, 37, 6, 6, 12, 5, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10, 1,  8, 28, 38, 6, 6, 12, 5, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11, 1,  8, 28, 39, 6, 6, 12, 6, 18, 0, 0, 0, 6240, 4, 5, 20, 5, 0, 512, 1},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11, 1,  9, 32, 43, 7, 7, 14, 6, 20, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512, 1},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12, 1,  9, 32, 44, 7, 7, 14, 6, 20, 0, 0, 0, 7280, 5, 6, 23, 6, 0, 512, 1},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 1, 10, 36, 48, 8, 8, 16, 6, 22, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512, 1},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 1, 10, 36, 49, 8, 8, 16, 7, 22, 0, 0, 0, 8320, 6, 7, 26, 7, 0, 512, 1}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__SALP_H*/
-diff --git a/ext/ramulator/Ramulator/src/STTMRAM.cpp b/ext/ramulator/Ramulator/src/STTMRAM.cpp
-new file mode 100644
-index 0000000..830867c
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/STTMRAM.cpp
-@@ -0,0 +1,347 @@
-+/*
-+*
-+* The timing parameters used in this file are provided by the following study:
-+* Kazi Asifuzzaman, Rommel Sanchez Verdejo, and Petar Radojkovic.2017.
-+* Enabling a reliable STT-MRAM main memory simulation.
-+* In Proceedings of the International Symposium on Memory Systems (MEMSYS '17).
-+* Washington DC, USA, 283-292. DOI: https://doi.org/10.1145/3132402.3132416
-+*
-+*/
-+#include "STTMRAM.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+#include <math.h>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string STTMRAM::standard_name = "STTMRAM";
-+string STTMRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum STTMRAM::Org> STTMRAM::org_map = {
-+    {"STTMRAM_512Mb_x4", STTMRAM::Org::STTMRAM_512Mb_x4}, {"STTMRAM_512Mb_x8", STTMRAM::Org::STTMRAM_512Mb_x8}, {"STTMRAM_512Mb_x16", STTMRAM::Org::STTMRAM_512Mb_x16},
-+    {"STTMRAM_1Gb_x4", STTMRAM::Org::STTMRAM_1Gb_x4}, {"STTMRAM_1Gb_x8", STTMRAM::Org::STTMRAM_1Gb_x8}, {"STTMRAM_1Gb_x16", STTMRAM::Org::STTMRAM_1Gb_x16},
-+    {"STTMRAM_2Gb_x4", STTMRAM::Org::STTMRAM_2Gb_x4}, {"STTMRAM_2Gb_x8", STTMRAM::Org::STTMRAM_2Gb_x8}, {"STTMRAM_2Gb_x16", STTMRAM::Org::STTMRAM_2Gb_x16},
-+    {"STTMRAM_4Gb_x4", STTMRAM::Org::STTMRAM_4Gb_x4}, {"STTMRAM_4Gb_x8", STTMRAM::Org::STTMRAM_4Gb_x8}, {"STTMRAM_4Gb_x16", STTMRAM::Org::STTMRAM_4Gb_x16},
-+    {"STTMRAM_8Gb_x4", STTMRAM::Org::STTMRAM_8Gb_x4}, {"STTMRAM_8Gb_x8", STTMRAM::Org::STTMRAM_8Gb_x8}, {"STTMRAM_8Gb_x16", STTMRAM::Org::STTMRAM_8Gb_x16},
-+};
-+
-+map<string, enum STTMRAM::Speed> STTMRAM::speed_map = {
-+    {"STT_1600_1_2", STTMRAM::Speed::STT_1600_1_2}, {"STT_1600_1_5", STTMRAM::Speed::STT_1600_1_5}, {"STT_1600_2_0", STTMRAM::Speed::STT_1600_2_0},
-+};
-+
-+
-+STTMRAM::STTMRAM(Org org, Speed speed) :
-+    org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+STTMRAM::STTMRAM(const string& org_str, const string& speed_str) :
-+    STTMRAM(org_map[org_str], speed_map[speed_str])
-+{
-+}
-+
-+void STTMRAM::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void STTMRAM::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void STTMRAM::init_speed()
-+{
-+    // nRRD, nFAW
-+    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-+    switch (speed_entry.rate) {
-+          case 1600: speed_entry.nRRD = ceil(speed_entry.nRRD  * ((page==1) ? 5 : 6) /10.0); speed_entry.nFAW = ceil(speed_entry.nFAW *((page==1) ? 24 : 32)/10.0); break;
-+        default: assert(false);
-+    }
-+
-+    // nRFC, nXS
-+    int chip = org_entry.size;
-+    switch (speed_entry.rate) {
-+        case 1600: speed_entry.nRFC = 1; break;
-+        default: assert(false);
-+    }
-+    switch (speed_entry.rate) {
-+          case 1600: speed_entry.nXS  = ceil(speed_entry.nXS * ((chip==512) ? 80  : (chip==1<<10) ? 96  : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288) /10.0); break;
-+        default: assert(false);
-+    }
-+}
-+
-+
-+void STTMRAM::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PREA;
-+        }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }};
-+}
-+
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void STTMRAM::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void STTMRAM::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void STTMRAM::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<STTMRAM>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<STTMRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<STTMRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<STTMRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<STTMRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<STTMRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<STTMRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<STTMRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<STTMRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<STTMRAM>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<STTMRAM>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<STTMRAM>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void STTMRAM::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::PREA)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+}
-diff --git a/ext/ramulator/Ramulator/src/STTMRAM.h b/ext/ramulator/Ramulator/src/STTMRAM.h
-new file mode 100644
-index 0000000..1698b1a
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/STTMRAM.h
-@@ -0,0 +1,213 @@
-+/*
-+*
-+* The timing parameters used in this file are provided by the following study:
-+* Kazi Asifuzzaman, Rommel Sanchez Verdejo, and Petar Radojkovic.2017.
-+* Enabling a reliable STT-MRAM main memory simulation.
-+* In Proceedings of the International Symposium on Memory Systems (MEMSYS '17).
-+* Washington DC, USA, 283-292. DOI: https://doi.org/10.1145/3132402.3132416
-+*
-+*/
-+#ifndef __STTMRAM_H
-+#define __STTMRAM_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <map>
-+#include <string>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class STTMRAM
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    STTMRAM(Org org, Speed speed);
-+    STTMRAM(const string& org_str, const string& speed_str);
-+
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    /*** Level ***/
-+    enum class Level : int
-+    {
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    {
-+        ACT, PRE, PREA,
-+        RD,  WR,  RDA,  WRA,
-+        REF, PDE, PDX,  SRE, SRX,
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA",
-+        "RD",  "WR",  "RDA",  "WRA",
-+        "REF", "PDE", "PDX",  "SRE", "SRX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PREA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<STTMRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<STTMRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<STTMRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    };
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<STTMRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        STTMRAM_512Mb_x4, STTMRAM_512Mb_x8, STTMRAM_512Mb_x16,
-+        STTMRAM_1Gb_x4,   STTMRAM_1Gb_x8,   STTMRAM_1Gb_x16,
-+        STTMRAM_2Gb_x4,   STTMRAM_2Gb_x8,   STTMRAM_2Gb_x16,
-+        STTMRAM_4Gb_x4,   STTMRAM_4Gb_x8,   STTMRAM_4Gb_x16,
-+        STTMRAM_8Gb_x4,   STTMRAM_8Gb_x8,   STTMRAM_8Gb_x16,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {  512,  4, {0, 0, 8, 1<<13, 1<<11}}, {  512,  8, {0, 0, 8, 1<<13, 1<<10}}, {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-+        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}}, {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}}, {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-+        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}}, {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}}, {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-+        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}}, {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}}, {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-+        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}}, {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}}, {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        STT_1600_1_2, STT_1600_1_5, STT_1600_2_0,
-+        MAX
-+    };
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRD, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL;
-+        int nCKESR, nXS, nXSDLL;
-+    } speed_table[int(Speed::MAX)] = {
-+          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 14,  14,  8,   20,   34,  6,    6,   12,  12,   12,   1,    6240, 4, 5, 20,        5,     0,   512}, //1.2x
-+          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 17,  17,  8,   23,   40,  6,    6,   12,  15,   15,   1,    6240, 4, 5, 20,        5,     0,   512}, //1.5x
-+          {1600, (400.0/3)*6, 1.25, 4, 4,   2,   11, 22,  22,  8,   28,   50,  6,    6,   12,  20,   20,   1,    6240, 4, 5, 20,        5,     0,   512}, //2.0x
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__STTMRAM_H*/
-diff --git a/ext/ramulator/Ramulator/src/Scheduler.h b/ext/ramulator/Ramulator/src/Scheduler.h
-new file mode 100644
-index 0000000..0a328c3
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Scheduler.h
-@@ -0,0 +1,357 @@
-+#ifndef __SCHEDULER_H
-+#define __SCHEDULER_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include "Controller.h"
-+#include <vector>
-+#include <map>
-+#include <list>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+template <typename T>
-+class Controller;
-+
-+template <typename T>
-+class Scheduler
-+{
-+public:
-+    Controller<T>* ctrl;
-+
-+    enum class Type {
-+      FCFS, FRFCFS, FRFCFS_Cap, FRFCFS_PriorHit, FRFCFS_DepPre, MAX
-+    } type = Type::FRFCFS_PriorHit;
-+    //} type = Type::FCFS;
-+
-+    long cap = 16;
-+
-+    Scheduler(Controller<T>* ctrl) : ctrl(ctrl) {}
-+
-+    list<Request>::iterator get_head(list<Request>& q)
-+    {
-+      // TODO make the decision at compile time
-+      if (type != Type::FRFCFS_PriorHit) {
-+        if (!q.size())
-+            return q.end();
-+
-+        auto head = q.begin();
-+        for (auto itr = next(q.begin(), 1); itr != q.end(); itr++)
-+            head = compare[int(type)](head, itr);
-+
-+        return head;
-+      } else {
-+        if (!q.size())
-+            return q.end();
-+
-+        auto head = q.begin();
-+        for (auto itr = next(q.begin(), 1); itr != q.end(); itr++) {
-+            head = compare[int(Type::FRFCFS_PriorHit)](head, itr);
-+        }
-+
-+        if (this->ctrl->is_ready(head) && this->ctrl->is_row_hit(head)) {
-+          return head;
-+        }
-+
-+        // prepare a list of hit request
-+        vector<vector<int>> hit_reqs;
-+        for (auto itr = q.begin() ; itr != q.end() ; ++itr) {
-+          if (this->ctrl->is_row_hit(itr)) {
-+            auto begin = itr->addr_vec.begin();
-+            // TODO Here it assumes all DRAM standards use PRE to close a row
-+            // It's better to make it more general.
-+            auto end = begin + int(ctrl->channel->spec->scope[int(T::Command::PRE)]) + 1;
-+            vector<int> rowgroup(begin, end); // bank or subarray
-+            hit_reqs.push_back(rowgroup);
-+          }
-+        }
-+        // if we can't find proper request, we need to return q.end(),
-+        // so that no command will be scheduled
-+        head = q.end();
-+        for (auto itr = q.begin(); itr != q.end(); itr++) {
-+          bool violate_hit = false;
-+          if ((!this->ctrl->is_row_hit(itr)) && this->ctrl->is_row_open(itr)) {
-+            // so the next instruction to be scheduled is PRE, might violate hit
-+            auto begin = itr->addr_vec.begin();
-+            // TODO Here it assumes all DRAM standards use PRE to close a row
-+            // It's better to make it more general.
-+            auto end = begin + int(ctrl->channel->spec->scope[int(T::Command::PRE)]) + 1;
-+            vector<int> rowgroup(begin, end); // bank or subarray
-+            for (const auto& hit_req_rowgroup : hit_reqs) {
-+              if (rowgroup == hit_req_rowgroup) {
-+                  violate_hit = true;
-+                  break;
-+              }
-+            }
-+          }
-+          if (violate_hit) {
-+            continue;
-+          }
-+          // If it comes here, that means it won't violate any hit request
-+          if (head == q.end()) {
-+            head = itr;
-+          } else {
-+            head = compare[int(Type::FRFCFS)](head, itr);
-+          }
-+        }
-+
-+        return head;
-+      }
-+    }
-+
-+private:
-+    typedef list<Request>::iterator ReqIter;
-+    function<ReqIter(ReqIter, ReqIter)> compare[int(Type::MAX)] = {
-+        // FCFS
-+        [this] (ReqIter req1, ReqIter req2) {
-+            if (req1->arrive <= req2->arrive) return req1;
-+            return req2;},
-+
-+        // FRFCFS
-+        [this] (ReqIter req1, ReqIter req2) {
-+            bool ready1 = this->ctrl->is_ready(req1);
-+            bool ready2 = this->ctrl->is_ready(req2);
-+
-+            if (ready1 ^ ready2) {
-+                if (ready1) return req1;
-+                return req2;
-+            }
-+
-+            if (req1->arrive <= req2->arrive) return req1;
-+            return req2;},
-+
-+        // FRFCFS_CAP
-+        [this] (ReqIter req1, ReqIter req2) {
-+            bool ready1 = this->ctrl->is_ready(req1);
-+            bool ready2 = this->ctrl->is_ready(req2);
-+
-+            ready1 = ready1 && (this->ctrl->rowtable->get_hits(req1->addr_vec) <= this->cap);
-+            ready2 = ready2 && (this->ctrl->rowtable->get_hits(req2->addr_vec) <= this->cap);
-+
-+            if (ready1 ^ ready2) {
-+                if (ready1) return req1;
-+                return req2;
-+            }
-+
-+            if (req1->arrive <= req2->arrive) return req1;
-+            return req2;},
-+	
-+        // FRFCFS_PriorHit
-+        [this] (ReqIter req1, ReqIter req2) {
-+            bool ready1 = this->ctrl->is_ready(req1) && this->ctrl->is_row_hit(req1);
-+            bool ready2 = this->ctrl->is_ready(req2) && this->ctrl->is_row_hit(req2);
-+
-+            if (ready1 ^ ready2) {
-+                if (ready1) return req1;
-+                return req2;
-+            }
-+
-+            if (req1->arrive <= req2->arrive) return req1;
-+            return req2;},
-+
-+	// gagan : FRFCFS_DepPre
-+	[this] (ReqIter req1, ReqIter req2) {
-+            bool ready1 = this->ctrl->is_ready(req1);
-+            bool ready2 = this->ctrl->is_ready(req2);
-+
-+            if (ready1 ^ ready2) {
-+                if (ready1) return req1;
-+                return req2;
-+            }
-+
-+	    if (req1->is_prefetch ^ req2->is_prefetch) {
-+	      if (req1->is_prefetch) return req2;
-+	      return req1;
-+	    }
-+
-+            if (req1->arrive <= req2->arrive) return req1;
-+            return req2;},
-+
-+    };
-+};
-+
-+
-+template <typename T>
-+class RowPolicy
-+{
-+public:
-+    Controller<T>* ctrl;
-+
-+    enum class Type {
-+        Closed, ClosedAP, Opened, Timeout, MAX
-+    } type = Type::Timeout;
-+    // } type = Type::Closed;
-+    // } type = Type::Opened;
-+
-+    int timeout = 200;
-+
-+    RowPolicy(Controller<T>* ctrl) : ctrl(ctrl) {}
-+
-+    vector<int> get_victim(typename T::Command cmd)
-+    {
-+        return policy[int(type)](cmd);
-+    }
-+
-+private:
-+    function<vector<int>(typename T::Command)> policy[int(Type::MAX)] = {
-+        // Closed
-+        [this] (typename T::Command cmd) -> vector<int> {
-+            for (auto& kv : this->ctrl->rowtable->table) {
-+                if (!this->ctrl->is_ready(cmd, kv.first))
-+                    continue;
-+                return kv.first;
-+            }
-+            return vector<int>();},
-+
-+        // ClosedAP
-+        [this] (typename T::Command cmd) -> vector<int> {
-+            for (auto& kv : this->ctrl->rowtable->table) {
-+                if (!this->ctrl->is_ready(cmd, kv.first))
-+                    continue;
-+                return kv.first;
-+            }
-+            return vector<int>();},
-+
-+        // Opened
-+        [this] (typename T::Command cmd) {
-+            return vector<int>();},
-+
-+        // Timeout
-+        [this] (typename T::Command cmd) -> vector<int> {
-+            for (auto& kv : this->ctrl->rowtable->table) {
-+                auto& entry = kv.second;
-+                if (this->ctrl->clk - entry.timestamp < timeout)
-+                    continue;
-+                if (!this->ctrl->is_ready(cmd, kv.first))
-+                    continue;
-+                return kv.first;
-+            }
-+            return vector<int>();}
-+    };
-+
-+};
-+
-+
-+template <typename T>
-+class RowTable
-+{
-+public:
-+    Controller<T>* ctrl;
-+
-+    struct Entry {
-+        int row;
-+        int hits;
-+        long timestamp;
-+    };
-+
-+    map<vector<int>, Entry> table;
-+
-+    RowTable(Controller<T>* ctrl) : ctrl(ctrl) {}
-+
-+    // gagan : rowtable print
-+    void print()
-+    {
-+      int ch = ctrl->channel->id;
-+      std::cout << "Channel: " << ch << std::endl;
-+      for(int ra = 0; ra < ctrl->channel->children.size(); ra++)
-+	{
-+	  for(int bg = 0; bg < 4; bg++)
-+	    for(int ba = 0; ba < 4; ba++)
-+	      {
-+		auto found = table.find({ch, ra, bg, ba});
-+		if(found != table.end())
-+		  {
-+		    std::cout << "[" << found->second.row << "] ";
-+		  }
-+		else
-+		  {
-+		    std::cout << "[Closed] ";
-+		  }
-+	      }
-+	  std::cout << std::endl;
-+	}
-+    }
-+
-+    void update(typename T::Command cmd, const vector<int>& addr_vec, long clk)
-+    {
-+        auto begin = addr_vec.begin();
-+        auto end = begin + int(T::Level::Row);
-+        vector<int> rowgroup(begin, end); // bank or subarray
-+        int row = *end;
-+
-+        T* spec = ctrl->channel->spec;
-+
-+        if (spec->is_opening(cmd))
-+            table.insert({rowgroup, {row, 0, clk}});
-+
-+        if (spec->is_accessing(cmd)) {
-+            // we are accessing a row -- update its entry
-+            auto match = table.find(rowgroup);
-+            assert(match != table.end());
-+            assert(match->second.row == row);
-+            match->second.hits++;
-+            match->second.timestamp = clk;
-+        } /* accessing */
-+
-+        if (spec->is_closing(cmd)) {
-+          // we are closing one or more rows -- remove their entries
-+          int n_rm = 0;
-+          int scope;
-+          if (spec->is_accessing(cmd))
-+            scope = int(T::Level::Row) - 1; //special condition for RDA and WRA
-+          else
-+            scope = int(spec->scope[int(cmd)]);
-+
-+          for (auto it = table.begin(); it != table.end();) {
-+            if (equal(begin, begin + scope + 1, it->first.begin())) {
-+              n_rm++;
-+              it = table.erase(it);
-+            }
-+            else
-+              it++;
-+          }
-+
-+          assert(n_rm > 0);
-+        } /* closing */
-+    }
-+
-+    int get_hits(const vector<int>& addr_vec, const bool to_opened_row = false)
-+    {
-+        auto begin = addr_vec.begin();
-+        auto end = begin + int(T::Level::Row);
-+
-+        vector<int> rowgroup(begin, end);
-+        int row = *end;
-+
-+        auto itr = table.find(rowgroup);
-+        if (itr == table.end())
-+            return 0;
-+
-+        if(!to_opened_row && (itr->second.row != row))
-+            return 0;
-+
-+        return itr->second.hits;
-+    }
-+
-+    int get_open_row(const vector<int>& addr_vec) {
-+        auto begin = addr_vec.begin();
-+        auto end = begin + int(T::Level::Row);
-+
-+        vector<int> rowgroup(begin, end);
-+
-+        auto itr = table.find(rowgroup);
-+        if(itr == table.end())
-+            return -1;
-+
-+        return itr->second.row;
-+    }
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__SCHEDULER_H*/
-diff --git a/ext/ramulator/Ramulator/src/SpeedyController.h b/ext/ramulator/Ramulator/src/SpeedyController.h
-new file mode 100644
-index 0000000..f234633
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/SpeedyController.h
-@@ -0,0 +1,304 @@
-+#ifndef __SPEEDYCONTROLLER_H
-+#define __SPEEDYCONTROLLER_H
-+
-+#include "Config.h"
-+#include "DRAM.h"
-+#include "Request.h"
-+#include "Statistics.h"
-+#include <iostream>
-+#include <fstream>
-+#include <vector>
-+#include <string>
-+#include <algorithm>
-+#include <cassert>
-+#include <utility>
-+#include <queue>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+template <typename T>
-+class SpeedyController
-+// A FR-FCFS Open Row Controller, optimized for simulation speed.
-+// Not For SALP-2
-+{
-+protected:
-+  ScalarStat row_hits;
-+  ScalarStat row_misses;
-+private:
-+    class compair_depart_clk{
-+    public:
-+        bool operator()(const Request& lhs, const Request& rhs) {
-+            return lhs.depart > rhs.depart;
-+        }
-+    };
-+public:
-+    /* Command trace for DRAMPower 3.1 */
-+    string cmd_trace_prefix = "cmd-trace-";
-+    vector<ofstream> cmd_trace_files;
-+    bool record_cmd_trace = false;
-+    /* Commands to stdout */
-+    bool print_cmd_trace = false;
-+    /* Member Variables */
-+    const unsigned int queue_capacity = 32;
-+    long clk = 0;
-+    DRAM<T>* channel;
-+
-+    double write_hi = 0.875;
-+    double write_low = 0.5;
-+
-+    // request, first command, earliest clk
-+    typedef tuple<Request, typename T::Command, long> request_info;
-+    typedef vector<request_info> request_queue;
-+    request_queue readq;   // queue for read requests
-+    request_queue writeq;  // queue for write requests
-+    request_queue otherq;  // queue for all "other" requests (e.g., refresh)
-+
-+    // read requests that are about to receive data from DRAM
-+    priority_queue<Request, vector<Request>, compair_depart_clk> pending;
-+
-+    bool write_mode = false;  // whether write requests should be prioritized over reads
-+    long refreshed = 0;  // last time refresh requests were generated
-+
-+    /* Constructor */
-+    SpeedyController(const Config& configs, DRAM<T>* channel) :
-+        channel(channel)
-+    {
-+        record_cmd_trace = configs.record_cmd_trace();
-+        print_cmd_trace = configs.print_cmd_trace();
-+        if (record_cmd_trace){
-+            string prefix = cmd_trace_prefix + "chan-" + to_string(channel->id) + "-rank-";
-+            string suffix = ".cmdtrace";
-+            for (unsigned int i = 0; i < channel->children.size(); i++)
-+                cmd_trace_files.emplace_back(prefix + to_string(i) + suffix);
-+        }
-+        readq.reserve(queue_capacity);
-+        writeq.reserve(queue_capacity);
-+        otherq.reserve(queue_capacity);
-+
-+        // regStats
-+
-+        row_hits
-+            .name("row_hits_channel_"+to_string(channel->id))
-+            .desc("Number of row hits")
-+            .precision(0)
-+            ;
-+        row_misses
-+            .name("row_misses_channel_"+to_string(channel->id))
-+            .desc("Number of row misses")
-+            .precision(0)
-+            ;
-+    }
-+
-+    ~SpeedyController(){
-+        delete channel;
-+        for (auto& file : cmd_trace_files)
-+            file.close();
-+    }
-+
-+    /* Member Functions */
-+
-+    void finish(int read_req, int write_req, int dram_cycles) {
-+      // call finish function of each channel
-+      channel->finish(dram_cycles);
-+    }
-+
-+    bool enqueue(Request& req)
-+    {
-+        request_queue& q =
-+            req.type == Request::Type::READ? readq:
-+            req.type == Request::Type::WRITE? writeq:
-+                                             otherq;
-+        if (queue_capacity == q.size())
-+            return false;
-+
-+        req.arrive = clk;
-+        if (req.type == Request::Type::READ){
-+            for (auto& info : writeq)
-+                if (req.addr == get<0>(info).addr){
-+                    req.depart = clk + 1;
-+                    pending.push(req);
-+                    return true;
-+                }
-+        }
-+        typename T::Command first_cmd = get_first_cmd(req);
-+        long first_clk = channel->get_next(first_cmd, req.addr_vec.data());
-+        q.emplace_back(req, first_cmd, first_clk);
-+        push_heap(q.begin(), q.end(), compair_first_clk);;
-+        return true;
-+    }
-+
-+    void tick()
-+    {
-+        clk++;
-+
-+        /*** 1. Serve completed reads ***/
-+        if (pending.size()) {
-+            Request req = pending.top();
-+            if (req.depart <= clk) {
-+                req.depart = clk; // actual depart clk
-+                req.callback(req);
-+                pending.pop();
-+            }
-+        }
-+
-+        /*** 2. Should we schedule refreshes? ***/
-+        int refresh_interval = channel->spec->speed_entry.nREFI;
-+        if (clk - refreshed >= refresh_interval) {
-+            auto req_type = Request::Type::REFRESH;
-+            vector<int> addr_vec(int(T::Level::MAX), -1);
-+            addr_vec[0] = channel->id;
-+            for (auto child : channel->children) {
-+                addr_vec[1] = child->id;
-+                Request req(addr_vec, req_type, NULL);
-+                bool res = enqueue(req);
-+                assert(res);
-+            }
-+
-+            refreshed = clk;
-+        }
-+
-+        /*** 3. Should we schedule writes? ***/
-+        if (!write_mode) {
-+            // yes -- write queue is almost full or read queue is empty
-+            if (writeq.size() >= (unsigned int)(write_hi * queue_capacity) || readq.size() == 0)
-+                write_mode = true;
-+        }
-+        else {
-+            // no -- write queue is almost empty and read queue is not empty
-+            if (writeq.size() <= (unsigned int)(write_low * queue_capacity) && readq.size() != 0)
-+                write_mode = false;
-+        }
-+
-+        /*** 4. Find the best command to schedule, if any ***/
-+        request_queue& q = otherq.size()? otherq: write_mode ? writeq : readq;
-+
-+        schedule(q);
-+    }
-+
-+    bool is_row_hit(Request& req)
-+    {
-+        typename T::Command cmd = get_first_cmd(req);
-+        return channel->check_row_hit(cmd, req.addr_vec.data());
-+    }
-+
-+private:
-+
-+    static bool compair_first_clk(const request_info& lhs, const request_info& rhs) {
-+        return (get<2>(lhs) > get<2>(rhs));
-+    }
-+
-+    typename T::Command get_first_cmd(Request& req)
-+    {
-+        typename T::Command cmd = channel->spec->translate[int(req.type)];
-+        switch (int(req.type)){
-+            case int(Request::Type::READ):
-+            case int(Request::Type::WRITE):{
-+                auto node = channel;
-+                for (int i = 1; i < int(T::Level::Row); i++)
-+                    node = node->children[req.addr_vec[i]];
-+                assert(int(node->level) == int(T::Level::Row) - 1);
-+                if (node->state == T::State::Closed) return T::Command::ACT;
-+                else if (node->row_state.find(req.addr_vec[int(T::Level::Row)]) != node->row_state.end()) return cmd;
-+                else return T::Command::PRE;
-+            }
-+            case int(Request::Type::REFRESH):
-+                return channel->decode(cmd, req.addr_vec.data());
-+            default:
-+                assert(false);
-+        }
-+        // return channel->decode(cmd, req.addr_vec.data());
-+    }
-+    void update(typename T::Command cmd, bool state_change, vector<int>::iterator& begin, vector<int>::iterator& end, request_queue& q){
-+        if (q.empty()) return;
-+
-+        for (auto& info : q) {
-+            bool addr_eq = equal(begin, end, get<0>(info).addr_vec.begin());
-+            if (state_change && addr_eq)
-+                get<1>(info) = get_first_cmd(get<0>(info));
-+            if ((cmd == T::Command::RD || cmd == T::Command::WR)
-+                && get<1>(info) == T::Command::ACT)
-+                continue;
-+            get<2>(info) = channel->get_next(get<1>(info), get<0>(info).addr_vec.data());
-+        }
-+        make_heap(q.begin(), q.end(), compair_first_clk);
-+    }
-+
-+    void schedule(request_queue& q){
-+        if (q.empty()) return;
-+
-+        Request& req = get<0>(q[0]);
-+        typename T::Command& first_cmd = get<1>(q[0]);
-+        long first_clk = get<2>(q[0]);
-+
-+        if (first_clk > clk) return;
-+
-+        if (req.is_first_command) {
-+            req.is_first_command = false;
-+            if (req.type == Request::Type::READ || req.type == Request::Type::WRITE) {
-+                if (is_row_hit(req))
-+                    ++row_hits;
-+                else
-+                    ++row_misses;
-+            }
-+        }
-+
-+        issue_cmd(first_cmd, req.addr_vec.data());
-+
-+        if (first_cmd == channel->spec->translate[int(req.type)]){
-+            if (req.type == Request::Type::READ) {
-+                req.depart = clk + channel->spec->read_latency;
-+                pending.push(req);
-+            }
-+            pop_heap(q.begin(), q.end(), compair_first_clk);
-+            q.pop_back();
-+        }
-+
-+        bool state_change = channel->spec->is_opening(first_cmd)
-+                        || channel->spec->is_closing(first_cmd)
-+                        || channel->spec->is_refreshing(first_cmd);
-+
-+        auto begin = req.addr_vec.begin();
-+        auto end = begin + 1;
-+        for (; end < begin + int(T::Level::Row) && *end >= 0; end++);
-+
-+        update(first_cmd, state_change, begin, end, readq);
-+        update(first_cmd, state_change, begin, end, writeq);
-+        update(first_cmd, state_change, begin, end, otherq);
-+    }
-+
-+    void issue_cmd(typename T::Command cmd, int* addr_vec)
-+    {
-+        // assert(channel->check(cmd, addr_vec, clk));
-+        channel->update(cmd, addr_vec, clk);
-+
-+        if (record_cmd_trace){
-+            // select rank
-+            auto& file = cmd_trace_files[addr_vec[1]];
-+            string& cmd_name = channel->spec->command_name[int(cmd)];
-+            file<<clk<<','<<cmd_name;
-+            // TODO bad coding here
-+            if (cmd_name == "PREA" || cmd_name == "REF")
-+                file<<endl;
-+            else {
-+                int bank_id = addr_vec[int(T::Level::Bank)];
-+                if (channel->spec->standard_name == "DDR4" || channel->spec->standard_name == "GDDR5")
-+                    bank_id += addr_vec[int(T::Level::Bank) - 1] *
-+                        channel->spec->org_entry.count[int(T::Level::Bank)];
-+                file<<','<<bank_id<<endl;
-+            }
-+        }
-+        if (print_cmd_trace){
-+            printf("%5s %10ld:", channel->spec->command_name[int(cmd)].c_str(), clk);
-+            for (int lev = 0; lev < int(T::Level::MAX); lev++)
-+                printf(" %5d", addr_vec[lev]);
-+            printf("\n");
-+        }
-+    }
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__SPEEDYCONTROLLER_H*/
-diff --git a/ext/ramulator/Ramulator/src/StatType.cpp b/ext/ramulator/Ramulator/src/StatType.cpp
-new file mode 100644
-index 0000000..17b2535
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/StatType.cpp
-@@ -0,0 +1,153 @@
-+#include "StatType.h"
-+
-+namespace Stats {
-+
-+// Statistics list
-+StatList statlist;
-+
-+// The smallest timing granularity.
-+Tick curTick = 0;
-+
-+std::vector<StatBase*> all_stats;
-+void reset_stats() {
-+    for(auto s : all_stats)
-+        s->reset();
-+}
-+
-+void
-+Histogram::grow_out()
-+{
-+    int size = cvec.size();
-+    int zero = size / 2; // round down!
-+    int top_half = zero + (size - zero + 1) / 2; // round up!
-+    int bottom_half = (size - zero) / 2; // round down!
-+
-+    // grow down
-+    int low_pair = zero - 1;
-+    for (int i = zero - 1; i >= bottom_half; i--) {
-+        cvec[i] = cvec[low_pair];
-+        if (low_pair - 1 >= 0)
-+            cvec[i] += cvec[low_pair - 1];
-+        low_pair -= 2;
-+    }
-+    assert(low_pair == 0 || low_pair == -1 || low_pair == -2);
-+
-+    for (int i = bottom_half - 1; i >= 0; i--)
-+        cvec[i] = Counter();
-+
-+    // grow up
-+    int high_pair = zero;
-+    for (int i = zero; i < top_half; i++) {
-+        cvec[i] = cvec[high_pair];
-+        if (high_pair + 1 < size)
-+            cvec[i] += cvec[high_pair + 1];
-+        high_pair += 2;
-+    }
-+    assert(high_pair == size || high_pair == size + 1);
-+
-+    for (int i = top_half; i < size; i++)
-+        cvec[i] = Counter();
-+
-+    max_bucket *= 2;
-+    min_bucket *= 2;
-+    bucket_size *= 2;
-+}
-+
-+void
-+Histogram::grow_convert()
-+{
-+    int size = cvec.size();
-+    int half = (size + 1) / 2; // round up!
-+    //bool even = (size & 1) == 0;
-+
-+    int pair = size - 1;
-+    for (int i = size - 1; i >= half; --i) {
-+        cvec[i] = cvec[pair];
-+        if (pair - 1 >= 0)
-+            cvec[i] += cvec[pair - 1];
-+        pair -= 2;
-+    }
-+
-+    for (int i = half - 1; i >= 0; i--)
-+        cvec[i] = Counter();
-+
-+    min_bucket = -max_bucket;// - (even ? bucket_size : 0);
-+    bucket_size *= 2;
-+}
-+
-+void
-+Histogram::grow_up()
-+{
-+    int size = cvec.size();
-+    int half = (size + 1) / 2; // round up!
-+
-+    int pair = 0;
-+    for (int i = 0; i < half; i++) {
-+        cvec[i] = cvec[pair];
-+        if (pair + 1 < size)
-+            cvec[i] += cvec[pair + 1];
-+        pair += 2;
-+    }
-+    assert(pair == size || pair == size + 1);
-+
-+    for (int i = half; i < size; i++)
-+        cvec[i] = Counter();
-+
-+    max_bucket *= 2;
-+    bucket_size *= 2;
-+}
-+
-+void
-+Histogram::add(Histogram &hs)
-+{
-+    size_type b_size = hs.size();
-+    assert(size() == b_size);
-+    assert(min_bucket == hs.min_bucket);
-+
-+    sum += hs.sum;
-+    logs += hs.logs;
-+    squares += hs.squares;
-+    samples += hs.samples;
-+
-+    while(bucket_size > hs.bucket_size)
-+        hs.grow_up();
-+    while(bucket_size < hs.bucket_size)
-+        grow_up();
-+
-+    for (uint32_t i = 0; i < b_size; i++)
-+        cvec[i] += hs.cvec[i];
-+}
-+
-+void
-+Histogram::sample(Counter val, int number)
-+{
-+    assert(min_bucket < max_bucket);
-+    if (val < min_bucket) {
-+        if (min_bucket == 0)
-+            grow_convert();
-+
-+        while (val < min_bucket)
-+            grow_out();
-+    } else if (val >= max_bucket + bucket_size) {
-+        if (min_bucket == 0) {
-+            while (val >= max_bucket + bucket_size)
-+                grow_up();
-+        } else {
-+            while (val >= max_bucket + bucket_size)
-+                grow_out();
-+        }
-+    }
-+
-+    size_type index =
-+        (int64_t)std::floor((val - min_bucket) / bucket_size);
-+
-+    assert(index >= 0 && index < size());
-+    cvec[index] += number;
-+
-+    sum += val * number;
-+    squares += val * val * number;
-+    logs += log(val) * number;
-+    samples += number;
-+}
-+
-+} /* namespace Stats */
-diff --git a/ext/ramulator/Ramulator/src/StatType.h b/ext/ramulator/Ramulator/src/StatType.h
-new file mode 100644
-index 0000000..c1e4dd3
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/StatType.h
-@@ -0,0 +1,669 @@
-+#ifndef __STATTYPE_H
-+#define __STATTYPE_H
-+
-+#include <limits>
-+#include <fstream>
-+#include <string>
-+#include <vector>
-+
-+#include <cassert>
-+#include <cmath>
-+#include <cstdlib>
-+
-+namespace ramulator {
-+
-+class ScalarStat;
-+class AverageStat;
-+class VectorStat;
-+class AverageVectorStat;
-+} // namespace ramulator
-+
-+namespace Stats {
-+
-+const double eps = 1e-8;
-+
-+typedef unsigned int size_type;
-+typedef unsigned int off_type;
-+typedef double Counter;
-+typedef double Result;
-+typedef uint64_t Tick;
-+typedef std::vector<Counter> VCounter;
-+typedef std::vector<Result> VResult;
-+typedef std::numeric_limits<Counter> CounterLimits;
-+
-+class StatBase;
-+extern std::vector<StatBase*> all_stats;
-+void reset_stats();
-+
-+// Flags
-+const uint16_t init      = 0x00000001;
-+const uint16_t display   = 0x00000002;
-+const uint16_t total     = 0x00000010;
-+const uint16_t pdf       = 0x00000020;
-+const uint16_t cdf       = 0x00000040;
-+const uint16_t dist      = 0x00000080;
-+const uint16_t nozero    = 0x00000100;
-+const uint16_t nonan     = 0x00000200;
-+
-+class Flags {
-+ protected:
-+  uint16_t flags;
-+ public:
-+  Flags(){}
-+  Flags(uint16_t flags):flags(flags){}
-+  void operator=(uint16_t _flags){flags = _flags;}
-+  bool is_total() const {return flags & total;}
-+  bool is_pdf() const {return flags & pdf;}
-+  bool is_nozero() const {return flags & nozero;}
-+  bool is_nonan() const {return flags & nonan;}
-+  bool is_cdf() const {return flags & cdf;}
-+  bool is_display() const {return flags & display;}
-+};
-+
-+class StatBase {
-+ public:
-+    StatBase() {
-+        all_stats.push_back(this);
-+    }
-+
-+
-+  // TODO implement print for Distribution, Histogram,
-+  // AverageDeviation, StandardDeviation
-+  virtual void print(std::ofstream& file) = 0;
-+
-+  virtual size_type size() const = 0;
-+  virtual bool zero() const = 0;
-+  virtual void prepare() = 0;
-+  virtual void reset() = 0;
-+
-+  virtual VResult vresult() const { return VResult(); };
-+  virtual Result total() const { return Result(); };
-+
-+  virtual bool is_display() const  = 0;
-+  virtual bool is_nozero() const = 0;
-+};
-+
-+class StatList {
-+ protected:
-+  std::vector<StatBase*> list;
-+  std::ofstream stat_output;
-+ public:
-+  void add(StatBase* stat) {
-+    list.push_back(stat);
-+  }
-+  void output(std::string filename) {
-+    stat_output.open(filename.c_str(), std::ios_base::out);
-+    if (!stat_output.good()) {
-+      assert(false && "!stat_output.good()");
-+    }
-+  }
-+  void printall() {
-+    for(off_type i = 0 ; i < list.size() ; ++i) {
-+      if (!list[i]) {
-+        continue;
-+      }
-+      if (list[i]->is_nozero() && list[i]->zero()) {
-+        continue;
-+      }
-+      if (list[i]->is_display()) {
-+        list[i]->prepare();
-+        list[i]->print(stat_output);
-+      }
-+    }
-+  }
-+  ~StatList() {
-+    stat_output.close();
-+  }
-+};
-+
-+extern StatList statlist;
-+
-+template<class Derived>
-+class Stat : public StatBase {
-+ protected:
-+  std::string _name;
-+  std::string _desc;
-+  int _precision = 1;
-+  Flags _flags = display;
-+  std::string separatorString;
-+ public:
-+  Stat() {
-+    statlist.add(selfptr());
-+  }
-+  Derived &self() {return *static_cast<Derived*>(this);}
-+  Derived *selfptr() {return static_cast<Derived*>(this);}
-+  Derived &name(const std::string &__name) {
-+    _name = __name;
-+    return self();
-+  };
-+  Derived &desc(const std::string &__desc) {
-+    _desc = __desc;
-+    return self();
-+  };
-+  Derived &precision(int __precision) {
-+    _precision = __precision;
-+    return self();
-+  };
-+  Derived &flags(Flags __flags) {
-+    _flags = __flags;
-+    return self();
-+  };
-+
-+  template <class GenericStat>
-+  Derived &prereq(const GenericStat & prereq) {
-+    // TODO deal with prereq;
-+    // only print the stat if the prereq is not zero.
-+    return self();
-+  }
-+
-+  Derived &setSeparator(std::string str) {
-+    separatorString = str;
-+    return self();
-+  }
-+  const std::string& setSeparator() const {return separatorString;}
-+
-+  size_type size() const { return 0; }
-+
-+  virtual void print(std::ofstream& file) {};
-+  virtual void printname(std::ofstream& file) {
-+    file.width(40);
-+    file << _name;
-+  }
-+
-+  virtual void printdesc(std::ofstream& file) {
-+    file.width(40);
-+    file << "# " << _desc << std::endl;
-+  }
-+
-+  virtual bool is_display() const {
-+    return _flags.is_display();
-+  }
-+
-+  virtual bool is_nozero() const {
-+    return _flags.is_nozero();
-+  }
-+};
-+
-+template <class ScalarType>
-+class ScalarBase: public Stat<ScalarType> {
-+ public:
-+  virtual Counter value() const = 0;
-+  virtual Result result() const = 0;
-+  virtual Result total() const = 0;
-+
-+  size_type size() const {return 1;}
-+  VResult vresult() const {return VResult(1, result());}
-+
-+  virtual void print(std::ofstream& file) {
-+    Stat<ScalarType>::printname(file);
-+    // TODO deal with flag
-+    file.precision(Stat<ScalarType>::_precision);
-+    file.width(20);
-+    Result res = Stat<ScalarType>::self().result();
-+    file << std::fixed << res;
-+    Stat<ScalarType>::printdesc(file);
-+  }
-+};
-+
-+class ConstValue: public ScalarBase<ConstValue> {
-+ private:
-+  Counter _value;
-+ public:
-+  ConstValue(Counter __value):_value(__value){}
-+
-+  void operator ++ () { ++_value; }
-+  void operator -- () { --_value; }
-+  void operator ++ (int) { _value++; }
-+  void operator -- (int) { _value--; }
-+
-+  template <typename U>
-+  void operator = (const U &v) { _value = v; }
-+
-+  template <typename U>
-+  void operator += (const U &v) { _value += v;}
-+
-+  template <typename U>
-+  void operator -= (const U &v) { _value -= v;}
-+
-+
-+  Counter value() const {return _value;}
-+  Result result() const {return (Result)_value;}
-+  Result total() const {return result();}
-+  bool zero() const {return (fabs(_value) < eps);}
-+  void prepare() {}
-+  void reset() {}
-+};
-+
-+class Scalar: public ScalarBase<Scalar> {
-+ private:
-+  Counter _value;
-+ public:
-+  Scalar():_value(0) {}
-+  Counter value() const {return _value;}
-+  Result result() const {return (Result)_value;}
-+  Result total() const {return (Result)_value;}
-+
-+  void operator ++ () { ++_value; }
-+  void operator -- () { --_value; }
-+  void operator ++ (int) { _value++; }
-+  void operator -- (int) { _value--; }
-+
-+  template <typename U>
-+  void operator = (const U &v) { _value = v; }
-+
-+  template <typename U>
-+  void operator += (const U &v) { _value += v;}
-+
-+  template <typename U>
-+  void operator -= (const U &v) { _value -= v;}
-+
-+
-+  virtual bool zero() const {return (fabs(_value) < eps);}
-+  void prepare() {}
-+  void reset() {_value = Counter();}
-+
-+};
-+
-+extern Tick curTick;
-+
-+class Average: public ScalarBase<Average> {
-+ private:
-+  Counter current;
-+  Tick lastReset;
-+  Result total_val;
-+  Tick last;
-+ public:
-+  Average():current(0), lastReset(0), total_val(0), last(0){}
-+
-+  void set(Counter val) {
-+    total_val += current * (curTick - last);
-+    last = curTick;
-+    current = val;
-+  }
-+  void inc(Counter val) {
-+    set(current + val);
-+  }
-+  void dec(Counter val) {
-+    set(current - val);
-+  }
-+  void operator ++ () { inc(1); }
-+  void operator -- () { dec(1); }
-+  void operator ++ (int) { inc(1); }
-+  void operator -- (int) { dec(1); }
-+
-+  template <typename U>
-+  void operator = (const U &v) { set(v); }
-+
-+  template <typename U>
-+  void operator += (const U &v) { inc(v);}
-+
-+  template <typename U>
-+  void operator -= (const U &v) { dec(v);}
-+
-+
-+  bool zero() const { return (fabs(total_val) < eps); }
-+  void prepare() {
-+    total_val += current * (curTick - last);
-+    last = curTick;
-+  }
-+  void reset() {
-+    total_val = 0.0;
-+    last = curTick;
-+    lastReset = curTick;
-+  }
-+
-+  Counter value() const { return current; }
-+  Result result() const {
-+    assert(last == curTick);
-+    return (Result)(total_val + current)/ (Result)(curTick - lastReset + 1);
-+  }
-+  Result total() const {return result();}
-+};
-+
-+template<class Derived, class Element>
-+class VectorBase: public Stat<Derived> {
-+ private:
-+  size_type _size = 0;
-+  std::vector<Element> data;
-+
-+ public:
-+  void init(size_type __size) {
-+    _size = __size;
-+    data.resize(size());
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      data[i].flags(0)
-+             .name("[" + std::string(1, char(i + '0')) + "]");
-+    }
-+  }
-+  size_type size() const {return _size;}
-+  // Copy the values to a local vector and return a reference to it.
-+  void value(VCounter& vec) const {
-+    vec.resize(size());
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      vec[i] = data[i].value();
-+    }
-+  }
-+  // Copy the results to a local vector and return a reference to it.
-+  void result(VResult& vec) const {
-+    vec.resize(size());
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      vec[i] = data[i].result();
-+    }
-+  }
-+
-+  Result total() const {
-+    Result sum = 0.0;
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      sum += data[i].result();
-+    }
-+    return sum;
-+  }
-+
-+  VResult vresult() const {
-+    VResult vres;
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      vres[i] = data[i].result();
-+    }
-+    return vres;
-+  }
-+
-+  bool check() const {
-+    // We don't separate storage and access as gem5 does.
-+    // So here is always true.
-+    return true;
-+  }
-+
-+  Element &operator[](off_type index) {
-+    assert(index >= 0 && index < size());
-+    return data[index];
-+  }
-+
-+  bool zero() const {
-+    return (fabs(total()) < eps);
-+  }
-+
-+  void prepare() {
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      data[i].prepare();
-+    }
-+  }
-+  void reset() {
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      data[i].reset();
-+    }
-+  }
-+  void print(std::ofstream& file) {
-+    Stat<Derived>::printname(file);
-+    file.precision(Stat<Derived>::_precision);
-+    file.width(20);
-+    file << std::fixed << total();
-+    Stat<Derived>::printdesc(file);
-+    for (off_type i = 0 ; i < size() ; ++i) {
-+      data[i].print(file);
-+    }
-+  }
-+};
-+
-+class Vector: public VectorBase<Vector, Scalar> {
-+};
-+
-+class AverageVector: public VectorBase<AverageVector, Average> {
-+};
-+
-+class Distribution: public Stat<Distribution> {
-+ private:
-+  // Parameter part:
-+  Counter param_min;
-+  Counter param_max;
-+  Counter param_bucket_size;
-+  Counter param_buckets;
-+
-+  // The minimum value to track
-+  Counter min_track;
-+  // The maximum value to track
-+  Counter max_track;
-+  // The number of entries in each bucket
-+  Counter bucket_size;
-+
-+  Counter min_val;
-+  Counter max_val;
-+  // The number of values sampled less than min
-+  Counter underflow;
-+  // The number of values sampled more than max
-+  Counter overflow;
-+  // The current sum
-+  Counter sum;
-+  // The sum of squares
-+  Counter squares;
-+  // The number of samples
-+  Counter samples;
-+  // Counter for each bucket
-+  VCounter cvec;
-+
-+ public:
-+  Distribution():param_min(Counter()), param_max(Counter()),
-+      param_bucket_size(Counter()) { reset(); }
-+  void init(Counter min, Counter max, Counter bkt) {
-+    param_min = min;
-+    param_max = max;
-+    param_bucket_size = bkt;
-+    param_buckets = (size_type)ceil((max - min + 1.0) / bkt);
-+    cvec.resize(param_buckets);
-+
-+    reset();
-+  }
-+  void sample(Counter val, int number) {
-+    if (val < min_track)
-+      underflow += number;
-+    else if (val > max_track)
-+      overflow += number;
-+    else {
-+      size_type index =
-+          (size_type)std::floor((val - min_track) / bucket_size);
-+      assert(index < size());
-+      cvec[index] += number;
-+    }
-+
-+    if (val < min_val)
-+      min_val = val;
-+
-+    if (val > max_val)
-+      max_val = val;
-+
-+    sum += val * number;
-+    squares += val * val * number;
-+    samples += number;
-+  }
-+
-+  size_type size() const {return cvec.size();}
-+  bool zero() const {
-+    return (fabs(samples) < eps);
-+  }
-+  void prepare() {};
-+  void reset() {
-+    min_track = param_min;
-+    max_track = param_max;
-+    bucket_size = param_bucket_size;
-+
-+    min_val = CounterLimits::max();
-+    max_val = CounterLimits::min();
-+    underflow = Counter();
-+    overflow = Counter();
-+
-+    size_type _size = cvec.size();
-+    for (off_type i = 0 ; i < _size ; ++i) {
-+      cvec[i] = Counter();
-+    }
-+
-+    sum = Counter();
-+    squares = Counter();
-+    samples = Counter();
-+  };
-+  void add(Distribution &d) {
-+    size_type d_size = d.size();
-+    assert(size() == d_size);
-+    assert(min_track == d.min_track);
-+    assert(max_track == d.max_track);
-+
-+    underflow += d.underflow;
-+    overflow += d.overflow;
-+
-+    sum += d.sum;
-+    squares += d.squares;
-+    samples += d.samples;
-+
-+    if (d.min_val < min_val) {
-+      min_val = d.min_val;
-+    }
-+
-+    if (d.max_val > max_val) {
-+      max_val = d.max_val;
-+    }
-+
-+    for (off_type i = 0 ; i < d_size ; ++i) {
-+      cvec[i] += d.cvec[i];
-+    }
-+  }
-+};
-+
-+class Histogram: public Stat<Histogram> {
-+ private:
-+  size_type param_buckets;
-+
-+  Counter min_bucket;
-+  Counter max_bucket;
-+  Counter bucket_size;
-+
-+  Counter sum;
-+  Counter logs;
-+  Counter squares;
-+  Counter samples;
-+  VCounter cvec;
-+
-+ public:
-+  Histogram():param_buckets(0) { reset(); }
-+  Histogram(size_type __buckets):cvec(__buckets) {
-+    init(__buckets);
-+  }
-+  void init(size_type __buckets) {
-+    cvec.resize(__buckets);
-+    param_buckets = __buckets;
-+    reset();
-+  }
-+
-+  void grow_up();
-+  void grow_out();
-+  void grow_convert();
-+  void add(Histogram& hs);
-+  void sample(Counter val, int number);
-+
-+  bool zero() const {
-+    return (fabs(samples) < eps);
-+  }
-+  void prepare() {}
-+  void reset() {
-+    min_bucket = 0;
-+    max_bucket = param_buckets - 1;
-+    bucket_size = 1;
-+
-+    size_type size = param_buckets;
-+    for (off_type i = 0 ; i < size ; ++i) {
-+      cvec[i] = Counter();
-+    }
-+
-+    sum = Counter();
-+    squares = Counter();
-+    samples = Counter();
-+    logs = Counter();
-+  }
-+
-+  size_type size() const {return param_buckets;}
-+};
-+
-+class StandardDeviation: public Stat<StandardDeviation> {
-+ private:
-+  Counter sum;
-+  Counter squares;
-+  Counter samples;
-+
-+ public:
-+  StandardDeviation():sum(Counter()), squares(Counter()),
-+      samples(Counter()) {}
-+  void sample(Counter val, int number) {
-+    Counter value = val * number;
-+    sum += value;
-+    squares += value * value;
-+    samples += number;
-+  }
-+  size_type size() const {return 1;}
-+  bool zero() const {return (fabs(samples) < eps);}
-+  void prepare() {}
-+  void reset() {
-+    sum = Counter();
-+    squares = Counter();
-+    samples = Counter();
-+  }
-+  void add(StandardDeviation& sd) {
-+    sum += sd.sum;
-+    squares += sd.squares;
-+    samples += sd.samples;
-+  }
-+};
-+
-+class AverageDeviation: public Stat<AverageDeviation> {
-+ private:
-+  Counter sum;
-+  Counter squares;
-+
-+ public:
-+  AverageDeviation():sum(Counter()), squares(Counter()) {}
-+  void sample(Counter val, int number) {
-+    Counter value = val * number;
-+    sum += value;
-+    squares += value * value;
-+  }
-+  size_type size() const {return 1;}
-+  bool zero() const {return (fabs(sum) < eps);}
-+  void prepare() {}
-+  void reset() {
-+    sum = Counter();
-+    squares = Counter();
-+  }
-+  void add(AverageDeviation& ad) {
-+    sum += ad.sum;
-+    squares += ad.squares;
-+  }
-+};
-+
-+class Op {
-+ private:
-+  std::string opstring;
-+ public:
-+  Op() {}
-+  Op(std::string __opstring):opstring(__opstring){}
-+  Result operator() (Result r) const {
-+    if (opstring == "-") {
-+      return -r;
-+    } else {
-+      assert("Unary operation can only be unary negation." && false);
-+    }
-+  }
-+  Result operator() (Result l, Result r) const {
-+    if (opstring == "+") {
-+      return l + r;
-+    } else if (opstring == "-") {
-+      return l - r;
-+    } else if (opstring == "*") {
-+      return l * r;
-+    } else if (opstring == "/") {
-+      assert(fabs(r) > 1e-8 || "divide zero error");
-+      return l / r;
-+    } else {
-+      assert("invalid binary opstring " && false);
-+    }
-+  }
-+};
-+
-+} // namespace Stats
-+
-+#endif
-diff --git a/ext/ramulator/Ramulator/src/Statistics.h b/ext/ramulator/Ramulator/src/Statistics.h
-new file mode 100644
-index 0000000..b9f7489
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/Statistics.h
-@@ -0,0 +1,246 @@
-+#ifndef __STATISTICS_H
-+#define __STATISTICS_H
-+
-+#include <string>
-+
-+// FIXME Find better way to decide where does it come from
-+#if !defined(RAMULATOR)
-+#define INTEGRATED_WITH_GEM5
-+#endif
-+
-+#ifdef INTEGRATED_WITH_GEM5
-+#include "base/statistics.hh"
-+#else
-+#include "StatType.h"
-+#endif
-+
-+/*
-+  IMPORTANT NOTE - Read this first!
-+
-+  This version of the file provides wrappers to the gem5 statistics classes.
-+  Feel free to go through this file, though it can be difficult to follow
-+  with the degree of abstraction going on. In short, this file currently
-+  provides the following mapping of stat classes. In almost all cases, the
-+  wrapper provides identical and complete functionality to the gem5 stat
-+  classes. All of our classes are defined in the ramulator namespace.
-+
-+  GEM5 CLASS --> RAMULATOR CLASS
-+  ==============================
-+  Stats::Scalar --> ScalarStat
-+  Stats::Average --> AverageStat
-+  Stats::Vector --> VectorStat
-+  Stats::AverageVector --> AverageVectorStat
-+  Stats::Distribution --> DistributionStat
-+  Stats::Histogram --> HistogramStat
-+  Stats::StandardDeviation --> StandardDeviationStat
-+  Stats::AverageDeviation --> AverageDeviationStat
-+
-+  All of the stats that you create will be named "ramulator.<your name>"
-+  automatically, and will be dumped at the end of simulation into the gem5
-+  stats file.
-+*/
-+
-+namespace ramulator {
-+
-+template<class StatType>
-+class StatBase { // wrapper for Stats::DataWrap
-+  protected:
-+    StatType stat;
-+    std::string statName;
-+
-+    StatBase<StatType> & self() { return *this; }
-+  public:
-+    StatBase() {}
-+
-+#ifndef INTEGRATED_WITH_GEM5
-+    const StatType* get_stat() const {
-+      return &stat;
-+    }
-+#endif
-+
-+    StatBase(std::string _name) {
-+      name(_name);
-+    }
-+
-+    StatBase(std::string _name, std::string _desc) {
-+      name(_name);
-+      desc(_desc);
-+    }
-+
-+    StatBase<StatType> & name(std::string _name) {
-+      statName = _name;
-+      stat.name("ramulator." + _name);
-+
-+      return self();
-+    }
-+
-+    const std::string &name(void) const { return statName; }
-+
-+    StatBase<StatType> & setSeparator(const std::string & _sep) {
-+      stat.setSeparator(_sep);
-+      return self();
-+    }
-+
-+    const std::string &setSeparator() const { return stat.setSeparator(); }
-+
-+    StatBase<StatType> & desc(std::string _desc) {
-+      stat.desc(_desc);
-+      return self();
-+    }
-+
-+    StatBase<StatType> & precision(int _precision) {
-+      stat.precision(_precision);
-+      return self();
-+    }
-+
-+    StatBase<StatType> & flags(Stats::Flags _flags) {
-+      stat.flags(_flags);
-+      return self();
-+    }
-+
-+    template <class Stat>
-+    StatBase<StatType> & prereq(const Stat & _prereq) {
-+      stat.prereq(_prereq);
-+      return self();
-+    }
-+
-+    Stats::size_type size(void) const { return stat.size(); }
-+    bool zero(void) const { return stat.zero(); }
-+    void prepare(void) { stat.prepare(); }
-+    void reset(void) { stat.reset(); }
-+};
-+
-+template<class StatType>
-+class StatBaseVec : public StatBase<StatType> { // wrapper for Stats::DataWrapVec
-+  protected:
-+    StatBaseVec<StatType> & self() { return *this; }
-+
-+  public:
-+    StatBaseVec<StatType> & subname(Stats::off_type index, const std::string & name) {
-+      StatBase<StatType>::stat.subname(index, name);
-+      return self();
-+    }
-+
-+    StatBaseVec<StatType> & subdesc(Stats::off_type index, const std::string & desc) {
-+      StatBase<StatType>::stat.subdesc(index, desc);
-+      return self();
-+    }
-+};
-+
-+template<class StatType>
-+class ScalarStatBase : public StatBase<StatType> { // wrapper for Stats::ScalarBase
-+  public:
-+    Stats::Counter value() const { return StatBase<StatType>::stat.value(); };
-+    void operator++() { ++StatBase<StatType>::stat; }
-+    void operator--() { --StatBase<StatType>::stat; }
-+
-+    void operator++(int) { StatBase<StatType>::stat++; }
-+    void operator--(int) { StatBase<StatType>::stat--; }
-+
-+    template <typename U>
-+    void operator=(const U &v) { StatBase<StatType>::stat = v; }
-+
-+    template <typename U>
-+    void operator+=(const U &v) { StatBase<StatType>::stat += v; }
-+
-+    template <typename U>
-+    void operator-=(const U &v) { StatBase<StatType>::stat -= v; }
-+};
-+
-+template<class StatType, class Element>
-+class VectorStatBase : public StatBaseVec<StatType> { // wrapper for Stats::VectorBase
-+  protected:
-+    VectorStatBase<StatType, Element> & self() { return *this; }
-+
-+  public:
-+    void value(Stats::VCounter & vec) const { StatBase<StatType>::stat.value(vec); }
-+    void result(Stats::VResult & vec) const { StatBase<StatType>::stat.result(vec); }
-+    Stats::Result total(void) const { return StatBase<StatType>::stat.total(); }
-+
-+    bool check(void) const { return StatBase<StatType>::stat.check(); }
-+
-+    VectorStatBase<StatType, Element> & init(Stats::size_type size) {
-+      StatBase<StatType>::stat.init(size);
-+      return self();
-+    }
-+
-+#ifdef INTEGRATED_WITH_GEM5
-+    Stats::ScalarProxy<StatType> operator[](Stats::off_type index) { return StatBase<StatType>::stat[index]; }
-+#else
-+    Element &operator[](Stats::off_type index) { return StatBase<StatType>::stat[index]; }
-+#endif
-+};
-+
-+
-+template<class StatType>
-+class DistStatBase : public StatBase<StatType> { // wrapper for Stats::DistBase
-+  public:
-+    template<typename U>
-+    void sample(const U &v, int n = 1) { StatBase<StatType>::stat.sample(v, n); }
-+
-+    void add(DistStatBase & d) { StatBase<StatType>::stat.add(d.StatBase<StatType>::stat); }
-+};
-+
-+
-+/*
-+  nice wrappers for the gem5 stats classes used throughout the rest of the code
-+*/
-+
-+class ScalarStat : public ScalarStatBase<Stats::Scalar> {
-+  public:
-+    using ScalarStatBase<Stats::Scalar>::operator=;
-+};
-+
-+class AverageStat : public ScalarStatBase<Stats::Average> {
-+  public:
-+    using ScalarStatBase<Stats::Average>::operator=;
-+};
-+
-+class VectorStat : public VectorStatBase<Stats::Vector, Stats::Scalar> {
-+};
-+
-+class AverageVectorStat : public VectorStatBase<Stats::AverageVector, Stats::Average> {
-+};
-+
-+class DistributionStat : public DistStatBase<Stats::Distribution> {
-+  protected:
-+    DistributionStat & self() { return *this; }
-+
-+  public:
-+    DistributionStat & init(Stats::Counter min, Stats::Counter max, Stats::Counter bkt) {
-+      StatBase<Stats::Distribution>::stat.init(min, max, bkt);
-+      return self();
-+    }
-+
-+};
-+
-+class HistogramStat : public DistStatBase<Stats::Histogram> {
-+  protected:
-+    HistogramStat & self() { return *this; }
-+
-+  public:
-+    HistogramStat & init(Stats::size_type size) {
-+      StatBase<Stats::Histogram>::stat.init(size);
-+      return self();
-+    }
-+};
-+
-+class StandardDeviationStat : public DistStatBase<Stats::StandardDeviation> {
-+};
-+
-+class AverageDeviationStat : public DistStatBase<Stats::AverageDeviation> {
-+};
-+
-+/*
-+  Stats TODO
-+  * Formula
-+  * VectorDistribution
-+  * VectorStandardDeviation
-+  * VectorAverageDeviation
-+  * Vector2d
-+  * SparseHistogram
-+*/
-+
-+} /* namespace ramulator */
-+
-+#endif
-diff --git a/ext/ramulator/Ramulator/src/TLDRAM.cpp b/ext/ramulator/Ramulator/src/TLDRAM.cpp
-new file mode 100644
-index 0000000..c9b3052
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/TLDRAM.cpp
-@@ -0,0 +1,567 @@
-+#include "TLDRAM.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+#include <iostream>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string TLDRAM::standard_name = "TLDRAM";
-+string TLDRAM::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum TLDRAM::Org> TLDRAM::org_map = {
-+    {"TLDRAM_512Mb_x4", TLDRAM::Org::TLDRAM_512Mb_x4},
-+    {"TLDRAM_512Mb_x8", TLDRAM::Org::TLDRAM_512Mb_x8},
-+    {"TLDRAM_512Mb_x16", TLDRAM::Org::TLDRAM_512Mb_x16},
-+    {"TLDRAM_1Gb_x4", TLDRAM::Org::TLDRAM_1Gb_x4},
-+    {"TLDRAM_1Gb_x8", TLDRAM::Org::TLDRAM_1Gb_x8},
-+    {"TLDRAM_1Gb_x16", TLDRAM::Org::TLDRAM_1Gb_x16},
-+    {"TLDRAM_2Gb_x4", TLDRAM::Org::TLDRAM_2Gb_x4},
-+    {"TLDRAM_2Gb_x8", TLDRAM::Org::TLDRAM_2Gb_x8},
-+    {"TLDRAM_2Gb_x16", TLDRAM::Org::TLDRAM_2Gb_x16},
-+    {"TLDRAM_4Gb_x4", TLDRAM::Org::TLDRAM_4Gb_x4},
-+    {"TLDRAM_4Gb_x8", TLDRAM::Org::TLDRAM_4Gb_x8},
-+    {"TLDRAM_4Gb_x16", TLDRAM::Org::TLDRAM_4Gb_x16},
-+    {"TLDRAM_8Gb_x4", TLDRAM::Org::TLDRAM_8Gb_x4},
-+    {"TLDRAM_8Gb_x8", TLDRAM::Org::TLDRAM_8Gb_x8},
-+    {"TLDRAM_8Gb_x16", TLDRAM::Org::TLDRAM_8Gb_x16},
-+};
-+
-+map<string, enum TLDRAM::Speed> TLDRAM::speed_map = {
-+    {"TLDRAM_800D", TLDRAM::Speed::TLDRAM_800D},
-+    {"TLDRAM_800E", TLDRAM::Speed::TLDRAM_800E},
-+    {"TLDRAM_1066E", TLDRAM::Speed::TLDRAM_1066E},
-+    {"TLDRAM_1066F", TLDRAM::Speed::TLDRAM_1066F},
-+    {"TLDRAM_1066G", TLDRAM::Speed::TLDRAM_1066G},
-+    {"TLDRAM_1333G", TLDRAM::Speed::TLDRAM_1333G},
-+    {"TLDRAM_1333H", TLDRAM::Speed::TLDRAM_1333H},
-+    {"TLDRAM_1600H", TLDRAM::Speed::TLDRAM_1600H},
-+    {"TLDRAM_1600J", TLDRAM::Speed::TLDRAM_1600J},
-+    {"TLDRAM_1600K", TLDRAM::Speed::TLDRAM_1600K},
-+    {"TLDRAM_1866K", TLDRAM::Speed::TLDRAM_1866K},
-+    {"TLDRAM_1866L", TLDRAM::Speed::TLDRAM_1866L},
-+    {"TLDRAM_2133L", TLDRAM::Speed::TLDRAM_2133L},
-+    {"TLDRAM_2133M", TLDRAM::Speed::TLDRAM_2133M},
-+};
-+
-+
-+TLDRAM::TLDRAM(Org org, Speed speed, int segment_ratio) :
-+    segment_ratio(segment_ratio),
-+    org_entry(org_table[int(org)]),
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nBL)
-+{
-+    this->segment_ratio = segment_ratio;
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+TLDRAM::TLDRAM(const string& org_str, const string& speed_str, int segment_ratio) :
-+    TLDRAM(org_map[org_str], speed_map[speed_str], segment_ratio)
-+{
-+    this->segment_ratio = segment_ratio;
-+}
-+
-+void TLDRAM::set_channel_number(int channel) {
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void TLDRAM::set_rank_number(int rank) {
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void TLDRAM::init_speed()
-+{
-+    // nRRD, nFAW
-+    int page = (org_entry.dq * org_entry.count[int(Level::Column)]) >> 13;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRRD = (page==1) ? 4 : 4;
-+          speed_entry.nFAW = (page==1) ? 16 : 20;
-+          break;
-+        case 1066: speed_entry.nRRD = (page==1) ? 4 : 6;
-+          speed_entry.nFAW = (page==1) ? 20 : 27;
-+          break;
-+        case 1333:
-+          speed_entry.nRRD = (page==1) ? 4 : 5;
-+          speed_entry.nFAW = (page==1) ? 20 : 30;
-+          break;
-+        case 1600:
-+          speed_entry.nRRD = (page==1) ? 5 : 6;
-+          speed_entry.nFAW = (page==1) ? 24 : 32;
-+          break;
-+        case 1866:
-+          speed_entry.nRRD = (page==1) ? 5 : 6;
-+          speed_entry.nFAW = (page==1) ? 26 : 33;
-+          break;
-+        case 2133:
-+          speed_entry.nRRD = (page==1) ? 5 : 6;
-+          speed_entry.nFAW = (page==1) ? 27 : 34;
-+          break;
-+        default: assert(false);
-+    }
-+
-+    // nRFC, nXS
-+    int chip = org_entry.size;
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nRFC = (chip==512) ? 36  : (chip==1<<10) ? 44
-+          : (chip==1<<11) ? 64  : (chip==1<<12) ? 104 : 140; break;
-+        case 1066: speed_entry.nRFC = (chip==512) ? 48  : (chip==1<<10) ? 59
-+          : (chip==1<<11) ? 86  : (chip==1<<12) ? 139 : 187; break;
-+        case 1333: speed_entry.nRFC = (chip==512) ? 60  : (chip==1<<10) ? 74
-+          : (chip==1<<11) ? 107 : (chip==1<<12) ? 174 : 234; break;
-+        case 1600: speed_entry.nRFC = (chip==512) ? 72  : (chip==1<<10) ? 88
-+          : (chip==1<<11) ? 128 : (chip==1<<12) ? 208 : 280; break;
-+        case 1866: speed_entry.nRFC = (chip==512) ? 84  : (chip==1<<10) ? 103
-+          : (chip==1<<11) ? 150 : (chip==1<<12) ? 243 : 327; break;
-+        case 2133: speed_entry.nRFC = (chip==512) ? 96  : (chip==1<<10) ? 118
-+          : (chip==1<<11) ? 171 : (chip==1<<12) ? 278 : 374; break;
-+        default: assert(false);
-+    }
-+    switch (speed_entry.rate) {
-+        case 800:  speed_entry.nXS  = (chip==512) ? 40  : (chip==1<<10) ? 48
-+          : (chip==1<<11) ? 68  : (chip==1<<12) ? 108 : 144; break;
-+        case 1066: speed_entry.nXS  = (chip==512) ? 54  : (chip==1<<10) ? 64
-+          : (chip==1<<11) ? 91  : (chip==1<<12) ? 144 : 192; break;
-+        case 1333: speed_entry.nXS  = (chip==512) ? 67  : (chip==1<<10) ? 80
-+          : (chip==1<<11) ? 114 : (chip==1<<12) ? 180 : 240; break;
-+        case 1600: speed_entry.nXS  = (chip==512) ? 80  : (chip==1<<10) ? 96
-+          : (chip==1<<11) ? 136 : (chip==1<<12) ? 216 : 288; break;
-+        case 1866: speed_entry.nXS  = (chip==512) ? 94  : (chip==1<<10) ? 112
-+          : (chip==1<<11) ? 159 : (chip==1<<12) ? 252 : 336; break;
-+        case 2133: speed_entry.nXS  = (chip==512) ? 107 : (chip==1<<10) ? 128
-+          : (chip==1<<11) ? 182 : (chip==1<<12) ? 288 : 384; break;
-+        default: assert(false);
-+    }
-+}
-+
-+
-+void TLDRAM::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }
-+    };
-+    prereq[int(Level::Rank)][int(Command::MIG)] = prereq[int(Level::Rank)][int(Command::RD)];
-+
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed):
-+                if (id % node->spec->segment_ratio)
-+                    return Command::ACT;
-+                else
-+                    return Command::ACTF;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                if (id % node->spec->segment_ratio)
-+                    return Command::PRE;
-+                else
-+                    return Command::PREF;
-+            default: assert(false);
-+        }
-+    };
-+    prereq[int(Level::Bank)][int(Command::MIG)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed):
-+                return Command::ACTM;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PREM;
-+            default: assert(false);
-+        }
-+    };
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            if (id % node->spec->segment_ratio)
-+                return Command::PREA;
-+            else
-+                return Command::PREAF;
-+        }
-+        return Command::REF;
-+    };
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PDE;
-+            case int(State::ActPowerDown): return Command::PDE;
-+            case int(State::PrePowerDown): return Command::PDE;
-+            case int(State::SelfRefresh): return Command::SRX;
-+            default: assert(false);
-+        }
-+    };
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SRE;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SRE;
-+            default: assert(false);
-+        }
-+    };
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void TLDRAM::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void TLDRAM::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void TLDRAM::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;
-+    };
-+    lambda[int(Level::Bank)][int(Command::ACTF)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;
-+    };
-+    lambda[int(Level::Bank)][int(Command::ACTM)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;
-+    };
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();
-+    };
-+    lambda[int(Level::Bank)][int(Command::PREF)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();
-+    };
-+    lambda[int(Level::Bank)][int(Command::PREM)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();
-+    };
-+    lambda[int(Level::Rank)][int(Command::PREA)] = [] (DRAM<TLDRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();
-+        }
-+    };
-+    lambda[int(Level::Rank)][int(Command::PREAF)] = [] (DRAM<TLDRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();
-+        }
-+    };
-+    lambda[int(Level::Rank)][int(Command::PREAM)] = [] (DRAM<TLDRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();
-+        }
-+    };
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, int id) {};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<TLDRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<TLDRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<TLDRAM>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::MIG)] = [] (DRAM<TLDRAM>* node, int id) {};
-+    lambda[int(Level::Rank)][int(Command::PDE)] = [] (DRAM<TLDRAM>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;
-+    };
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::PowerUp;
-+    };
-+    lambda[int(Level::Rank)][int(Command::SRE)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::SelfRefresh;
-+    };
-+    lambda[int(Level::Rank)][int(Command::SRX)] = [] (DRAM<TLDRAM>* node, int id) {
-+        node->state = State::PowerUp;
-+    };
-+}
-+
-+
-+void TLDRAM::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::MIG, 1, s.nBL});
-+    t[int(Command::MIG)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+
-+
-+    /*** Rank ***/
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::MIG, 1, s.nCCD});
-+    t[int(Command::MIG)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nCCD});
-+
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::MIG)].push_back({Command::WR, 1, s.nCL + s.nCCD + 2 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::MIG, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::MIG, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::RD)].push_back({Command::PREAF, 1, s.nRTP});
-+    t[int(Command::RD)].push_back({Command::PREAM, 1, s.nRTP});
-+
-+    t[int(Command::MIG)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::MIG)].push_back({Command::MIG, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::MIG)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::MIG)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nRTRS - s.nCWL, true});
-+    t[int(Command::MIG)].push_back({Command::PREA, 1, s.nRTP});
-+    t[int(Command::MIG)].push_back({Command::PREAF, 1, s.nRTP});
-+    t[int(Command::MIG)].push_back({Command::PREAM, 1, s.nRTP});
-+
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::MIG, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::PREA, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WR)].push_back({Command::PREAF, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WR)].push_back({Command::PREAM, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::MIG)].push_back({Command::PDE, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PDE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::MIG, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::ACTF, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACTF, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::ACTM, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACTM, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::PREA, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::PREF, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::PREAF, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::PREM, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::PREAM, 1, s.nRAS});
-+
-+    t[int(Command::ACTF)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACTF)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACTF)].push_back({Command::ACTF, 1, s.nRRD});
-+    t[int(Command::ACTF)].push_back({Command::ACTF, 4, s.nFAW});
-+    t[int(Command::ACTF)].push_back({Command::ACTM, 1, s.nRRD});
-+    t[int(Command::ACTF)].push_back({Command::ACTM, 4, s.nFAW});
-+    t[int(Command::ACTF)].push_back({Command::PRE, 1, s.nRASF});
-+    t[int(Command::ACTF)].push_back({Command::PREA, 1, s.nRASF});
-+    t[int(Command::ACTF)].push_back({Command::PREF, 1, s.nRASF});
-+    t[int(Command::ACTF)].push_back({Command::PREAF, 1, s.nRASF});
-+    t[int(Command::ACTF)].push_back({Command::PREM, 1, s.nRASF});
-+    t[int(Command::ACTF)].push_back({Command::PREAM, 1, s.nRASF});
-+
-+    t[int(Command::ACTM)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACTM)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACTM)].push_back({Command::ACTF, 1, s.nRRD});
-+    t[int(Command::ACTM)].push_back({Command::ACTF, 4, s.nFAW});
-+    t[int(Command::ACTM)].push_back({Command::ACTM, 1, s.nRRD});
-+    t[int(Command::ACTM)].push_back({Command::ACTM, 4, s.nFAW});
-+    t[int(Command::ACTM)].push_back({Command::PRE, 1, s.nRASM});
-+    t[int(Command::ACTM)].push_back({Command::PREA, 1, s.nRASM});
-+    t[int(Command::ACTM)].push_back({Command::PREF, 1, s.nRASM});
-+    t[int(Command::ACTM)].push_back({Command::PREAF, 1, s.nRASM});
-+    t[int(Command::ACTM)].push_back({Command::PREM, 1, s.nRASM});
-+    t[int(Command::ACTM)].push_back({Command::PREAM, 1, s.nRASM});
-+
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+    t[int(Command::PRE)].push_back({Command::ACTF, 1, s.nRP});
-+    t[int(Command::PRE)].push_back({Command::ACTM, 1, s.nRP});
-+
-+    t[int(Command::PREF)].push_back({Command::ACT, 1, s.nRPF});
-+    t[int(Command::PREF)].push_back({Command::ACTF, 1, s.nRPF});
-+    t[int(Command::PREF)].push_back({Command::ACTM, 1, s.nRPF});
-+
-+    t[int(Command::PREM)].push_back({Command::ACT, 1, s.nRPM});
-+    t[int(Command::PREM)].push_back({Command::ACTF, 1, s.nRPM});
-+    t[int(Command::PREM)].push_back({Command::ACTM, 1, s.nRPM});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREF)].push_back({Command::REF, 1, s.nRPF});
-+    t[int(Command::PREM)].push_back({Command::REF, 1, s.nRPM});
-+
-+    t[int(Command::PREA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PREAF)].push_back({Command::REF, 1, s.nRPF});
-+    t[int(Command::PREAM)].push_back({Command::REF, 1, s.nRPM});
-+
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+    t[int(Command::REF)].push_back({Command::ACTF, 1, s.nRFC});
-+    t[int(Command::REF)].push_back({Command::ACTM, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::ACTF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::ACTM)].push_back({Command::PDE, 1, 1});
-+
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::ACTF, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::ACTM, 1, s.nXP});
-+
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREF, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PREM, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREF)].push_back({Command::SRE, 1, s.nRPF});
-+    t[int(Command::PREM)].push_back({Command::SRE, 1, s.nRPM});
-+    t[int(Command::PREA)].push_back({Command::SRE, 1, s.nRP});
-+    t[int(Command::PREAF)].push_back({Command::SRE, 1, s.nRPF});
-+    t[int(Command::PREAM)].push_back({Command::SRE, 1, s.nRPM});
-+
-+    t[int(Command::SRX)].push_back({Command::ACT, 1, s.nXS});
-+    t[int(Command::SRX)].push_back({Command::ACTF, 1, s.nXS});
-+    t[int(Command::SRX)].push_back({Command::ACTM, 1, s.nXS});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PDE, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SRX)].push_back({Command::REF, 1, s.nXS});
-+
-+    // PD <-> PD
-+    t[int(Command::PDE)].push_back({Command::PDX, 1, s.nPD});
-+    t[int(Command::PDX)].push_back({Command::PDE, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SRE, 1, s.nXP});
-+    t[int(Command::SRX)].push_back({Command::PDE, 1, s.nXS});
-+
-+    // SR <-> SR
-+    t[int(Command::SRE)].push_back({Command::SRX, 1, s.nCKESR});
-+    t[int(Command::SRX)].push_back({Command::SRE, 1, s.nXS});
-+
-+
-+    /*** Bank ***/
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACTF)].push_back({Command::RD, 1, s.nRCDF});    // Fast Segment
-+    t[int(Command::ACTM)].push_back({Command::RD, 1, s.nRCDM});    // Fast Segment
-+
-+    t[int(Command::ACT)].push_back({Command::MIG, 1, s.nRCD});
-+    t[int(Command::ACTF)].push_back({Command::MIG, 1, s.nRCDF});  // Fast Segment
-+    t[int(Command::ACTM)].push_back({Command::MIG, 1, s.nRCDM});  // Fast Segment
-+
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACTF)].push_back({Command::WR, 1, s.nRCDF});    // Fast Segment
-+    t[int(Command::ACTM)].push_back({Command::WR, 1, s.nRCDM});    // Fast Segment
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::RD)].push_back({Command::PREF, 1, s.nRTP});
-+    t[int(Command::RD)].push_back({Command::PREM, 1, s.nRTP});
-+
-+    t[int(Command::MIG)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::MIG)].push_back({Command::PREF, 1, s.nRTP});
-+    t[int(Command::MIG)].push_back({Command::PREM, 1, s.nRTP});
-+
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WR)].push_back({Command::PREF, 1, s.nCWL + s.nBL + s.nWR});
-+
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::ACTF, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::ACTM, 1, s.nRC});
-+    t[int(Command::ACTF)].push_back({Command::ACT, 1, s.nRCF});
-+    t[int(Command::ACTF)].push_back({Command::ACTF, 1, s.nRCF});
-+    t[int(Command::ACTF)].push_back({Command::ACTM, 1, s.nRCF});
-+    t[int(Command::ACTM)].push_back({Command::ACT, 1, s.nRCM});
-+    t[int(Command::ACTM)].push_back({Command::ACTF, 1, s.nRCM});
-+    t[int(Command::ACTM)].push_back({Command::ACTM, 1, s.nRCM});
-+
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::PREF, 1, s.nRAS});
-+    t[int(Command::ACT)].push_back({Command::PREM, 1, s.nRAS});
-+    t[int(Command::ACTF)].push_back({Command::PRE, 1, s.nRASF});
-+    t[int(Command::ACTF)].push_back({Command::PREF, 1, s.nRASF});
-+    t[int(Command::ACTF)].push_back({Command::PREM, 1, s.nRASF});
-+    t[int(Command::ACTM)].push_back({Command::PRE, 1, s.nRASM});
-+    t[int(Command::ACTM)].push_back({Command::PREF, 1, s.nRASM});
-+    t[int(Command::ACTM)].push_back({Command::PREM, 1, s.nRASM});
-+
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+    t[int(Command::PRE)].push_back({Command::ACTF, 1, s.nRP});
-+    t[int(Command::PRE)].push_back({Command::ACTM, 1, s.nRP});
-+    t[int(Command::PREF)].push_back({Command::ACT, 1, s.nRPF});
-+    t[int(Command::PREF)].push_back({Command::ACTF, 1, s.nRPF});
-+    t[int(Command::PREF)].push_back({Command::ACTM, 1, s.nRPF});
-+    t[int(Command::PREM)].push_back({Command::ACT, 1, s.nRPM});
-+    t[int(Command::PREM)].push_back({Command::ACTF, 1, s.nRPM});
-+    t[int(Command::PREM)].push_back({Command::ACTM, 1, s.nRPM});
-+
-+}
-diff --git a/ext/ramulator/Ramulator/src/TLDRAM.h b/ext/ramulator/Ramulator/src/TLDRAM.h
-new file mode 100644
-index 0000000..deced42
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/TLDRAM.h
-@@ -0,0 +1,261 @@
-+#ifndef __TLDRAM_H
-+#define __TLDRAM_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <map>
-+#include <string>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class TLDRAM
-+{
-+public:
-+    int segment_ratio = 16;
-+
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    TLDRAM(Org org, Speed speed, int segment_ratio);
-+    TLDRAM(const string& org_str, const string& speed_str, int segment_ratio);
-+
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+    /*** Level ***/
-+    enum class Level : int
-+    {
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    {
-+        ACT, PRE, PREA,
-+        RD, WR,
-+        REF, PDE, PDX, SRE, SRX,
-+        ACTF, PREF, PREAF,
-+        MIG,
-+        ACTM, PREM, PREAM,
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PREA",
-+        "RD", "WR",
-+        "REF", "PDE", "PDX", "SRE", "SRX",
-+        "ACTF", "PREF", "PREAF",
-+        "MIG",
-+        "ACTM", "PREM", "PREAM"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row, Level::Bank, Level::Rank,
-+        Level::Column, Level::Column,
-+        Level::Rank, Level::Rank, Level::Rank, Level::Rank, Level::Rank,
-+        Level::Row, Level::Bank, Level::Rank,
-+        Level::Column,
-+        Level::Row, Level::Bank, Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+            case int(Command::ACTF):
-+            case int(Command::ACTM):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::MIG):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::PRE):
-+            case int(Command::PREF):
-+            case int(Command::PREM):
-+            case int(Command::PREA):
-+            case int(Command::PREAF):
-+            case int(Command::PREAM):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd)
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PDE, Command::SRE,
-+        Command::MIG
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<TLDRAM>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<TLDRAM>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<TLDRAM>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    };
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<TLDRAM>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        TLDRAM_512Mb_x4, TLDRAM_512Mb_x8, TLDRAM_512Mb_x16,
-+        TLDRAM_1Gb_x4,   TLDRAM_1Gb_x8,   TLDRAM_1Gb_x16,
-+        TLDRAM_2Gb_x4,   TLDRAM_2Gb_x8,   TLDRAM_2Gb_x16,
-+        TLDRAM_4Gb_x4,   TLDRAM_4Gb_x8,   TLDRAM_4Gb_x16,
-+        TLDRAM_8Gb_x4,   TLDRAM_8Gb_x8,   TLDRAM_8Gb_x16,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        {  512,  4, {0, 0, 8, 1<<13, 1<<11}},
-+        {  512,  8, {0, 0, 8, 1<<13, 1<<10}},
-+        {  512, 16, {0, 0, 8, 1<<12, 1<<10}},
-+        {1<<10,  4, {0, 0, 8, 1<<14, 1<<11}},
-+        {1<<10,  8, {0, 0, 8, 1<<14, 1<<10}},
-+        {1<<10, 16, {0, 0, 8, 1<<13, 1<<10}},
-+        {2<<10,  4, {0, 0, 8, 1<<15, 1<<11}},
-+        {2<<10,  8, {0, 0, 8, 1<<15, 1<<10}},
-+        {2<<10, 16, {0, 0, 8, 1<<14, 1<<10}},
-+        {4<<10,  4, {0, 0, 8, 1<<16, 1<<11}},
-+        {4<<10,  8, {0, 0, 8, 1<<16, 1<<10}},
-+        {4<<10, 16, {0, 0, 8, 1<<15, 1<<10}},
-+        {8<<10,  4, {0, 0, 8, 1<<16, 1<<12}},
-+        {8<<10,  8, {0, 0, 8, 1<<16, 1<<11}},
-+        {8<<10, 16, {0, 0, 8, 1<<16, 1<<10}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        TLDRAM_800D,  TLDRAM_800E,
-+        TLDRAM_1066E, TLDRAM_1066F, TLDRAM_1066G,
-+        TLDRAM_1333G, TLDRAM_1333H,
-+        TLDRAM_1600H, TLDRAM_1600J, TLDRAM_1600K,
-+        TLDRAM_1866K, TLDRAM_1866L,
-+        TLDRAM_2133L, TLDRAM_2133M,
-+        MAX
-+    };
-+
-+    int prefetch_size = 8; // 8n prefetch DDR
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nRTRS;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRD, nFAW;
-+        int nRFC, nREFI;
-+        int nPD, nXP, nXPDLL;
-+        int nCKESR, nXS, nXSDLL;
-+        int nRCDF, nRPF, nRASF, nRCF;
-+        int nRCDM, nRPM, nRASM, nRCM;
-+    } speed_table[int(Speed::MAX)] = {
-+        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  5,  5,  5,  5, 15, 20, 4, 4,  6, 0, 0, 0,
-+          3120, 3, 3, 10, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {800,  (400.0/3)*3, (3/0.4)/3, 4, 4, 2,  6,  6,  6,  5, 15, 21, 4, 4,  6, 0, 0, 0,
-+          3120, 3, 3, 10, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  6,  6,  6,  6, 20, 26, 4, 4,  8, 0, 0, 0,
-+          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  7,  7,  7,  6, 20, 27, 4, 4,  8, 0, 0, 0,
-+          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1066, (400.0/3)*4, (3/0.4)/4, 4, 4, 2,  8,  8,  8,  6, 20, 28, 4, 4,  8, 0, 0, 0,
-+          4160, 3, 4, 13, 4, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  8,  8,  8,  7, 24, 32, 5, 5, 10, 0, 0, 0,
-+          5200, 4, 4, 16, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1333, (400.0/3)*5, (3/0.4)/5, 4, 4, 2,  9,  9,  9,  7, 24, 33, 5, 5, 10, 0, 0, 0,
-+          5200, 4, 4, 16, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2,  9,  9,  9,  8, 28, 37, 6, 6, 12, 0, 0, 0,
-+          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 10, 10, 10,  8, 28, 38, 6, 6, 12, 0, 0, 0,
-+          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1600, (400.0/3)*6, (3/0.4)/6, 4, 4, 2, 11, 11, 11,  8, 28, 39, 6, 6, 12, 0, 0, 0,
-+          6240, 4, 5, 20, 5, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 11, 11, 11,  9, 32, 43, 7, 7, 14, 0, 0, 0,
-+          7280, 5, 6, 23, 6, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {1866, (400.0/3)*7, (3/0.4)/7, 4, 4, 2, 12, 12, 12,  9, 32, 44, 7, 7, 14, 0, 0, 0,
-+          7280, 5, 6, 23, 6, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 12, 12, 12, 10, 36, 48, 8, 8, 16, 0, 0, 0,
-+          8320, 6, 7, 26, 7, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26},
-+        {2133, (400.0/3)*8, (3/0.4)/8, 4, 4, 2, 13, 13, 13, 10, 36, 49, 8, 8, 16, 0, 0, 0,
-+          8320, 6, 7, 26, 7, 0, 512, 3, 3, 10, 13, 6, 6, 20, 26}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__TLDRAM_H*/
-diff --git a/ext/ramulator/Ramulator/src/WideIO.cpp b/ext/ramulator/Ramulator/src/WideIO.cpp
-new file mode 100644
-index 0000000..987193f
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/WideIO.cpp
-@@ -0,0 +1,326 @@
-+#include "WideIO.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string WideIO::standard_name = "WideIO";
-+string WideIO::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum WideIO::Org> WideIO::org_map = {
-+    {"WideIO_1Gb", WideIO::Org::WideIO_1Gb},
-+    {"WideIO_2Gb", WideIO::Org::WideIO_2Gb},
-+    {"WideIO_4Gb", WideIO::Org::WideIO_4Gb},
-+    {"WideIO_8Gb", WideIO::Org::WideIO_8Gb},
-+};
-+
-+map<string, enum WideIO::Speed> WideIO::speed_map = {
-+    {"WideIO_200", WideIO::Speed::WideIO_200}, 
-+    {"WideIO_266", WideIO::Speed::WideIO_266},
-+};
-+
-+WideIO::WideIO(Org org, Speed speed) : 
-+    org_entry(org_table[int(org)]), 
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-+{
-+    init_speed();
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_rowopen();
-+    init_lambda();
-+    init_timing();
-+}
-+
-+WideIO::WideIO(const string& org_str, const string& speed_str) :
-+    WideIO(org_map[org_str], speed_map[speed_str]) 
-+{
-+}
-+
-+void WideIO::set_channel_number(int channel) {
-+  assert((channel == 4) && "The Wide I/O interface supports 4 physical and 4 logical channels.");
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void WideIO::set_rank_number(int rank) {
-+  assert((rank == 1) && "WideIO rank number is fixed to 1.");
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void WideIO::init_speed()
-+{
-+    const static int RFC_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-+        {18, 26, 26, 42},
-+        {24, 35, 35, 56}
-+    };
-+    const static int REFI_TABLE[int(Speed::MAX)][int(Org::MAX)] = {
-+        {3120, 1560, 780, 780},
-+        {4160, 2080, 1040, 520}
-+    };
-+    int speed = 0, density = 0;
-+    switch(speed_entry.rate){
-+        case 200: speed = 0; break;
-+        case 266: speed = 1; break;
-+        default: assert(false);
-+    }
-+    switch(org_entry.size >> 8){
-+        case 1: density = 0; break;
-+        case 2: density = 1; break;
-+        case 4: density = 2; break;
-+        case 8: density = 3; break;
-+        default: assert(false);
-+    }
-+    speed_entry.nRFC = RFC_TABLE[speed][density];
-+    speed_entry.nREFI = REFI_TABLE[speed][density];
-+}
-+
-+
-+void WideIO::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PRA;
-+        }
-+        return Command::REF;};
-+
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PD;
-+            case int(State::ActPowerDown): return Command::PD;
-+            case int(State::PrePowerDown): return Command::PD;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SREF;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREF;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void WideIO::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void WideIO::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void WideIO::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<WideIO>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<WideIO>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<WideIO>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::WR)] = [] (DRAM<WideIO>* node, int id) {};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<WideIO>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<WideIO>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<WideIO>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<WideIO>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void WideIO::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/ 
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/ 
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nRTW});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nRTW});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nRTW});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nRTW});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nWTR});
-+
-+    // CAS <-> PRA
-+    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+    
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 2, s.nTAW});
-+    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-+    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRP});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRP});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFC});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRP});
-+    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRP});
-+    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFC});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-+    
-+    // PD <-> PD
-+    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-+    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-+    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-+    
-+    // SR <-> SR
-+    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-+    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-+
-+
-+    /*** Bank ***/ 
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRP});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + s.nBL + s.nWR + s.nRP});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRP});
-+}
-diff --git a/ext/ramulator/Ramulator/src/WideIO.h b/ext/ramulator/Ramulator/src/WideIO.h
-new file mode 100644
-index 0000000..4cdbc76
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/WideIO.h
-@@ -0,0 +1,203 @@
-+#ifndef __WIDEIO_H
-+#define __WIDEIO_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class WideIO
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    WideIO(Org org, Speed speed);
-+    WideIO(const string& org_str, const string& speed_str);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+
-+    /*** Level ***/
-+    enum class Level : int
-+    { 
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    { 
-+        ACT, PRE, PRA, 
-+        RD,  WR,  RDA,  WRA, 
-+        REF, PD,  PDX,  SREF, SREFX, 
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE", "PRA", 
-+        "RD",  "WR",  "RDA",  "WRA", 
-+        "REF", "PD", "PDX",  "SREF", "SREFX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PD, Command::SREF
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<WideIO>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<WideIO>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<WideIO>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<WideIO>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        WideIO_1Gb,
-+        WideIO_2Gb,
-+        WideIO_4Gb,
-+        WideIO_8Gb,
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size;
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_table[int(Org::MAX)] = {
-+        // fixed to have 1 rank
-+        { 256, 128, {0, 1, 4, 1<<12, 1<<7}},
-+        { 512, 128, {0, 1, 4, 1<<13, 1<<7}},
-+        {1024, 128, {0, 1, 4, 1<<14, 1<<7}},
-+        {2048, 128, {0, 1, 4, 1<<15, 1<<7}}
-+    }, org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        WideIO_200,
-+        WideIO_266,
-+        MAX
-+    };
-+    
-+    int prefetch_size = 4; // 4n prefetch SDR
-+    int channel_width = 128;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nDQSCK;
-+        int nCL, nRCD, nRP, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nRTW, nWTR, nWR;
-+        int nRRD, nTAW;
-+        int nRFC, nREFI;
-+        int nCKE, nXP;
-+        int nCKESR, nXSR; // tXSR = tRFC+10
-+    } speed_table[int(Speed::MAX)] = {
-+        {200, 200.0/3*3, 5.0*3/3, 4, 4, 1, 3, 4, 4, 1,  9, 12, 4, 8, 3, 3, 2, 10, 0, 0, 3, 2, 3, 0},
-+        {266, 200.0/3*4, 5.0*3/4, 4, 4, 1, 3, 5, 5, 1, 12, 16, 4, 8, 4, 4, 3, 14, 0, 0, 3, 3, 4, 0}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_speed();
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__WIDEIO_H*/
-diff --git a/ext/ramulator/Ramulator/src/WideIO2.cpp b/ext/ramulator/Ramulator/src/WideIO2.cpp
-new file mode 100644
-index 0000000..c451738
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/WideIO2.cpp
-@@ -0,0 +1,339 @@
-+#include "WideIO2.h"
-+#include "DRAM.h"
-+#include <vector>
-+#include <functional>
-+#include <cassert>
-+
-+using namespace std;
-+using namespace ramulator;
-+
-+string WideIO2::standard_name = "WideIO2";
-+string WideIO2::level_str [int(Level::MAX)] = {"Ch", "Ra", "Ba", "Ro", "Co"};
-+
-+map<string, enum WideIO2::Org> WideIO2::org_map = {
-+    {"WideIO2_8Gb", WideIO2::Org::WideIO2_8Gb},
-+};
-+
-+map<string, enum WideIO2::Speed> WideIO2::speed_map = {
-+    {"WideIO2_800", WideIO2::Speed::WideIO2_800}, 
-+    {"WideIO2_1066", WideIO2::Speed::WideIO2_1066},
-+};
-+
-+WideIO2::WideIO2(Org org, Speed speed, int channels) :  
-+    speed_entry(speed_table[int(speed)]),
-+    read_latency(speed_entry.nCL + speed_entry.nDQSCK + speed_entry.nBL)
-+{
-+    switch(int(org)){
-+        case int(Org::WideIO2_8Gb):
-+            org_entry.size = (8<<10) / channels;
-+            org_entry.dq = 64;
-+            if (channels == 4) {
-+                org_entry.size = 2<<10;
-+                org_entry.count[int(Level::Channel)] = channels;
-+                org_entry.count[int(Level::Rank)] = 0;
-+                org_entry.count[int(Level::Bank)] = 8;
-+                org_entry.count[int(Level::Row)] = 1<<13;
-+                org_entry.count[int(Level::Column)] = 1<<9;
-+            } else if (channels == 8) {
-+                org_entry.size = 1<<10;
-+                org_entry.count[int(Level::Channel)] = channels;
-+                org_entry.count[int(Level::Rank)] = 0;
-+                org_entry.count[int(Level::Bank)] = 4;
-+                org_entry.count[int(Level::Row)] = 1<<14;
-+                org_entry.count[int(Level::Column)] = 1<<8;
-+            } else assert(false && "The WideIO2 interface supports 4 or 8 physical channels.");
-+            break;
-+        default: assert(false);
-+    }
-+    speed_entry.nRPab = (channels == 4)? speed_entry.nRP8b: speed_entry.nRPpb;
-+    init_prereq();
-+    init_rowhit(); // SAUGATA: added row hit function
-+    init_lambda();
-+    init_timing();
-+}
-+
-+WideIO2::WideIO2(const string& org_str, const string& speed_str, int channels) :
-+    WideIO2(org_map[org_str], speed_map[speed_str], channels)
-+{
-+}
-+
-+void WideIO2::set_channel_number(int channel) {
-+  assert((channel == org_entry.count[int(Level::Channel)]) && "channel number must be consistent with spec initializaiton configuration.");
-+  org_entry.count[int(Level::Channel)] = channel;
-+}
-+
-+void WideIO2::set_rank_number(int rank) {
-+  assert(((rank == 1) || (rank == 2)) && "WideIO2 supports single and dual rank configurations.");
-+  org_entry.count[int(Level::Rank)] = rank;
-+}
-+
-+void WideIO2::init_prereq()
-+{
-+    // RD
-+    prereq[int(Level::Rank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::MAX;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+    prereq[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return Command::ACT;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return cmd;
-+                return Command::PRE;
-+            default: assert(false);
-+        }};
-+    // WR
-+    prereq[int(Level::Rank)][int(Command::WR)] = prereq[int(Level::Rank)][int(Command::RD)];
-+    prereq[int(Level::Bank)][int(Command::WR)] = prereq[int(Level::Bank)][int(Command::RD)];
-+    // REF
-+    prereq[int(Level::Rank)][int(Command::REF)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            return Command::PRA;
-+        }
-+        return Command::REF;};
-+    // PD
-+    prereq[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::PD;
-+            case int(State::ActPowerDown): return Command::PD;
-+            case int(State::PrePowerDown): return Command::PD;
-+            case int(State::SelfRefresh): return Command::SREFX;
-+            default: assert(false);
-+        }};
-+    // SR
-+    prereq[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::PowerUp): return Command::SREF;
-+            case int(State::ActPowerDown): return Command::PDX;
-+            case int(State::PrePowerDown): return Command::PDX;
-+            case int(State::SelfRefresh): return Command::SREF;
-+            default: assert(false);
-+        }};
-+}
-+
-+// SAUGATA: added row hit check functions to see if the desired location is currently open
-+void WideIO2::init_rowhit()
-+{
-+    // RD
-+    rowhit[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened):
-+                if (node->row_state.find(id) != node->row_state.end())
-+                    return true;
-+                return false;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowhit[int(Level::Bank)][int(Command::WR)] = rowhit[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void WideIO2::init_rowopen()
-+{
-+    // RD
-+    rowopen[int(Level::Bank)][int(Command::RD)] = [] (DRAM<WideIO2>* node, Command cmd, int id) {
-+        switch (int(node->state)) {
-+            case int(State::Closed): return false;
-+            case int(State::Opened): return true;
-+            default: assert(false);
-+        }};
-+
-+    // WR
-+    rowopen[int(Level::Bank)][int(Command::WR)] = rowopen[int(Level::Bank)][int(Command::RD)];
-+}
-+
-+void WideIO2::init_lambda()
-+{
-+    lambda[int(Level::Bank)][int(Command::ACT)] = [] (DRAM<WideIO2>* node, int id) {
-+        node->state = State::Opened;
-+        node->row_state[id] = State::Opened;};
-+    lambda[int(Level::Bank)][int(Command::PRE)] = [] (DRAM<WideIO2>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PRA)] = [] (DRAM<WideIO2>* node, int id) {
-+        for (auto bank : node->children) {
-+            bank->state = State::Closed;
-+            bank->row_state.clear();}};
-+    lambda[int(Level::Bank)][int(Command::RDA)] = [] (DRAM<WideIO2>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Bank)][int(Command::WRA)] = [] (DRAM<WideIO2>* node, int id) {
-+        node->state = State::Closed;
-+        node->row_state.clear();};
-+    lambda[int(Level::Rank)][int(Command::PD)] = [] (DRAM<WideIO2>* node, int id) {
-+        for (auto bank : node->children) {
-+            if (bank->state == State::Closed)
-+                continue;
-+            node->state = State::ActPowerDown;
-+            return;
-+        }
-+        node->state = State::PrePowerDown;};
-+    lambda[int(Level::Rank)][int(Command::PDX)] = [] (DRAM<WideIO2>* node, int id) {
-+        node->state = State::PowerUp;};
-+    lambda[int(Level::Rank)][int(Command::SREF)] = [] (DRAM<WideIO2>* node, int id) {
-+        node->state = State::SelfRefresh;};
-+    lambda[int(Level::Rank)][int(Command::SREFX)] = [] (DRAM<WideIO2>* node, int id) {
-+        node->state = State::PowerUp;};
-+}
-+
-+
-+void WideIO2::init_timing()
-+{
-+    SpeedEntry& s = speed_entry;
-+    vector<TimingEntry> *t;
-+
-+    /*** Channel ***/ 
-+    t = timing[int(Level::Channel)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nBL});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nBL});
-+
-+
-+    /*** Rank ***/ 
-+    t = timing[int(Level::Rank)];
-+
-+    // CAS <-> CAS
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nCCD});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WR)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WR, 1, s.nCCD});
-+    t[int(Command::WRA)].push_back({Command::WRA, 1, s.nCCD});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nDQSCK + s.nBL + 1 - s.nCWL});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + 1 + s.nBL + s.nWTR});
-+
-+    // CAS <-> CAS (between sibling ranks)
-+    t[int(Command::RD)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RD, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::RDA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nBL + s.nRTRS, true});
-+    t[int(Command::RD)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RD)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WR, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::RDA)].push_back({Command::WRA, 1, s.nCL + s.nBL + s.nDQSCK + 1 + s.nRTRS - s.nCWL, true});
-+    t[int(Command::WR)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WR)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RD, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+    t[int(Command::WRA)].push_back({Command::RDA, 1, s.nCWL + s.nBL + s.nRTRS - s.nCL, true});
-+
-+    // CAS <-> PRA
-+    t[int(Command::RD)].push_back({Command::PRA, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRA, 1, s.nCWL + 1 + s.nBL + s.nWR});
-+
-+    // CAS <-> PD
-+    t[int(Command::RD)].push_back({Command::PD, 1, s.nCL + s.nDQSCK + s.nBL + 1});
-+    t[int(Command::RDA)].push_back({Command::PD, 1, s.nCL + s.nDQSCK + s.nBL + 1});
-+    t[int(Command::WR)].push_back({Command::PD, 1, s.nCWL + 1 + s.nBL + s.nWR});
-+    t[int(Command::WRA)].push_back({Command::PD, 1, s.nCWL + 1 + s.nBL + s.nWR + 1}); // +1 for pre
-+    t[int(Command::PDX)].push_back({Command::RD, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::RDA, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WR, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::WRA, 1, s.nXP});
-+    
-+    // CAS <-> SR: none (all banks have to be precharged)
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRRD});
-+    t[int(Command::ACT)].push_back({Command::ACT, 4, s.nFAW});
-+    t[int(Command::ACT)].push_back({Command::PRA, 1, s.nRAS});
-+    t[int(Command::PRA)].push_back({Command::ACT, 1, s.nRPab});
-+
-+    // RAS <-> REF
-+    t[int(Command::PRE)].push_back({Command::REF, 1, s.nRPpb});
-+    t[int(Command::PRA)].push_back({Command::REF, 1, s.nRPab});
-+    t[int(Command::REF)].push_back({Command::ACT, 1, s.nRFCab});
-+
-+    // RAS <-> PD
-+    t[int(Command::ACT)].push_back({Command::PD, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::ACT, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRE, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::PRA, 1, s.nXP});
-+
-+    // RAS <-> SR
-+    t[int(Command::PRE)].push_back({Command::SREF, 1, s.nRPpb});
-+    t[int(Command::PRA)].push_back({Command::SREF, 1, s.nRPab});
-+    t[int(Command::SREFX)].push_back({Command::ACT, 1, s.nXSR});
-+
-+    // REF <-> REF
-+    t[int(Command::REF)].push_back({Command::REF, 1, s.nRFCab});
-+    t[int(Command::REF)].push_back({Command::REFPB, 1, s.nRFCab});
-+    t[int(Command::REFPB)].push_back({Command::REF, 1, s.nRFCpb});
-+
-+    // REF <-> PD
-+    t[int(Command::REF)].push_back({Command::PD, 1, 1});
-+    t[int(Command::REFPB)].push_back({Command::PD, 1, 1});
-+    t[int(Command::PDX)].push_back({Command::REF, 1, s.nXP});
-+    t[int(Command::PDX)].push_back({Command::REFPB, 1, s.nXP});
-+
-+    // REF <-> SR
-+    t[int(Command::SREFX)].push_back({Command::REF, 1, s.nXSR});
-+    t[int(Command::SREFX)].push_back({Command::REFPB, 1, s.nXSR});
-+
-+    // PD <-> PD
-+    t[int(Command::PD)].push_back({Command::PDX, 1, s.nCKE});
-+    t[int(Command::PDX)].push_back({Command::PD, 1, s.nXP});
-+
-+    // PD <-> SR
-+    t[int(Command::PDX)].push_back({Command::SREF, 1, s.nXP});
-+    t[int(Command::SREFX)].push_back({Command::PD, 1, s.nXSR});
-+    
-+    // SR <-> SR
-+    t[int(Command::SREF)].push_back({Command::SREFX, 1, s.nCKESR});
-+    t[int(Command::SREFX)].push_back({Command::SREF, 1, s.nXSR});
-+
-+    /*** Bank ***/ 
-+    t = timing[int(Level::Bank)];
-+
-+    // CAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::RD, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::RDA, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WR, 1, s.nRCD});
-+    t[int(Command::ACT)].push_back({Command::WRA, 1, s.nRCD});
-+
-+    t[int(Command::RD)].push_back({Command::PRE, 1, s.nRTP});
-+    t[int(Command::WR)].push_back({Command::PRE, 1, s.nCWL + 1 + s.nBL + s.nWR});
-+
-+    t[int(Command::RDA)].push_back({Command::ACT, 1, s.nRTP + s.nRPpb});
-+    t[int(Command::WRA)].push_back({Command::ACT, 1, s.nCWL + 1 + s.nBL + s.nWR + s.nRPpb});
-+
-+    // RAS <-> RAS
-+    t[int(Command::ACT)].push_back({Command::ACT, 1, s.nRC});
-+    t[int(Command::ACT)].push_back({Command::PRE, 1, s.nRAS});
-+    t[int(Command::PRE)].push_back({Command::ACT, 1, s.nRPpb});
-+    t[int(Command::PRE)].push_back({Command::REFPB, 1, s.nRPpb});
-+
-+    // between different banks
-+    t[int(Command::ACT)].push_back({Command::REFPB, 1, s.nRRD, true});
-+    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRRD, true});
-+
-+    // REFPB
-+    t[int(Command::REFPB)].push_back({Command::REFPB, 1, s.nRFCpb});
-+    t[int(Command::REFPB)].push_back({Command::ACT, 1, s.nRFCpb});
-+}
-diff --git a/ext/ramulator/Ramulator/src/WideIO2.h b/ext/ramulator/Ramulator/src/WideIO2.h
-new file mode 100644
-index 0000000..36ee794
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/WideIO2.h
-@@ -0,0 +1,199 @@
-+#ifndef __WIDEIO2_H
-+#define __WIDEIO2_H
-+
-+#include "DRAM.h"
-+#include "Request.h"
-+#include <vector>
-+#include <functional>
-+
-+using namespace std;
-+
-+namespace ramulator
-+{
-+
-+class WideIO2
-+{
-+public:
-+    static string standard_name;
-+    enum class Org;
-+    enum class Speed;
-+    WideIO2(Org org, Speed speed, int channels = 4);
-+    WideIO2(const string& org_str, const string& speed_str, int channels = 4);
-+    
-+    static map<string, enum Org> org_map;
-+    static map<string, enum Speed> speed_map;
-+
-+    /*** Level ***/
-+    enum class Level : int
-+    { 
-+        Channel, Rank, Bank, Row, Column, MAX
-+    };
-+    
-+    static std::string level_str [int(Level::MAX)];
-+
-+    /*** Command ***/
-+    enum class Command : int
-+    { 
-+        ACT, PRE,   PRA, 
-+        RD,  WR,    RDA,  WRA, 
-+        REF, REFPB, PD,  PDX,  SREF, SREFX, 
-+        MAX
-+    };
-+
-+    string command_name[int(Command::MAX)] = {
-+        "ACT", "PRE",   "PRA", 
-+        "RD",  "WR",    "RDA", "WRA", 
-+        "REF", "REFPB", "PD",  "PDX",  "SREF", "SREFX"
-+    };
-+
-+    Level scope[int(Command::MAX)] = {
-+        Level::Row,    Level::Bank,   Level::Rank,   
-+        Level::Column, Level::Column, Level::Column, Level::Column,
-+        Level::Rank,   Level::Bank,   Level::Rank,   Level::Rank,   Level::Rank,   Level::Rank
-+    };
-+
-+    bool is_opening(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::ACT):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_accessing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RD):
-+            case int(Command::WR):
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_closing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::RDA):
-+            case int(Command::WRA):
-+            case int(Command::PRE):
-+            case int(Command::PRA):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+    bool is_refreshing(Command cmd) 
-+    {
-+        switch(int(cmd)) {
-+            case int(Command::REF):
-+            case int(Command::REFPB):
-+                return true;
-+            default:
-+                return false;
-+        }
-+    }
-+
-+
-+    /* State */
-+    enum class State : int
-+    {
-+        Opened, Closed, PowerUp, ActPowerDown, PrePowerDown, SelfRefresh, MAX
-+    } start[int(Level::MAX)] = {
-+        State::MAX, State::PowerUp, State::Closed, State::Closed, State::MAX
-+    };
-+
-+    /* Translate */
-+    Command translate[int(Request::Type::MAX)] = {
-+        Command::RD,  Command::WR,
-+        Command::REF, Command::PD, Command::SREF
-+    };
-+
-+    /* Prerequisite */
-+    function<Command(DRAM<WideIO2>*, Command cmd, int)> prereq[int(Level::MAX)][int(Command::MAX)];
-+
-+    // SAUGATA: added function object container for row hit status
-+    /* Row hit */
-+    function<bool(DRAM<WideIO2>*, Command cmd, int)> rowhit[int(Level::MAX)][int(Command::MAX)];
-+    function<bool(DRAM<WideIO2>*, Command cmd, int)> rowopen[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Timing */
-+    struct TimingEntry
-+    {
-+        Command cmd;
-+        int dist;
-+        int val;
-+        bool sibling;
-+    }; 
-+    vector<TimingEntry> timing[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Lambda */
-+    function<void(DRAM<WideIO2>*, int)> lambda[int(Level::MAX)][int(Command::MAX)];
-+
-+    /* Organization */
-+    enum class Org : int
-+    {
-+        // per-die density
-+        WideIO2_8Gb,
-+        // WideIO2_12Gb, tRFC TBD
-+        // WideIO2_16Gb, tRFC TBD
-+        // WideIO2_24Gb, TBD
-+        // WideIO2_32Gb, TBD
-+        MAX
-+    };
-+
-+    struct OrgEntry {
-+        int size; // per-channel density
-+        int dq;
-+        int count[int(Level::MAX)];
-+    } org_entry;
-+
-+    void set_channel_number(int channel);
-+    void set_rank_number(int rank);
-+
-+    /* Speed */
-+    enum class Speed : int
-+    {
-+        WideIO2_800,
-+        WideIO2_1066,
-+        MAX
-+    };
-+    // WideIO2 specified /4, /2, x1, x2, x4 refresh rates. x1 is used here
-+
-+    int prefetch_size = 4;
-+    int channel_width = 64;
-+
-+    struct SpeedEntry {
-+        int rate;
-+        double freq, tCK;
-+        int nBL, nCCD, nDQSCK, nRTRS; // 4n prefetch, DDR (although 8n is allowed?)
-+        int nCL, nRCD, nRPpb, nRP8b, nRPab, nCWL;
-+        int nRAS, nRC;
-+        int nRTP, nWTR, nWR;
-+        int nRRD, nFAW;
-+        int nRFCab, nRFCpb, nREFI;
-+        int nCKE, nXP;
-+        int nCKESR, nXSR;
-+    } speed_table[int(Speed::MAX)] = {
-+        { 800, 800.0/3*3, 2.5*3/3, 2, 2, 1, 2, 7,  8,  8,  9, 0, 5, 17, 25, 3, 4,  8, 4, 24, 72, 36, 1560, 3, 3, 6,  76},
-+        {1066, 800.0/3*4, 2.5*3/4, 2, 2, 1, 2, 9, 10, 10, 12, 0, 7, 23, 33, 4, 6, 11, 6, 32, 96, 48, 2080, 3, 4, 8, 102}
-+    }, speed_entry;
-+
-+    int read_latency;
-+
-+private:
-+    void init_lambda();
-+    void init_prereq();
-+    void init_rowhit();  // SAUGATA: added function to check for row hits
-+    void init_rowopen();
-+    void init_timing();
-+};
-+
-+} /*namespace ramulator*/
-+
-+#endif /*__WIDEIO2_H*/
-diff --git a/ext/ramulator/Ramulator/src/temp.txt b/ext/ramulator/Ramulator/src/temp.txt
-new file mode 100644
-index 0000000..2e48992
---- /dev/null
-+++ b/ext/ramulator/Ramulator/src/temp.txt
-@@ -0,0 +1,113 @@
-+
-+
-+#include "ALDRAM.h"
-+#include "TLDRAM.h"
-+
-+
-+    ALDRAM* aldram = new ALDRAM(ALDRAM::Org::ALDRAM_4Gb_x8, ALDRAM::Speed::ALDRAM_1600K);
-+    IPC = run_simulation(aldram, argv[1], 1, 1, 4);
-+    printf("ALDRAM:   %.5lf %.5lf\n", IPC, IPC / baseIPC);
-+
-+    TLDRAM* tldram = new TLDRAM(TLDRAM::Org::TLDRAM_4Gb_x8, TLDRAM::Speed::TLDRAM_1600K, 16);
-+    IPC = run_simulation(tldram, argv[1], 1, 1, 4);
-+    printf("TLDRAM:   %.5lf %.5lf\n", IPC, IPC / baseIPC);
-+
-+
-+            // ALDRAM: update timing parameters based on temperatures
-+            ALDRAM::Temp current_temperature = ALDRAM::Temp::COLD;
-+            update_temp(current_temperature);
-+
-+
-+    void update_temp(ALDRAM::Temp current_temperature)
-+    {
-+    }
-+
-+
-+template <>
-+void Controller<ALDRAM>::update_temp(ALDRAM::Temp current_temperature){
-+    channel->spec->aldram_timing(current_temperature);
-+}
-+
-+
-+template <>
-+void Controller<TLDRAM>::tick(){
-+    clk++;
-+
-+    /*** 1. Serve completed reads ***/
-+    if (pending.size()) {
-+        Request& req = pending[0];
-+        if (req.depart <= clk) {
-+            req.callback(req);
-+            pending.pop_front();
-+        }
-+    }
-+
-+    /*** 2. Should we schedule refreshes? ***/
-+    int refresh_interval = channel->spec->speed_entry.nREFI;
-+    if (clk - refreshed >= refresh_interval) {
-+        auto req_type = Request::Type::REFRESH;
-+
-+        vector<int> addr_vec(int(TLDRAM::Level::MAX), -1);
-+        addr_vec[0] = channel->id;
-+        for (auto child : channel->children) {
-+            addr_vec[1] = child->id;
-+            Request req(addr_vec, req_type, NULL);
-+            bool res = enqueue(req);
-+            assert(res);
-+        }
-+        refreshed = clk;
-+    }
-+
-+    /*** 3. Should we schedule writes? ***/
-+    if (!write_mode) {
-+        // yes -- write queue is almost full or read queue is empty
-+        if (writeq.size() >= int(0.8 * writeq.max) || readq.size() == 0)
-+            write_mode = true;
-+    }
-+    else {
-+        // no -- write queue is almost empty and read queue is not empty
-+        if (writeq.size() <= int(0.2 * writeq.max) && readq.size() != 0)
-+            write_mode = false;
-+    }
-+
-+    /*** 4. Find the best command to schedule, if any ***/
-+    Queue* queue = !write_mode ? &readq : &writeq;
-+    if (otherq.size())
-+        queue = &otherq;  // "other" requests are rare, so we give them precedence over reads/writes
-+
-+    auto req = scheduler->get_head(queue->q);
-+    if (req == queue->q.end() || !is_ready(req)) {
-+        // we couldn't find a command to schedule -- let's try to be speculative
-+        auto cmd = TLDRAM::Command::PRE;
-+        vector<int> victim = rowpolicy->get_victim(cmd);
-+        if (!victim.empty()){
-+            issue_cmd(cmd, victim);
-+        }
-+        return;  // nothing more to be done this cycle
-+    }
-+
-+    /*** 5. Change a read request to a migration request ***/
-+    if (req->type == Request::Type::READ) {
-+        req->type = Request::Type::EXTENSION;
-+    }
-+
-+    // issue command on behalf of request
-+    auto cmd = get_first_cmd(req);
-+    issue_cmd(cmd, get_addr_vec(cmd, req));
-+
-+    // check whether this is the last command (which finishes the request)
-+    if (cmd != channel->spec->translate[int(req->type)])
-+        return;
-+
-+    // set a future completion time for read requests
-+    if (req->type == Request::Type::READ || req->type == Request::Type::EXTENSION) {
-+        req->depart = clk + channel->spec->read_latency;
-+        pending.push_back(*req);
-+    }
-+
-+    // remove request from queue
-+    queue->q.erase(req);
-+}
-+
-+
-+        EXTENSION,  // DHL: supporting extended functionality
-diff --git a/ext/ramulator/SConscript b/ext/ramulator/SConscript
-new file mode 100644
-index 0000000..2709034
---- /dev/null
-+++ b/ext/ramulator/SConscript
-@@ -0,0 +1,49 @@
-+# -*- mode:python -*-
-+
-+import os
-+
-+Import('main')
-+
-+if not os.path.exists(Dir('.').srcnode().abspath + '/Ramulator'):
-+    main['HAVE_RAMULATOR'] = False
-+    Return()
-+
-+# We have got the folder, so add the library and build the wrappers
-+main['HAVE_RAMULATOR'] = True
-+
-+# Add the appropriate files. We leave out the trace driven simulator
-+dram_files = []
-+
-+def DRAMFile(filename):
-+    dram_files.append(File('Ramulator/src/' + filename))
-+
-+DRAMFile('Config.cpp')
-+DRAMFile('Controller.cpp')
-+DRAMFile('DDR3.cpp')
-+DRAMFile('DDR4.cpp')
-+DRAMFile('GDDR5.cpp')
-+DRAMFile('Gem5Wrapper.cpp')
-+DRAMFile('HBM.cpp')
-+DRAMFile('LPDDR3.cpp')
-+DRAMFile('LPDDR4.cpp')
-+DRAMFile('MemoryFactory.cpp')
-+DRAMFile('SALP.cpp')
-+DRAMFile('WideIO.cpp')
-+DRAMFile('WideIO2.cpp')
-+DRAMFile('TLDRAM.cpp')
-+DRAMFile('ALDRAM.cpp')
-+
-+dramenv = main.Clone()
-+dramenv.Append(CXXFLAGS=['-g'])
-+dramenv.Append(CXXFLAGS=['-Wno-missing-field-initializers'])
-+dramenv.Append(CXXFLAGS=['-Wno-unused-variable'])
-+dramenv.Append(CXXFLAGS=['-Wno-reorder'])
-+
-+# added support to hook in gem5 headers
-+dramenv.Append(CPPPATH = Dir('./../../src/'))
-+
-+dramenv.Library('ramulator', [dramenv.SharedObject(f) for f in dram_files])
-+
-+main.Prepend(CPPPATH=Dir('.'))
-+main.Append(LIBS=['ramulator'])
-+main.Prepend(LIBPATH=[Dir('.')])
-diff --git a/ramulator_configs/1chan_2rank_nbr.cfg b/ramulator_configs/1chan_2rank_nbr.cfg
-new file mode 100755
-index 0000000..021d3ef
---- /dev/null
-+++ b/ramulator_configs/1chan_2rank_nbr.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_2rank_nbr_nbw.cfg b/ramulator_configs/1chan_2rank_nbr_nbw.cfg
-new file mode 100755
-index 0000000..49f5e62
---- /dev/null
-+++ b/ramulator_configs/1chan_2rank_nbr_nbw.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2_modified
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_2rank_nbr_nbw_custom.cfg b/ramulator_configs/1chan_2rank_nbr_nbw_custom.cfg
-new file mode 100755
-index 0000000..400dacc
---- /dev/null
-+++ b/ramulator_configs/1chan_2rank_nbr_nbw_custom.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2_custom
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_2rank_nbr_nbw_lbb.cfg b/ramulator_configs/1chan_2rank_nbr_nbw_lbb.cfg
-new file mode 100755
-index 0000000..c4ce76e
---- /dev/null
-+++ b/ramulator_configs/1chan_2rank_nbr_nbw_lbb.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_2rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/1chan_2rank_nbr_nbw_lbb_64b.cfg
-new file mode 100755
-index 0000000..eb46173
---- /dev/null
-+++ b/ramulator_configs/1chan_2rank_nbr_nbw_lbb_64b.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_4rank_nbr.cfg b/ramulator_configs/1chan_4rank_nbr.cfg
-new file mode 100755
-index 0000000..b9ee327
---- /dev/null
-+++ b/ramulator_configs/1chan_4rank_nbr.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_4rank_nbr_nbw.cfg b/ramulator_configs/1chan_4rank_nbr_nbw.cfg
-new file mode 100755
-index 0000000..09fcde7
---- /dev/null
-+++ b/ramulator_configs/1chan_4rank_nbr_nbw.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2_modified
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_4rank_nbr_nbw_custom.cfg b/ramulator_configs/1chan_4rank_nbr_nbw_custom.cfg
-new file mode 100755
-index 0000000..6df8e62
---- /dev/null
-+++ b/ramulator_configs/1chan_4rank_nbr_nbw_custom.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2_custom
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_4rank_nbr_nbw_lbb.cfg b/ramulator_configs/1chan_4rank_nbr_nbw_lbb.cfg
-new file mode 100755
-index 0000000..5e6d43e
---- /dev/null
-+++ b/ramulator_configs/1chan_4rank_nbr_nbw_lbb.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 4
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/1chan_4rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/1chan_4rank_nbr_nbw_lbb_64b.cfg
-new file mode 100755
-index 0000000..1991af8
---- /dev/null
-+++ b/ramulator_configs/1chan_4rank_nbr_nbw_lbb_64b.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 4
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/2rank_nbr.cfg b/ramulator_configs/2rank_nbr.cfg
-new file mode 100755
-index 0000000..4fc615c
---- /dev/null
-+++ b/ramulator_configs/2rank_nbr.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/2rank_nbr_lbb.cfg b/ramulator_configs/2rank_nbr_lbb.cfg
-new file mode 100755
-index 0000000..9a34f27
---- /dev/null
-+++ b/ramulator_configs/2rank_nbr_lbb.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/2rank_nbr_lbb_sts_freq.cfg b/ramulator_configs/2rank_nbr_lbb_sts_freq.cfg
-new file mode 100755
-index 0000000..7d95484
---- /dev/null
-+++ b/ramulator_configs/2rank_nbr_lbb_sts_freq.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_2933R_ideal_nbr_lbb_sts
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/2rank_nbr_lbb_ts_freq.cfg b/ramulator_configs/2rank_nbr_lbb_ts_freq.cfg
-new file mode 100755
-index 0000000..e54badc
---- /dev/null
-+++ b/ramulator_configs/2rank_nbr_lbb_ts_freq.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_2933R_ideal_nbr_lbb_ts
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_2rank_nbr.cfg b/ramulator_configs/4chan_2rank_nbr.cfg
-new file mode 100755
-index 0000000..20ebf94
---- /dev/null
-+++ b/ramulator_configs/4chan_2rank_nbr.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_2rank_nbr_nbw.cfg b/ramulator_configs/4chan_2rank_nbr_nbw.cfg
-new file mode 100755
-index 0000000..d655991
---- /dev/null
-+++ b/ramulator_configs/4chan_2rank_nbr_nbw.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2_modified
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_2rank_nbr_nbw_custom.cfg b/ramulator_configs/4chan_2rank_nbr_nbw_custom.cfg
-new file mode 100755
-index 0000000..5d27259
---- /dev/null
-+++ b/ramulator_configs/4chan_2rank_nbr_nbw_custom.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2_custom
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_2rank_nbr_nbw_lbb.cfg b/ramulator_configs/4chan_2rank_nbr_nbw_lbb.cfg
-new file mode 100755
-index 0000000..39fb53f
---- /dev/null
-+++ b/ramulator_configs/4chan_2rank_nbr_nbw_lbb.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_2rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/4chan_2rank_nbr_nbw_lbb_64b.cfg
-new file mode 100755
-index 0000000..983656b
---- /dev/null
-+++ b/ramulator_configs/4chan_2rank_nbr_nbw_lbb_64b.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_4rank_nbr.cfg b/ramulator_configs/4chan_4rank_nbr.cfg
-new file mode 100755
-index 0000000..a1b6531
---- /dev/null
-+++ b/ramulator_configs/4chan_4rank_nbr.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_4rank_nbr_nbw.cfg b/ramulator_configs/4chan_4rank_nbr_nbw.cfg
-new file mode 100755
-index 0000000..f3ca698
---- /dev/null
-+++ b/ramulator_configs/4chan_4rank_nbr_nbw.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2_modified
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_4rank_nbr_nbw_custom.cfg b/ramulator_configs/4chan_4rank_nbr_nbw_custom.cfg
-new file mode 100755
-index 0000000..bedb845
---- /dev/null
-+++ b/ramulator_configs/4chan_4rank_nbr_nbw_custom.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2_custom
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_4rank_nbr_nbw_lbb.cfg b/ramulator_configs/4chan_4rank_nbr_nbw_lbb.cfg
-new file mode 100755
-index 0000000..12c7f37
---- /dev/null
-+++ b/ramulator_configs/4chan_4rank_nbr_nbw_lbb.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4chan_4rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/4chan_4rank_nbr_nbw_lbb_64b.cfg
-new file mode 100755
-index 0000000..9a61c42
---- /dev/null
-+++ b/ramulator_configs/4chan_4rank_nbr_nbw_lbb_64b.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4rank_nbr.cfg b/ramulator_configs/4rank_nbr.cfg
-new file mode 100755
-index 0000000..0a84b40
---- /dev/null
-+++ b/ramulator_configs/4rank_nbr.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/4rank_nbr_lbb.cfg b/ramulator_configs/4rank_nbr_lbb.cfg
-new file mode 100755
-index 0000000..b838203
---- /dev/null
-+++ b/ramulator_configs/4rank_nbr_lbb.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_nbr_lbb
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-2400-4CH2R-test.cfg b/ramulator_configs/DDR4-2400-4CH2R-test.cfg
-new file mode 100755
-index 0000000..483d8de
---- /dev/null
-+++ b/ramulator_configs/DDR4-2400-4CH2R-test.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_2400R
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-2400R-4CH2RANK-BASE.cfg b/ramulator_configs/DDR4-2400R-4CH2RANK-BASE.cfg
-new file mode 100755
-index 0000000..6344721
---- /dev/null
-+++ b/ramulator_configs/DDR4-2400R-4CH2RANK-BASE.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_2400R_base
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK-BASE.cfg b/ramulator_configs/DDR4-3200-1CH2RANK-BASE.cfg
-new file mode 100755
-index 0000000..281e34c
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK-BASE.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK.cfg b/ramulator_configs/DDR4-3200-1CH2RANK.cfg
-new file mode 100755
-index 0000000..8a84780
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base
-+ org = DDR4_4Gb_x8_w16
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W16.cfg
-new file mode 100755
-index 0000000..3f32ca0
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W16.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_full_w16
-+ org = DDR4_4Gb_x8_w16
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W32.cfg
-new file mode 100755
-index 0000000..ed9193f
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W32.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_full_w32
-+ org = DDR4_4Gb_x8_w32
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W64.cfg
-new file mode 100755
-index 0000000..7c30a68
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W64.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_full_w64
-+ org = DDR4_4Gb_x8_w64
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W8.cfg
-new file mode 100755
-index 0000000..75bdffe
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W8.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_full_w8
-+ org = DDR4_4Gb_x8_w8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W16.cfg
-new file mode 100755
-index 0000000..fcd63a8
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W16.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_half_w16
-+ org = DDR4_4Gb_x8_w16
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W32.cfg
-new file mode 100755
-index 0000000..69e1226
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W32.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_half_w32
-+ org = DDR4_4Gb_x8_w32
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W64.cfg
-new file mode 100755
-index 0000000..72de9ac
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W64.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_half_w64
-+ org = DDR4_4Gb_x8_w64
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W8.cfg
-new file mode 100755
-index 0000000..e7def41
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W8.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_half_w8
-+ org = DDR4_4Gb_x8_w8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W16.cfg
-new file mode 100755
-index 0000000..a09f06a
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W16.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_quarter_w16
-+ org = DDR4_4Gb_x8_w16
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W32.cfg
-new file mode 100755
-index 0000000..93f7f2a
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W32.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_quarter_w32
-+ org = DDR4_4Gb_x8_w32
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W64.cfg
-new file mode 100755
-index 0000000..950b5d1
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W64.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_quarter_w64
-+ org = DDR4_4Gb_x8_w64
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W8.cfg
-new file mode 100755
-index 0000000..97fa4dc
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W8.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_quarter_w8
-+ org = DDR4_4Gb_x8_w8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W16.cfg
-new file mode 100755
-index 0000000..a75ee78
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_W16.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_w16
-+ org = DDR4_4Gb_x8_w16
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W32.cfg
-new file mode 100755
-index 0000000..b783ba1
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_W32.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_w32
-+ org = DDR4_4Gb_x8_w32
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W64.cfg
-new file mode 100755
-index 0000000..0651072
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_W64.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_w64
-+ org = DDR4_4Gb_x8_w64
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W8.cfg
-new file mode 100755
-index 0000000..6e66051
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH2RANK_W8.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 2
-+ speed = DDR4_3200_base_w8
-+ org = DDR4_4Gb_x8_w8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-1CH4RANK-BASE.cfg b/ramulator_configs/DDR4-3200-1CH4RANK-BASE.cfg
-new file mode 100755
-index 0000000..77b61b8
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-1CH4RANK-BASE.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 4
-+ speed = DDR4_3200_base
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-BASE.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-BASE.cfg
-new file mode 100755
-index 0000000..34682f6
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-BASE.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_base
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv1.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv1.cfg
-new file mode 100755
-index 0000000..5d0717c
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv1.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v1
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2.cfg
-new file mode 100755
-index 0000000..4fc615c
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2_MODIFIED.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2_MODIFIED.cfg
-new file mode 100755
-index 0000000..e164696
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2_MODIFIED.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v2_modified
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv3.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv3.cfg
-new file mode 100755
-index 0000000..bd6f9b5
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv3.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v3
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4.cfg
-new file mode 100755
-index 0000000..4d25106
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v4
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4s.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4s.cfg
-new file mode 100755
-index 0000000..4dcac66
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4s.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v4s
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5.cfg
-new file mode 100755
-index 0000000..c3d436b
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v4
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5a.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5a.cfg
-new file mode 100755
-index 0000000..ca3a4dc
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5a.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v5a
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv6.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv6.cfg
-new file mode 100755
-index 0000000..f24bd61
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv6.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v4
-+ org = DDR4_4Gb_x8_2xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv7.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv7.cfg
-new file mode 100755
-index 0000000..f60729e
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv7.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3200_ideal_v7
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-BASE.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-BASE.cfg
-new file mode 100755
-index 0000000..7411735
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-BASE.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_base
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = on
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv1.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv1.cfg
-new file mode 100755
-index 0000000..2e1f303
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv1.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v1
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2.cfg
-new file mode 100755
-index 0000000..0a84b40
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2_MODIFIED.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2_MODIFIED.cfg
-new file mode 100755
-index 0000000..4982d90
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2_MODIFIED.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v2_modified
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv3.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv3.cfg
-new file mode 100755
-index 0000000..c21434b
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv3.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v3
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4.cfg
-new file mode 100755
-index 0000000..8026549
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v4
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4s.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4s.cfg
-new file mode 100755
-index 0000000..82bd768
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4s.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v4s
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5.cfg
-new file mode 100755
-index 0000000..71e8a4e
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v4
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5a.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5a.cfg
-new file mode 100755
-index 0000000..4210a74
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5a.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v5a
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv6.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv6.cfg
-new file mode 100755
-index 0000000..a299648
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv6.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v4
-+ org = DDR4_4Gb_x8_2xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv7.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv7.cfg
-new file mode 100755
-index 0000000..037b5b3
---- /dev/null
-+++ b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv7.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3200_ideal_v7
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3600-4CH2RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3600-4CH2RANK-IDEALv5.cfg
-new file mode 100755
-index 0000000..f0a940f
---- /dev/null
-+++ b/ramulator_configs/DDR4-3600-4CH2RANK-IDEALv5.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3600_ideal_v4
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3600-4CH4RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3600-4CH4RANK-IDEALv5.cfg
-new file mode 100755
-index 0000000..76970ed
---- /dev/null
-+++ b/ramulator_configs/DDR4-3600-4CH4RANK-IDEALv5.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3600_ideal_v4
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3866-4CH2RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3866-4CH2RANK-IDEALv5.cfg
-new file mode 100755
-index 0000000..ee838e9
---- /dev/null
-+++ b/ramulator_configs/DDR4-3866-4CH2RANK-IDEALv5.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 2
-+ speed = DDR4_3866_ideal_v4
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-3866-4CH4RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3866-4CH4RANK-IDEALv5.cfg
-new file mode 100755
-index 0000000..1fcadcb
---- /dev/null
-+++ b/ramulator_configs/DDR4-3866-4CH4RANK-IDEALv5.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 4
-+ ranks = 4
-+ speed = DDR4_3866_ideal_v4
-+ org = DDR4_4Gb_x8_4xBank
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/ramulator_configs/DDR4-config.cfg b/ramulator_configs/DDR4-config.cfg
-new file mode 100755
-index 0000000..e68e874
---- /dev/null
-+++ b/ramulator_configs/DDR4-config.cfg
-@@ -0,0 +1,30 @@
-+########################
-+# Example config file
-+# Comments start with #
-+# There are restrictions for valid channel/rank numbers
-+ standard = DDR4
-+ channels = 1
-+ ranks = 1
-+ speed = DDR4_2400R
-+ org = DDR4_4Gb_x8
-+# record_cmd_trace: (default is off): on, off
-+ record_cmd_trace = off
-+# print_cmd_trace: (default is off): on, off
-+ print_cmd_trace = off
-+
-+### Below are parameters only for CPU trace
-+ cpu_tick = 8
-+ mem_tick = 3
-+### Below are parameters only for multicore mode
-+# When early_exit is on, all cores will be terminated when the earliest one finishes.
-+ early_exit = on
-+# early_exit = on, off (default value is on)
-+# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
-+ expected_limit_insts = 200000000
-+ warmup_insts = 100000000
-+ cache = no
-+# cache = no, L1L2, L3, all (default value is no)
-+ translation = None
-+# translation = None, Random (default value is None)
-+#
-+########################
-diff --git a/src/mem/Ramulator.py b/src/mem/Ramulator.py
-new file mode 100644
-index 0000000..4981708
---- /dev/null
-+++ b/src/mem/Ramulator.py
-@@ -0,0 +1,18 @@
-+# -*- mode:python -*-
-+from m5.params import *
-+from AbstractMemory import *
-+
-+# A wrapper for Ramulator multi-channel memory controller
-+class Ramulator(AbstractMemory):
-+    type = 'Ramulator'
-+    cxx_header = "mem/ramulator.hh"
-+
-+    # A single port for now
-+    port = SlavePort("Slave port")
-+
-+    config_file = Param.String("", "configuration file")
-+    num_cpus = Param.Unsigned(1, "Number of cpu")
-+    
-+    # gagan
-+    real_warm_up = Param.UInt64(100, "specify the real warm up time")
-+    output_dir = Param.String("", "Ramulator trace output")
-diff --git a/src/mem/SConscript b/src/mem/SConscript
-index 2daa6bd..8c86854 100644
---- a/src/mem/SConscript
-+++ b/src/mem/SConscript
-@@ -92,6 +92,11 @@ if env['HAVE_DRAMSIM']:
-     Source('dramsim2_wrapper.cc')
-     Source('dramsim2.cc')
- 
-+if env['HAVE_RAMULATOR']:
-+    SimObject("Ramulator.py")
-+    Source('ramulator.cc')
-+    DebugFlag("Ramulator")
-+
- SimObject('MemChecker.py')
- Source('mem_checker.cc')
- Source('mem_checker_monitor.cc')
-diff --git a/src/mem/ramulator.cc b/src/mem/ramulator.cc
-new file mode 100644
-index 0000000..c16d0eb
---- /dev/null
-+++ b/src/mem/ramulator.cc
-@@ -0,0 +1,281 @@
-+#include "base/callback.hh"
-+#include "mem/ramulator.hh"
-+#include "Ramulator/src/Gem5Wrapper.h"
-+#include "Ramulator/src/Request.h"
-+#include "sim/system.hh"
-+#include "debug/Ramulator.hh"
-+
-+// daz3
-+ramulator::Gem5Wrapper* wrapper1 = NULL;
-+bool del_wrapper = false;
-+Tick begin_tick = 0;
-+Tick print_interval = 200000000;//0.2ms
-+unsigned long my_read_cnt = 0;
-+unsigned long my_write_cnt = 0;
-+unsigned long my_total_cnt = 0;
-+
-+Ramulator::Ramulator(const Params *p):
-+    AbstractMemory(p),
-+    port(name() + ".port", *this),
-+    requestsInFlight(0),
-+    drain_manager(NULL),
-+    config_file(p->config_file),
-+    configs(p->config_file),
-+    wrapper(NULL),
-+    read_cb_func(std::bind(&Ramulator::readComplete, this, std::placeholders::_1)),
-+    write_cb_func(std::bind(&Ramulator::writeComplete, this, std::placeholders::_1)),
-+    ticks_per_clk(0),
-+    resp_stall(false),
-+    req_stall(false),
-+    send_resp_event(this),
-+    tick_event(this) 
-+{
-+  warmuptime = p->real_warm_up;
-+
-+  configs.set_core_num(p->num_cpus);
-+  configs.set_tracefile_directory(p->output_dir);
-+}
-+Ramulator::~Ramulator()
-+{
-+    // delete wrapper;
-+    // daz3
-+    if(del_wrapper == false)
-+    {
-+        delete wrapper;
-+        del_wrapper = true;
-+    }
-+}
-+
-+void Ramulator::init() {
-+    if (!port.isConnected()){ 
-+        fatal("Ramulator port not connected\n");
-+    } else { 
-+        port.sendRangeChange(); 
-+    }
-+
-+    if (wrapper1 != NULL)
-+    {
-+        wrapper = wrapper1;
-+    }
-+    else
-+    {
-+        wrapper = new ramulator::Gem5Wrapper(configs, system()->cacheLineSize());
-+        wrapper1 = wrapper;
-+    }
-+    // daz3
-+    // wrapper = new ramulator::Gem5Wrapper(configs, system()->cacheLineSize());
-+    ticks_per_clk = Tick(wrapper->tCK * SimClock::Float::ns);
-+
-+    DPRINTF(Ramulator, "Instantiated Ramulator with config file '%s' (tCK=%lf, %d ticks per clk)\n", 
-+        config_file.c_str(), wrapper->tCK, ticks_per_clk);
-+    Callback* cb = new MakeCallback<ramulator::Gem5Wrapper, &ramulator::Gem5Wrapper::finish>(wrapper);
-+    registerExitCallback(cb);
-+}
-+
-+void Ramulator::startup() {
-+    schedule(tick_event, clockEdge());
-+}
-+
-+unsigned int Ramulator::drain(DrainManager* dm) {
-+    // DPRINTF(Ramulator, "Requested to drain\n");
-+    // // updated to include all in-flight requests
-+    // // if (resp_queue.size()) {
-+    // if (numOutstanding()) {
-+    //     setDrainState(Drainable::Draining);
-+    //     drain_manager = dm;
-+    //     return 1;
-+    // } else {
-+    //     setDrainState(Drainable::Drained);
-+    //     return 0;
-+    // }
-+    return 0;
-+}
-+
-+Port& Ramulator::getPort(const std::string& if_name, PortID idx) {
-+    if (if_name != "port") {
-+        return AbstractMemory::getPort(if_name, idx);
-+    } else {
-+        return port;
-+    }
-+}
-+
-+void Ramulator::sendResponse() {
-+    assert(!resp_stall);
-+    assert(!resp_queue.empty());
-+
-+    DPRINTF(Ramulator, "Attempting to send response\n");
-+
-+    long addr = resp_queue.front()->getAddr();
-+    if(addr){/*DO NOTHING. For avoid error unused-variable*/}
-+    if (port.sendTimingResp(resp_queue.front())){
-+        DPRINTF(Ramulator, "Response to %ld sent.\n", addr);
-+        resp_queue.pop_front();
-+        if (resp_queue.size() && !send_resp_event.scheduled())
-+            schedule(send_resp_event, curTick());
-+
-+        // check if we were asked to drain and if we are now done
-+        if (drain_manager && numOutstanding() == 0) {
-+            drain_manager->signalDrainDone();
-+            drain_manager = NULL;
-+        }
-+    } else 
-+        resp_stall = true;
-+}
-+    
-+void Ramulator::tick() {
-+    wrapper->tick();
-+    if (req_stall){
-+        req_stall = false;
-+        port.sendRetryReq();
-+    }
-+    //AbstractMemory::occupancyL3Cache = L3->occupancy();
-+    schedule(tick_event, curTick() + ticks_per_clk);
-+}
-+
-+// added an atomic packet response function to enable fast forwarding
-+Tick Ramulator::recvAtomic(PacketPtr pkt) {
-+    access(pkt);
-+    //L3->call(pkt->getAddr());
-+    // set an fixed arbitrary 50ns response time for atomic requests
-+    return pkt->cacheResponding() ? 0 : 50000;
-+}
-+
-+void Ramulator::recvFunctional(PacketPtr pkt) {
-+    pkt->pushLabel(name());
-+    functionalAccess(pkt);
-+    for (auto i = resp_queue.begin(); i != resp_queue.end(); ++i)
-+        pkt->trySatisfyFunctional(*i);
-+    pkt->popLabel();
-+}
-+
-+bool Ramulator::recvTimingReq(PacketPtr pkt) {
-+    // we should never see a new request while in retry
-+    assert(!req_stall);
-+
-+    for (PacketPtr pendPkt: pending_del)
-+        delete pendPkt;
-+    pending_del.clear();
-+
-+    // daz3
-+    if (begin_tick == 0) {
-+        begin_tick = curTick();
-+    }
-+
-+    if (pkt->cacheResponding()) {
-+        // snooper will supply based on copy of packet
-+        // still target's responsibility to delete packet
-+        pending_del.push_back(pkt);
-+        return true;
-+    }
-+
-+    // daz3
-+    if (curTick()<=(begin_tick + warmuptime))
-+      {
-+        my_total_cnt++;
-+        accessAndRespond(pkt);
-+        return true;
-+      }
-+    
-+    bool accepted = true;
-+    if (pkt->isRead()) {
-+      //DPRINTF(Ramulator, "context id: %d, thread id: %d\n", pkt->req->contextId(),
-+      //    pkt->req->threadId());
-+      ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::READ, read_cb_func, pkt->req->isPrefetch(), 0);
-+        //daz3
-+        // ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::READ, read_cb_func, 0);
-+        accepted = wrapper->send(req);
-+        if (accepted){
-+            reads[req.addr].push_back(pkt);
-+            DPRINTF(Ramulator, "Read to %ld accepted.\n", req.addr);
-+
-+            // added counter to track requests in flight
-+            ++requestsInFlight;
-+            // daz3
-+            my_read_cnt++;
-+            my_total_cnt++;
-+        } else {
-+            req_stall = true;
-+        }
-+    } else if (pkt->isWrite()) {
-+        // Detailed CPU model always comes along with cache model enabled and
-+        // write requests are caused by cache eviction, so it shouldn't be
-+        // tallied for any core/thread
-+        ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::WRITE, write_cb_func, false, 0);
-+        accepted = wrapper->send(req);
-+        if (accepted){
-+            accessAndRespond(pkt);
-+            DPRINTF(Ramulator, "Write to %ld accepted and served.\n", req.addr);
-+
-+            // added counter to track requests in flight
-+            ++requestsInFlight;
-+            // daz3
-+            my_write_cnt++;
-+            my_total_cnt++;
-+        } else {
-+            req_stall = true;
-+        }
-+    } else {
-+        // keep it simple and just respond if necessary
-+        accessAndRespond(pkt);
-+        // daz3
-+        my_total_cnt++;
-+    }
-+    return accepted;
-+}
-+
-+void Ramulator::recvRespRetry() {
-+    DPRINTF(Ramulator, "Retrying\n");
-+
-+    assert(resp_stall);
-+    resp_stall = false;
-+    sendResponse();
-+}
-+
-+void Ramulator::accessAndRespond(PacketPtr pkt) {
-+    bool need_resp = pkt->needsResponse();
-+    access(pkt);
-+    if (need_resp) {
-+        assert(pkt->isResponse());
-+        pkt->headerDelay = pkt->payloadDelay = 0;
-+
-+        DPRINTF(Ramulator, "Queuing response for address %lld\n",
-+                pkt->getAddr());
-+
-+        resp_queue.push_back(pkt);
-+	// gagan : added 18 ns latency for the L3 cache
-+        if (!resp_stall && !send_resp_event.scheduled())
-+            schedule(send_resp_event, curTick());
-+    } else 
-+        pending_del.push_back(pkt);
-+}
-+
-+void Ramulator::readComplete(ramulator::Request& req){
-+    DPRINTF(Ramulator, "Read to %ld completed.\n", req.addr);
-+    auto& pkt_q = reads.find(req.addr)->second;
-+    PacketPtr pkt = pkt_q.front();
-+    pkt_q.pop_front();
-+    if (!pkt_q.size())
-+        reads.erase(req.addr);
-+
-+    // added counter to track requests in flight
-+    --requestsInFlight;
-+
-+    accessAndRespond(pkt);
-+}
-+
-+void Ramulator::writeComplete(ramulator::Request& req){
-+    DPRINTF(Ramulator, "Write to %ld completed.\n", req.addr);
-+
-+    // added counter to track requests in flight
-+    --requestsInFlight;
-+
-+    // check if we were asked to drain and if we are now done
-+    if (drain_manager && numOutstanding() == 0) {
-+        drain_manager->signalDrainDone();
-+        drain_manager = NULL;
-+    }
-+}
-+
-+Ramulator *RamulatorParams::create(){
-+    return new Ramulator(this);
-+}
-diff --git a/src/mem/ramulator.hh b/src/mem/ramulator.hh
-new file mode 100644
-index 0000000..1a3529b
---- /dev/null
-+++ b/src/mem/ramulator.hh
-@@ -0,0 +1,97 @@
-+#ifndef __RAMULATOR_HH__
-+#define __RAMULATOR_HH__
-+
-+#include <deque>
-+#include <tuple>
-+#include <map>
-+
-+#include "mem/abstract_mem.hh"
-+#include "params/Ramulator.hh"
-+#include "Ramulator/src/Config.h"
-+
-+namespace ramulator{
-+    class Request;
-+    class Gem5Wrapper;
-+}
-+
-+class Ramulator : public AbstractMemory {
-+private:
-+
-+    class MemoryPort: public SlavePort {
-+    private:
-+        Ramulator& mem;
-+    public:
-+        MemoryPort(const std::string& _name, Ramulator& _mem): SlavePort(_name, &_mem), mem(_mem) {}
-+    protected:
-+        Tick recvAtomic(PacketPtr pkt) {
-+            // modified to perform a fixed latency return for atomic packets to enable fast forwarding
-+            // assert(false && "only accepts functional or timing packets");
-+            return mem.recvAtomic(pkt);
-+        }
-+        
-+        void recvFunctional(PacketPtr pkt) {
-+            mem.recvFunctional(pkt);
-+        }
-+
-+        bool recvTimingReq(PacketPtr pkt) {
-+            return mem.recvTimingReq(pkt);
-+        }
-+
-+        void recvRespRetry() {
-+            mem.recvRespRetry();
-+        }
-+
-+        AddrRangeList getAddrRanges() const {
-+            AddrRangeList ranges;
-+            ranges.push_back(mem.getAddrRange());
-+            return ranges;
-+        }
-+    } port;
-+
-+    unsigned int requestsInFlight;
-+    std::map<long, std::deque<PacketPtr> > reads;
-+    std::map<long, std::deque<PacketPtr> > writes;
-+    std::deque<PacketPtr> resp_queue;
-+    std::deque<PacketPtr> pending_del;
-+    DrainManager *drain_manager;
-+
-+    std::string config_file;
-+    ramulator::Config configs;
-+    ramulator::Gem5Wrapper *wrapper;
-+    std::function<void(ramulator::Request&)> read_cb_func;
-+    std::function<void(ramulator::Request&)> write_cb_func;
-+    Tick ticks_per_clk;
-+    bool resp_stall;
-+    bool req_stall;
-+    // gagan :
-+    Tick warmuptime;
-+
-+    unsigned int numOutstanding() const { return requestsInFlight + resp_queue.size(); }
-+    
-+    void sendResponse();
-+    void tick();
-+    
-+    EventWrapper<Ramulator, &Ramulator::sendResponse> send_resp_event;
-+    EventWrapper<Ramulator, &Ramulator::tick> tick_event;
-+
-+public:
-+    typedef RamulatorParams Params;
-+    Ramulator(const Params *p);
-+    virtual void init();
-+    virtual void startup();
-+    unsigned int drain(DrainManager* dm);
-+    virtual Port& getPort(const std::string& if_name, 
-+        PortID idx = InvalidPortID);
-+    ~Ramulator();
-+
-+protected:
-+    Tick recvAtomic(PacketPtr pkt);
-+    void recvFunctional(PacketPtr pkt);
-+    bool recvTimingReq(PacketPtr pkt);
-+    void recvRespRetry();
-+    void accessAndRespond(PacketPtr pkt);
-+    void readComplete(ramulator::Request& req);
-+    void writeComplete(ramulator::Request& req);
-+};
-+
-+#endif // __RAMULATOR_HH__
-diff --git a/src/python/m5/params.py b/src/python/m5/params.py
-index 9b4198b..1ba3289 100644
---- a/src/python/m5/params.py
-+++ b/src/python/m5/params.py
-@@ -225,7 +225,7 @@ class ParamDesc(object):
-         return self.ptype(value).pretty_print(value)
- 
-     def cxx_predecls(self, code):
--        code('#include <cstddef>')
-+        code('#include <stddef.h>')
-         self.ptype.cxx_predecls(code)
- 
-     def pybind_predecls(self, code):
diff --git a/m5out_default_DDR4/config.dot b/m5out_default_DDR4/config.dot
deleted file mode 100644
index e3f997f0c..000000000
--- a/m5out_default_DDR4/config.dot
+++ /dev/null
@@ -1,2147 +0,0 @@
-digraph G {
-ranksep="1.3";
-subgraph cluster_root {
-shape=Mrecord;
-label="root \n: Root";
-tooltip="eventq_index&#61;0&#10;\full_system&#61;false&#10;\sim_quantum&#61;0&#10;\time_sync_enable&#61;false&#10;\time_sync_period&#61;100000000000&#10;\time_sync_spin_threshold&#61;100000000";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system {
-shape=Mrecord;
-label="system \n: System";
-tooltip="byte_order&#61;little&#10;\cache_line_size&#61;64&#10;\eventq_index&#61;0&#10;\exit_on_work_items&#61;false&#10;\init_param&#61;0&#10;\kvm_vm&#61;Null&#10;\m5ops_base&#61;4294901760&#10;\mem_mode&#61;timing&#10;\mem_ranges&#61;0:1073741824&#10;\memories&#61;system.mem_ctrls&#10;\mmap_using_noreserve&#61;false&#10;\multi_thread&#61;false&#10;\num_work_ids&#61;16&#10;\readfile&#61;&#10;\redirect_paths&#61;system.redirect_paths0 system.redirect_paths1 system.redirect_paths2&#10;\shared_backstore&#61;&#10;\symbolfile&#61;&#10;\thermal_components&#61;&#10;\thermal_model&#61;Null&#10;\work_begin_ckpt_count&#61;0&#10;\work_begin_cpu_id_exit&#61;-1&#10;\work_begin_exit_count&#61;0&#10;\work_cpus_ckpt_count&#61;0&#10;\work_end_ckpt_count&#61;0&#10;\work_end_exit_count&#61;0&#10;\work_item_id&#61;-1&#10;\workload&#61;Null";
-style="rounded, filled";
-color="#000000";
-fillcolor="#e4e7eb";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_system_port [shape=Mrecord, label=system_port, style="rounded, filled", color="#000000", fillcolor="#b6b8bc", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_dvfs_handler {
-shape=Mrecord;
-label="dvfs_handler \n: DVFSHandler";
-tooltip="domains&#61;&#10;\enable&#61;false&#10;\eventq_index&#61;0&#10;\sys_clk_domain&#61;system.clk_domain&#10;\transition_latency&#61;100000000";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0 {
-shape=Mrecord;
-label="cpu0 \n: TimingSimpleCPU";
-tooltip="branchPred&#61;Null&#10;\checker&#61;Null&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\cpu_id&#61;0&#10;\do_checkpoint_insts&#61;true&#10;\do_statistics_insts&#61;true&#10;\dtb&#61;system.cpu0.dtb&#10;\eventq_index&#61;0&#10;\function_trace&#61;false&#10;\function_trace_start&#61;0&#10;\interrupts&#61;system.cpu0.interrupts&#10;\isa&#61;system.cpu0.isa&#10;\itb&#61;system.cpu0.itb&#10;\max_insts_all_threads&#61;0&#10;\max_insts_any_thread&#61;0&#10;\numThreads&#61;1&#10;\power_gating_on_idle&#61;false&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.power_state&#10;\progress_interval&#61;0&#10;\pwr_gating_latency&#61;300&#10;\simpoint_start_insts&#61;&#10;\socket_id&#61;0&#10;\switched_out&#61;false&#10;\syscallRetryLatency&#61;10000&#10;\system&#61;system&#10;\tracer&#61;system.cpu0.tracer&#10;\wait_for_remote_gdb&#61;false&#10;\workload&#61;system.cpu0.workload";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bbc6d9";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_icache_port [shape=Mrecord, label=icache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu0_dcache_port [shape=Mrecord, label=dcache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_dtb {
-shape=Mrecord;
-label="dtb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu0.dtb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu0_dtb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.dtb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_dtb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_dtb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu0_itb {
-shape=Mrecord;
-label="itb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu0.itb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu0_itb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.itb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_itb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_itb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu0_tracer {
-shape=Mrecord;
-label="tracer \n: ExeTracer";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;ON CLK_GATED OFF";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_workload {
-shape=Mrecord;
-label="workload \n: Process";
-tooltip="cmd&#61;main.out&#10;\cwd&#61;/usr/local/src/gem5_v20.1&#10;\drivers&#61;&#10;\egid&#61;100&#10;\env&#61;&#10;\errout&#61;cerr&#10;\euid&#61;100&#10;\eventq_index&#61;0&#10;\executable&#61;main.out&#10;\gid&#61;100&#10;\input&#61;cin&#10;\kvmInSE&#61;false&#10;\maxStackSize&#61;67108864&#10;\output&#61;cout&#10;\pgid&#61;100&#10;\pid&#61;100&#10;\ppid&#61;0&#10;\release&#61;5.1.0&#10;\simpoint&#61;0&#10;\system&#61;system&#10;\uid&#61;100&#10;\useArchPT&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_isa {
-shape=Mrecord;
-label="isa \n: X86ISA";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_icache {
-shape=Mrecord;
-label="icache \n: L1_ICache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;true&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.icache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu0.icache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu0.icache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;true";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_icache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu0_icache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_icache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu0.icache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.icache.tags.power_state&#10;\replacement_policy&#61;system.cpu0.icache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu0_icache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;32768";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_icache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_icache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_icache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_dcache {
-shape=Mrecord;
-label="dcache \n: L1_DCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.dcache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu0.dcache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu0.dcache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_dcache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu0_dcache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_dcache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu0.dcache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.dcache.tags.power_state&#10;\replacement_policy&#61;system.cpu0.dcache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu0_dcache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;65536";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_dcache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_dcache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_dcache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_itb_walker_cache {
-shape=Mrecord;
-label="itb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.itb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu0.itb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu0.itb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_itb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu0_itb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_itb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu0.itb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.itb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu0.itb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu0_itb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_itb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_itb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_itb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_dtb_walker_cache {
-shape=Mrecord;
-label="dtb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.dtb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu0.dtb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu0.dtb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_dtb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu0_dtb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_dtb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu0.dtb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu0.dtb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu0.dtb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu0_dtb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_dtb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_dtb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu0_dtb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu0_interrupts {
-shape=Mrecord;
-label="interrupts \n: X86LocalApic";
-tooltip="clk_domain&#61;system.cpu0.interrupts.clk_domain&#10;\eventq_index&#61;0&#10;\int_latency&#61;1000&#10;\pio_latency&#61;100000&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu0_interrupts_int_requestor [shape=Mrecord, label=int_requestor, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu0_interrupts_int_responder [shape=Mrecord, label=int_responder, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu0_interrupts_pio [shape=Mrecord, label=pio, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu0_interrupts_clk_domain {
-shape=Mrecord;
-label="clk_domain \n: DerivedClockDomain";
-tooltip="clk_divider&#61;16&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu1 {
-shape=Mrecord;
-label="cpu1 \n: TimingSimpleCPU";
-tooltip="branchPred&#61;Null&#10;\checker&#61;Null&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\cpu_id&#61;1&#10;\do_checkpoint_insts&#61;true&#10;\do_statistics_insts&#61;true&#10;\dtb&#61;system.cpu1.dtb&#10;\eventq_index&#61;0&#10;\function_trace&#61;false&#10;\function_trace_start&#61;0&#10;\interrupts&#61;system.cpu1.interrupts&#10;\isa&#61;system.cpu1.isa&#10;\itb&#61;system.cpu1.itb&#10;\max_insts_all_threads&#61;0&#10;\max_insts_any_thread&#61;0&#10;\numThreads&#61;1&#10;\power_gating_on_idle&#61;false&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.power_state&#10;\progress_interval&#61;0&#10;\pwr_gating_latency&#61;300&#10;\simpoint_start_insts&#61;&#10;\socket_id&#61;0&#10;\switched_out&#61;false&#10;\syscallRetryLatency&#61;10000&#10;\system&#61;system&#10;\tracer&#61;system.cpu1.tracer&#10;\wait_for_remote_gdb&#61;false&#10;\workload&#61;system.cpu0.workload";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bbc6d9";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_icache_port [shape=Mrecord, label=icache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu1_dcache_port [shape=Mrecord, label=dcache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_dtb {
-shape=Mrecord;
-label="dtb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu1.dtb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu1_dtb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.dtb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_dtb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_dtb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu1_itb {
-shape=Mrecord;
-label="itb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu1.itb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu1_itb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.itb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_itb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_itb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu1_tracer {
-shape=Mrecord;
-label="tracer \n: ExeTracer";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;ON CLK_GATED OFF";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_isa {
-shape=Mrecord;
-label="isa \n: X86ISA";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_icache {
-shape=Mrecord;
-label="icache \n: L1_ICache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;true&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.icache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu1.icache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu1.icache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;true";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_icache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu1_icache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_icache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu1.icache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.icache.tags.power_state&#10;\replacement_policy&#61;system.cpu1.icache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu1_icache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;32768";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_icache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_icache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_icache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_dcache {
-shape=Mrecord;
-label="dcache \n: L1_DCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.dcache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu1.dcache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu1.dcache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_dcache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu1_dcache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_dcache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu1.dcache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.dcache.tags.power_state&#10;\replacement_policy&#61;system.cpu1.dcache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu1_dcache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;65536";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_dcache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_dcache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_dcache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_itb_walker_cache {
-shape=Mrecord;
-label="itb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.itb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu1.itb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu1.itb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_itb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu1_itb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_itb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu1.itb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.itb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu1.itb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu1_itb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_itb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_itb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_itb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_dtb_walker_cache {
-shape=Mrecord;
-label="dtb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.dtb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu1.dtb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu1.dtb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_dtb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu1_dtb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_dtb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu1.dtb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu1.dtb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu1.dtb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu1_dtb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_dtb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_dtb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu1_dtb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu1_interrupts {
-shape=Mrecord;
-label="interrupts \n: X86LocalApic";
-tooltip="clk_domain&#61;system.cpu1.interrupts.clk_domain&#10;\eventq_index&#61;0&#10;\int_latency&#61;1000&#10;\pio_latency&#61;100000&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu1_interrupts_int_requestor [shape=Mrecord, label=int_requestor, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu1_interrupts_int_responder [shape=Mrecord, label=int_responder, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu1_interrupts_pio [shape=Mrecord, label=pio, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu1_interrupts_clk_domain {
-shape=Mrecord;
-label="clk_domain \n: DerivedClockDomain";
-tooltip="clk_divider&#61;16&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu2 {
-shape=Mrecord;
-label="cpu2 \n: TimingSimpleCPU";
-tooltip="branchPred&#61;Null&#10;\checker&#61;Null&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\cpu_id&#61;2&#10;\do_checkpoint_insts&#61;true&#10;\do_statistics_insts&#61;true&#10;\dtb&#61;system.cpu2.dtb&#10;\eventq_index&#61;0&#10;\function_trace&#61;false&#10;\function_trace_start&#61;0&#10;\interrupts&#61;system.cpu2.interrupts&#10;\isa&#61;system.cpu2.isa&#10;\itb&#61;system.cpu2.itb&#10;\max_insts_all_threads&#61;0&#10;\max_insts_any_thread&#61;0&#10;\numThreads&#61;1&#10;\power_gating_on_idle&#61;false&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.power_state&#10;\progress_interval&#61;0&#10;\pwr_gating_latency&#61;300&#10;\simpoint_start_insts&#61;&#10;\socket_id&#61;0&#10;\switched_out&#61;false&#10;\syscallRetryLatency&#61;10000&#10;\system&#61;system&#10;\tracer&#61;system.cpu2.tracer&#10;\wait_for_remote_gdb&#61;false&#10;\workload&#61;system.cpu0.workload";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bbc6d9";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_icache_port [shape=Mrecord, label=icache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu2_dcache_port [shape=Mrecord, label=dcache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_dtb {
-shape=Mrecord;
-label="dtb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu2.dtb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu2_dtb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.dtb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_dtb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_dtb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu2_itb {
-shape=Mrecord;
-label="itb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu2.itb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu2_itb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.itb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_itb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_itb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu2_tracer {
-shape=Mrecord;
-label="tracer \n: ExeTracer";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;ON CLK_GATED OFF";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_isa {
-shape=Mrecord;
-label="isa \n: X86ISA";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_icache {
-shape=Mrecord;
-label="icache \n: L1_ICache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;true&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.icache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu2.icache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu2.icache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;true";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_icache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu2_icache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_icache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu2.icache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.icache.tags.power_state&#10;\replacement_policy&#61;system.cpu2.icache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu2_icache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;32768";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_icache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_icache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_icache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_dcache {
-shape=Mrecord;
-label="dcache \n: L1_DCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.dcache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu2.dcache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu2.dcache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_dcache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu2_dcache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_dcache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu2.dcache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.dcache.tags.power_state&#10;\replacement_policy&#61;system.cpu2.dcache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu2_dcache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;65536";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_dcache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_dcache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_dcache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_itb_walker_cache {
-shape=Mrecord;
-label="itb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.itb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu2.itb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu2.itb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_itb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu2_itb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_itb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu2.itb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.itb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu2.itb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu2_itb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_itb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_itb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_itb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_dtb_walker_cache {
-shape=Mrecord;
-label="dtb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.dtb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu2.dtb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu2.dtb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_dtb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu2_dtb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_dtb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu2.dtb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu2.dtb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu2.dtb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu2_dtb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_dtb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_dtb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu2_dtb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu2_interrupts {
-shape=Mrecord;
-label="interrupts \n: X86LocalApic";
-tooltip="clk_domain&#61;system.cpu2.interrupts.clk_domain&#10;\eventq_index&#61;0&#10;\int_latency&#61;1000&#10;\pio_latency&#61;100000&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu2_interrupts_int_requestor [shape=Mrecord, label=int_requestor, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu2_interrupts_int_responder [shape=Mrecord, label=int_responder, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu2_interrupts_pio [shape=Mrecord, label=pio, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu2_interrupts_clk_domain {
-shape=Mrecord;
-label="clk_domain \n: DerivedClockDomain";
-tooltip="clk_divider&#61;16&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu3 {
-shape=Mrecord;
-label="cpu3 \n: TimingSimpleCPU";
-tooltip="branchPred&#61;Null&#10;\checker&#61;Null&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\cpu_id&#61;3&#10;\do_checkpoint_insts&#61;true&#10;\do_statistics_insts&#61;true&#10;\dtb&#61;system.cpu3.dtb&#10;\eventq_index&#61;0&#10;\function_trace&#61;false&#10;\function_trace_start&#61;0&#10;\interrupts&#61;system.cpu3.interrupts&#10;\isa&#61;system.cpu3.isa&#10;\itb&#61;system.cpu3.itb&#10;\max_insts_all_threads&#61;0&#10;\max_insts_any_thread&#61;0&#10;\numThreads&#61;1&#10;\power_gating_on_idle&#61;false&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.power_state&#10;\progress_interval&#61;0&#10;\pwr_gating_latency&#61;300&#10;\simpoint_start_insts&#61;&#10;\socket_id&#61;0&#10;\switched_out&#61;false&#10;\syscallRetryLatency&#61;10000&#10;\system&#61;system&#10;\tracer&#61;system.cpu3.tracer&#10;\wait_for_remote_gdb&#61;false&#10;\workload&#61;system.cpu0.workload";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bbc6d9";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_icache_port [shape=Mrecord, label=icache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu3_dcache_port [shape=Mrecord, label=dcache_port, style="rounded, filled", color="#000000", fillcolor="#959ead", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_dtb {
-shape=Mrecord;
-label="dtb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu3.dtb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu3_dtb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.dtb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_dtb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_dtb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu3_itb {
-shape=Mrecord;
-label="itb \n: X86TLB";
-tooltip="eventq_index&#61;0&#10;\size&#61;64&#10;\system&#61;system&#10;\walker&#61;system.cpu3.itb.walker";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu3_itb_walker {
-shape=Mrecord;
-label="walker \n: X86PagetableWalker";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\num_squash_per_cycle&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.itb.walker.power_state&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_itb_walker_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#7f7c77", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_itb_walker_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_cpu3_tracer {
-shape=Mrecord;
-label="tracer \n: ExeTracer";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;ON CLK_GATED OFF";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_isa {
-shape=Mrecord;
-label="isa \n: X86ISA";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_icache {
-shape=Mrecord;
-label="icache \n: L1_ICache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;true&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.icache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu3.icache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu3.icache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;true";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_icache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu3_icache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_icache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu3.icache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.icache.tags.power_state&#10;\replacement_policy&#61;system.cpu3.icache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;32768&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu3_icache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;32768";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_icache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_icache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_icache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_dcache {
-shape=Mrecord;
-label="dcache \n: L1_DCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;4&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.dcache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu3.dcache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu3.dcache.tags&#10;\tgts_per_mshr&#61;20&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_dcache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu3_dcache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_dcache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu3.dcache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.dcache.tags.power_state&#10;\replacement_policy&#61;system.cpu3.dcache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;65536&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu3_dcache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;65536";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_dcache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_dcache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_dcache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_itb_walker_cache {
-shape=Mrecord;
-label="itb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.itb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu3.itb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu3.itb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_itb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu3_itb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_itb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu3.itb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.itb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu3.itb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu3_itb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_itb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_itb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_itb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_dtb_walker_cache {
-shape=Mrecord;
-label="dtb_walker_cache \n: PageTableWalkerCache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;2&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;2&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;10&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.dtb_walker_cache.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.cpu3.dtb_walker_cache.replacement_policy&#10;\response_latency&#61;2&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\tags&#61;system.cpu3.dtb_walker_cache.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_dtb_walker_cache_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu3_dtb_walker_cache_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_dtb_walker_cache_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;2&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.cpu3.dtb_walker_cache.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.cpu3.dtb_walker_cache.tags.power_state&#10;\replacement_policy&#61;system.cpu3.dtb_walker_cache.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;1024&#10;\system&#61;system&#10;\tag_latency&#61;2&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_cpu3_dtb_walker_cache_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;2&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;1024";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_dtb_walker_cache_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_dtb_walker_cache_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu3_dtb_walker_cache_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_cpu3_interrupts {
-shape=Mrecord;
-label="interrupts \n: X86LocalApic";
-tooltip="clk_domain&#61;system.cpu3.interrupts.clk_domain&#10;\eventq_index&#61;0&#10;\int_latency&#61;1000&#10;\pio_latency&#61;100000&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_cpu3_interrupts_int_requestor [shape=Mrecord, label=int_requestor, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu3_interrupts_int_responder [shape=Mrecord, label=int_responder, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_cpu3_interrupts_pio [shape=Mrecord, label=pio, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_cpu3_interrupts_clk_domain {
-shape=Mrecord;
-label="clk_domain \n: DerivedClockDomain";
-tooltip="clk_divider&#61;16&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-subgraph cluster_system_voltage_domain {
-shape=Mrecord;
-label="voltage_domain \n: VoltageDomain";
-tooltip="eventq_index&#61;0&#10;\voltage&#61;1.0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_clk_domain {
-shape=Mrecord;
-label="clk_domain \n: SrcClockDomain";
-tooltip="clock&#61;1000&#10;\domain_id&#61;-1&#10;\eventq_index&#61;0&#10;\init_perf_level&#61;0&#10;\voltage_domain&#61;system.voltage_domain";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu_voltage_domain {
-shape=Mrecord;
-label="cpu_voltage_domain \n: VoltageDomain";
-tooltip="eventq_index&#61;0&#10;\voltage&#61;1.0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_cpu_clk_domain {
-shape=Mrecord;
-label="cpu_clk_domain \n: SrcClockDomain";
-tooltip="clock&#61;500&#10;\domain_id&#61;-1&#10;\eventq_index&#61;0&#10;\init_perf_level&#61;0&#10;\voltage_domain&#61;system.cpu_voltage_domain";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_membus {
-shape=Mrecord;
-label="membus \n: SystemXBar";
-tooltip="clk_domain&#61;system.clk_domain&#10;\eventq_index&#61;0&#10;\forward_latency&#61;4&#10;\frontend_latency&#61;3&#10;\header_latency&#61;1&#10;\max_outstanding_snoops&#61;512&#10;\max_routing_table_size&#61;512&#10;\point_of_coherency&#61;true&#10;\point_of_unification&#61;true&#10;\power_model&#61;&#10;\power_state&#61;system.membus.power_state&#10;\response_latency&#61;2&#10;\snoop_filter&#61;system.membus.snoop_filter&#10;\snoop_response_latency&#61;4&#10;\system&#61;system&#10;\use_default_range&#61;false&#10;\width&#61;16";
-style="rounded, filled";
-color="#000000";
-fillcolor="#6f798c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_membus_cpu_side_ports [shape=Mrecord, label=cpu_side_ports, style="rounded, filled", color="#000000", fillcolor="#586070", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_membus_mem_side_ports [shape=Mrecord, label=mem_side_ports, style="rounded, filled", color="#000000", fillcolor="#586070", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_membus_snoop_filter {
-shape=Mrecord;
-label="snoop_filter \n: SnoopFilter";
-tooltip="eventq_index&#61;0&#10;\lookup_latency&#61;1&#10;\max_capacity&#61;8388608&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_membus_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_l2 {
-shape=Mrecord;
-label="l2 \n: L2Cache";
-tooltip="addr_ranges&#61;0:18446744073709551615&#10;\assoc&#61;8&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\clusivity&#61;mostly_incl&#10;\compressor&#61;Null&#10;\data_latency&#61;20&#10;\demand_mshr_reserve&#61;1&#10;\eventq_index&#61;0&#10;\is_read_only&#61;false&#10;\max_miss_count&#61;0&#10;\mshrs&#61;20&#10;\power_model&#61;&#10;\power_state&#61;system.l2.power_state&#10;\prefetch_on_access&#61;false&#10;\prefetcher&#61;Null&#10;\replacement_policy&#61;system.l2.replacement_policy&#10;\response_latency&#61;20&#10;\sequential_access&#61;false&#10;\size&#61;2097152&#10;\system&#61;system&#10;\tag_latency&#61;20&#10;\tags&#61;system.l2.tags&#10;\tgts_per_mshr&#61;12&#10;\warmup_percentage&#61;0&#10;\write_allocator&#61;Null&#10;\write_buffers&#61;8&#10;\writeback_clean&#61;false";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_l2_cpu_side [shape=Mrecord, label=cpu_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_l2_mem_side [shape=Mrecord, label=mem_side, style="rounded, filled", color="#000000", fillcolor="#94918b", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_l2_tags {
-shape=Mrecord;
-label="tags \n: BaseSetAssoc";
-tooltip="assoc&#61;8&#10;\block_size&#61;64&#10;\clk_domain&#61;system.cpu_clk_domain&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\indexing_policy&#61;system.l2.tags.indexing_policy&#10;\power_model&#61;&#10;\power_state&#61;system.l2.tags.power_state&#10;\replacement_policy&#61;system.l2.replacement_policy&#10;\sequential_access&#61;false&#10;\size&#61;2097152&#10;\system&#61;system&#10;\tag_latency&#61;20&#10;\warmup_percentage&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-subgraph cluster_system_l2_tags_indexing_policy {
-shape=Mrecord;
-label="indexing_policy \n: SetAssociative";
-tooltip="assoc&#61;8&#10;\entry_size&#61;64&#10;\eventq_index&#61;0&#10;\size&#61;2097152";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_l2_tags_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#84827c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_l2_replacement_policy {
-shape=Mrecord;
-label="replacement_policy \n: LRURP";
-tooltip="eventq_index&#61;0";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_l2_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#9f9c95";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_tol2bus {
-shape=Mrecord;
-label="tol2bus \n: L2XBar";
-tooltip="clk_domain&#61;system.cpu_clk_domain&#10;\eventq_index&#61;0&#10;\forward_latency&#61;0&#10;\frontend_latency&#61;1&#10;\header_latency&#61;1&#10;\max_outstanding_snoops&#61;512&#10;\max_routing_table_size&#61;512&#10;\point_of_coherency&#61;false&#10;\point_of_unification&#61;true&#10;\power_model&#61;&#10;\power_state&#61;system.tol2bus.power_state&#10;\response_latency&#61;1&#10;\snoop_filter&#61;system.tol2bus.snoop_filter&#10;\snoop_response_latency&#61;1&#10;\system&#61;system&#10;\use_default_range&#61;false&#10;\width&#61;32";
-style="rounded, filled";
-color="#000000";
-fillcolor="#6f798c";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_tol2bus_cpu_side_ports [shape=Mrecord, label=cpu_side_ports, style="rounded, filled", color="#000000", fillcolor="#586070", fontname=Arial, fontsize=14, fontcolor="#000000"];
-system_tol2bus_mem_side_ports [shape=Mrecord, label=mem_side_ports, style="rounded, filled", color="#000000", fillcolor="#586070", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_tol2bus_snoop_filter {
-shape=Mrecord;
-label="snoop_filter \n: SnoopFilter";
-tooltip="eventq_index&#61;0&#10;\lookup_latency&#61;0&#10;\max_capacity&#61;8388608&#10;\system&#61;system";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_tol2bus_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_mem_ctrls {
-shape=Mrecord;
-label="mem_ctrls \n: Ramulator";
-tooltip="clk_domain&#61;system.clk_domain&#10;\conf_table_reported&#61;true&#10;\config_file&#61;ramulator_configs/DDR4-config.cfg&#10;\eventq_index&#61;0&#10;\image_file&#61;&#10;\in_addr_map&#61;true&#10;\kvm_map&#61;true&#10;\null&#61;false&#10;\num_cpus&#61;4&#10;\output_dir&#61;m5out/&#10;\power_model&#61;&#10;\power_state&#61;system.mem_ctrls.power_state&#10;\range&#61;0:1073741824&#10;\real_warm_up&#61;100";
-style="rounded, filled";
-color="#000000";
-fillcolor="#5e5958";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-system_mem_ctrls_port [shape=Mrecord, label=port, style="rounded, filled", color="#000000", fillcolor="#4b4746", fontname=Arial, fontsize=14, fontcolor="#000000"];
-subgraph cluster_system_mem_ctrls_power_state {
-shape=Mrecord;
-label="power_state \n: PowerState";
-tooltip="clk_gate_bins&#61;20&#10;\clk_gate_max&#61;1000000000000&#10;\clk_gate_min&#61;1000&#10;\default_state&#61;UNDEFINED&#10;\eventq_index&#61;0&#10;\leaders&#61;&#10;\possible_states&#61;";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-subgraph cluster_system_redirect_paths0 {
-shape=Mrecord;
-label="redirect_paths0 \n: RedirectPath";
-tooltip="app_path&#61;/proc&#10;\eventq_index&#61;0&#10;\host_paths&#61;m5out/fs/proc";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_redirect_paths1 {
-shape=Mrecord;
-label="redirect_paths1 \n: RedirectPath";
-tooltip="app_path&#61;/sys&#10;\eventq_index&#61;0&#10;\host_paths&#61;m5out/fs/sys";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-subgraph cluster_system_redirect_paths2 {
-shape=Mrecord;
-label="redirect_paths2 \n: RedirectPath";
-tooltip="app_path&#61;/tmp&#10;\eventq_index&#61;0&#10;\host_paths&#61;m5out/fs/tmp";
-style="rounded, filled";
-color="#000000";
-fillcolor="#bab6ae";
-fontname=Arial;
-fontsize=14;
-fontcolor="#000000";
-}
-
-}
-
-}
-
-system_system_port -> system_membus_cpu_side_ports  [dir=forward];
-system_cpu0_icache_port -> system_cpu0_icache_cpu_side  [dir=forward];
-system_cpu0_dcache_port -> system_cpu0_dcache_cpu_side  [dir=forward];
-system_cpu0_dtb_walker_port -> system_cpu0_dtb_walker_cache_cpu_side  [dir=forward];
-system_cpu0_itb_walker_port -> system_cpu0_itb_walker_cache_cpu_side  [dir=forward];
-system_cpu1_icache_port -> system_cpu1_icache_cpu_side  [dir=forward];
-system_cpu1_dcache_port -> system_cpu1_dcache_cpu_side  [dir=forward];
-system_cpu1_dtb_walker_port -> system_cpu1_dtb_walker_cache_cpu_side  [dir=forward];
-system_cpu1_itb_walker_port -> system_cpu1_itb_walker_cache_cpu_side  [dir=forward];
-system_cpu2_icache_port -> system_cpu2_icache_cpu_side  [dir=forward];
-system_cpu2_dcache_port -> system_cpu2_dcache_cpu_side  [dir=forward];
-system_cpu2_dtb_walker_port -> system_cpu2_dtb_walker_cache_cpu_side  [dir=forward];
-system_cpu2_itb_walker_port -> system_cpu2_itb_walker_cache_cpu_side  [dir=forward];
-system_cpu3_icache_port -> system_cpu3_icache_cpu_side  [dir=forward];
-system_cpu3_dcache_port -> system_cpu3_dcache_cpu_side  [dir=forward];
-system_cpu3_dtb_walker_port -> system_cpu3_dtb_walker_cache_cpu_side  [dir=forward];
-system_cpu3_itb_walker_port -> system_cpu3_itb_walker_cache_cpu_side  [dir=forward];
-system_membus_cpu_side_ports -> system_l2_mem_side  [dir=back];
-system_membus_cpu_side_ports -> system_cpu0_interrupts_int_requestor  [dir=back];
-system_membus_cpu_side_ports -> system_cpu1_interrupts_int_requestor  [dir=back];
-system_membus_cpu_side_ports -> system_cpu2_interrupts_int_requestor  [dir=back];
-system_membus_cpu_side_ports -> system_cpu3_interrupts_int_requestor  [dir=back];
-system_membus_mem_side_ports -> system_cpu0_interrupts_pio  [dir=forward];
-system_membus_mem_side_ports -> system_cpu0_interrupts_int_responder  [dir=forward];
-system_membus_mem_side_ports -> system_cpu1_interrupts_pio  [dir=forward];
-system_membus_mem_side_ports -> system_cpu1_interrupts_int_responder  [dir=forward];
-system_membus_mem_side_ports -> system_cpu2_interrupts_pio  [dir=forward];
-system_membus_mem_side_ports -> system_cpu2_interrupts_int_responder  [dir=forward];
-system_membus_mem_side_ports -> system_cpu3_interrupts_pio  [dir=forward];
-system_membus_mem_side_ports -> system_cpu3_interrupts_int_responder  [dir=forward];
-system_membus_mem_side_ports -> system_mem_ctrls_port  [dir=forward];
-system_tol2bus_cpu_side_ports -> system_cpu0_icache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu0_dcache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu0_itb_walker_cache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu0_dtb_walker_cache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu1_icache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu1_dcache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu1_itb_walker_cache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu1_dtb_walker_cache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu2_icache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu2_dcache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu2_itb_walker_cache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu2_dtb_walker_cache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu3_icache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu3_dcache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu3_itb_walker_cache_mem_side  [dir=back];
-system_tol2bus_cpu_side_ports -> system_cpu3_dtb_walker_cache_mem_side  [dir=back];
-system_tol2bus_mem_side_ports -> system_l2_cpu_side  [dir=forward];
-}
diff --git a/m5out_default_DDR4/config.dot.pdf b/m5out_default_DDR4/config.dot.pdf
deleted file mode 100644
index 65dbf2808..000000000
Binary files a/m5out_default_DDR4/config.dot.pdf and /dev/null differ
diff --git a/m5out_default_DDR4/config.dot.svg b/m5out_default_DDR4/config.dot.svg
deleted file mode 100644
index e29db2e88..000000000
--- a/m5out_default_DDR4/config.dot.svg
+++ /dev/null
@@ -1,1123 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
- "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
-<!-- Generated by graphviz version 2.40.1 (20161225.0304)
- -->
-<!-- Title: G Pages: 1 -->
-<svg width="4147pt" height="638pt"
- viewBox="0.00 0.00 4147.00 638.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
-<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 634)">
-<title>G</title>
-<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-634 4143,-634 4143,4 -4,4"/>
-<g id="clust1" class="cluster">
-<title>cluster_root</title>
-<g id="a_clust1"><a xlink:title="eventq_index=0&#10;full_system=false&#10;sim_quantum=0&#10;time_sync_enable=false&#10;time_sync_period=100000000000&#10;time_sync_spin_threshold=100000000">
-<path fill="#bab6ae" stroke="#000000" d="M20,-8C20,-8 4119,-8 4119,-8 4125,-8 4131,-14 4131,-20 4131,-20 4131,-610 4131,-610 4131,-616 4125,-622 4119,-622 4119,-622 20,-622 20,-622 14,-622 8,-616 8,-610 8,-610 8,-20 8,-20 8,-14 14,-8 20,-8"/>
-<text text-anchor="middle" x="2069.5" y="-606.8" font-family="Arial" font-size="14.00" fill="#000000">root </text>
-<text text-anchor="middle" x="2069.5" y="-591.8" font-family="Arial" font-size="14.00" fill="#000000">: Root</text>
-</a>
-</g>
-</g>
-<g id="clust2" class="cluster">
-<title>cluster_system</title>
-<g id="a_clust2"><a xlink:title="byte_order=little&#10;cache_line_size=64&#10;eventq_index=0&#10;exit_on_work_items=false&#10;init_param=0&#10;kvm_vm=Null&#10;m5ops_base=4294901760&#10;mem_mode=timing&#10;mem_ranges=0:1073741824&#10;memories=system.mem_ctrls&#10;mmap_using_noreserve=false&#10;multi_thread=false&#10;&#10;um_work_ids=16&#10;&#13;eadfile=&#10;&#13;edirect_paths=system.redirect_paths0 system.redirect_paths1 system.redirect_paths2&#10;shared_backstore=&#10;symbolfile=&#10;thermal_components=&#10;thermal_model=Null&#10;work_begin_ckpt_count=0&#10;work_begin_cpu_id_exit=&#45;1&#10;work_begin_exit_count=0&#10;work_cpus_ckpt_count=0&#10;work_end_ckpt_count=0&#10;work_end_exit_count=0&#10;work_item_id=&#45;1&#10;workload=Null">
-<path fill="#e4e7eb" stroke="#000000" d="M28,-16C28,-16 4111,-16 4111,-16 4117,-16 4123,-22 4123,-28 4123,-28 4123,-564 4123,-564 4123,-570 4117,-576 4111,-576 4111,-576 28,-576 28,-576 22,-576 16,-570 16,-564 16,-564 16,-28 16,-28 16,-22 22,-16 28,-16"/>
-<text text-anchor="middle" x="2069.5" y="-560.8" font-family="Arial" font-size="14.00" fill="#000000">system </text>
-<text text-anchor="middle" x="2069.5" y="-545.8" font-family="Arial" font-size="14.00" fill="#000000">: System</text>
-</a>
-</g>
-</g>
-<g id="clust4" class="cluster">
-<title>cluster_system_cpu0</title>
-<g id="a_clust4"><a xlink:title="branchPred=Null&#10;checker=Null&#10;clk_domain=system.cpu_clk_domain&#10;cpu_id=0&#10;do_checkpoint_insts=true&#10;do_statistics_insts=true&#10;dtb=system.cpu0.dtb&#10;eventq_index=0&#10;function_trace=false&#10;function_trace_start=0&#10;interrupts=system.cpu0.interrupts&#10;isa=system.cpu0.isa&#10;itb=system.cpu0.itb&#10;max_insts_all_threads=0&#10;max_insts_any_thread=0&#10;&#10;umThreads=1&#10;power_gating_on_idle=false&#10;power_model=&#10;power_state=system.cpu0.power_state&#10;progress_interval=0&#10;pwr_gating_latency=300&#10;simpoint_start_insts=&#10;socket_id=0&#10;switched_out=false&#10;syscallRetryLatency=10000&#10;system=system&#10;tracer=system.cpu0.tracer&#10;wait_for_remote_gdb=false&#10;workload=system.cpu0.workload">
-<path fill="#bbc6d9" stroke="#000000" d="M3110,-24C3110,-24 4004,-24 4004,-24 4010,-24 4016,-30 4016,-36 4016,-36 4016,-334 4016,-334 4016,-340 4010,-346 4004,-346 4004,-346 3110,-346 3110,-346 3104,-346 3098,-340 3098,-334 3098,-334 3098,-36 3098,-36 3098,-30 3104,-24 3110,-24"/>
-<text text-anchor="middle" x="3557" y="-330.8" font-family="Arial" font-size="14.00" fill="#000000">cpu0 </text>
-<text text-anchor="middle" x="3557" y="-315.8" font-family="Arial" font-size="14.00" fill="#000000">: TimingSimpleCPU</text>
-</a>
-</g>
-</g>
-<g id="clust5" class="cluster">
-<title>cluster_system_cpu0_dtb</title>
-<g id="a_clust5"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu0.dtb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M3843,-155C3843,-155 3996,-155 3996,-155 4002,-155 4008,-161 4008,-167 4008,-167 4008,-288 4008,-288 4008,-294 4002,-300 3996,-300 3996,-300 3843,-300 3843,-300 3837,-300 3831,-294 3831,-288 3831,-288 3831,-167 3831,-167 3831,-161 3837,-155 3843,-155"/>
-<text text-anchor="middle" x="3919.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">dtb </text>
-<text text-anchor="middle" x="3919.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust6" class="cluster">
-<title>cluster_system_cpu0_dtb_walker</title>
-<g id="a_clust6"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu0.dtb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M3851,-163C3851,-163 3988,-163 3988,-163 3994,-163 4000,-169 4000,-175 4000,-175 4000,-242 4000,-242 4000,-248 3994,-254 3988,-254 3988,-254 3851,-254 3851,-254 3845,-254 3839,-248 3839,-242 3839,-242 3839,-175 3839,-175 3839,-169 3845,-163 3851,-163"/>
-<text text-anchor="middle" x="3919.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="3919.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust8" class="cluster">
-<title>cluster_system_cpu0_itb</title>
-<g id="a_clust8"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu0.itb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M3658,-155C3658,-155 3811,-155 3811,-155 3817,-155 3823,-161 3823,-167 3823,-167 3823,-288 3823,-288 3823,-294 3817,-300 3811,-300 3811,-300 3658,-300 3658,-300 3652,-300 3646,-294 3646,-288 3646,-288 3646,-167 3646,-167 3646,-161 3652,-155 3658,-155"/>
-<text text-anchor="middle" x="3734.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">itb </text>
-<text text-anchor="middle" x="3734.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust9" class="cluster">
-<title>cluster_system_cpu0_itb_walker</title>
-<g id="a_clust9"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu0.itb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M3666,-163C3666,-163 3803,-163 3803,-163 3809,-163 3815,-169 3815,-175 3815,-175 3815,-242 3815,-242 3815,-248 3809,-254 3803,-254 3803,-254 3666,-254 3666,-254 3660,-254 3654,-248 3654,-242 3654,-242 3654,-175 3654,-175 3654,-169 3660,-163 3666,-163"/>
-<text text-anchor="middle" x="3734.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="3734.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust15" class="cluster">
-<title>cluster_system_cpu0_icache</title>
-<g id="a_clust15"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=true&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu0.icache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu0.icache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=32768&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu0.icache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=true">
-<path fill="#bab6ae" stroke="#000000" d="M3320,-32C3320,-32 3490,-32 3490,-32 3496,-32 3502,-38 3502,-44 3502,-44 3502,-111 3502,-111 3502,-117 3496,-123 3490,-123 3490,-123 3320,-123 3320,-123 3314,-123 3308,-117 3308,-111 3308,-111 3308,-44 3308,-44 3308,-38 3314,-32 3320,-32"/>
-<text text-anchor="middle" x="3405" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">icache </text>
-<text text-anchor="middle" x="3405" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_ICache</text>
-</a>
-</g>
-</g>
-<g id="clust21" class="cluster">
-<title>cluster_system_cpu0_dcache</title>
-<g id="a_clust21"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu0.dcache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu0.dcache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=65536&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu0.dcache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M3118,-32C3118,-32 3288,-32 3288,-32 3294,-32 3300,-38 3300,-44 3300,-44 3300,-111 3300,-111 3300,-117 3294,-123 3288,-123 3288,-123 3118,-123 3118,-123 3112,-123 3106,-117 3106,-111 3106,-111 3106,-44 3106,-44 3106,-38 3112,-32 3118,-32"/>
-<text text-anchor="middle" x="3203" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dcache </text>
-<text text-anchor="middle" x="3203" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_DCache</text>
-</a>
-</g>
-</g>
-<g id="clust27" class="cluster">
-<title>cluster_system_cpu0_itb_walker_cache</title>
-<g id="a_clust27"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu0.itb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu0.itb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu0.itb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M3529,-32C3529,-32 3699,-32 3699,-32 3705,-32 3711,-38 3711,-44 3711,-44 3711,-111 3711,-111 3711,-117 3705,-123 3699,-123 3699,-123 3529,-123 3529,-123 3523,-123 3517,-117 3517,-111 3517,-111 3517,-44 3517,-44 3517,-38 3523,-32 3529,-32"/>
-<text text-anchor="middle" x="3614" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">itb_walker_cache </text>
-<text text-anchor="middle" x="3614" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust33" class="cluster">
-<title>cluster_system_cpu0_dtb_walker_cache</title>
-<g id="a_clust33"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu0.dtb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu0.dtb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu0.dtb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M3734,-32C3734,-32 3904,-32 3904,-32 3910,-32 3916,-38 3916,-44 3916,-44 3916,-111 3916,-111 3916,-117 3910,-123 3904,-123 3904,-123 3734,-123 3734,-123 3728,-123 3722,-117 3722,-111 3722,-111 3722,-44 3722,-44 3722,-38 3728,-32 3734,-32"/>
-<text text-anchor="middle" x="3819" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dtb_walker_cache </text>
-<text text-anchor="middle" x="3819" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust39" class="cluster">
-<title>cluster_system_cpu0_interrupts</title>
-<g id="a_clust39"><a xlink:title="clk_domain=system.cpu0.interrupts.clk_domain&#10;eventq_index=0&#10;int_latency=1000&#10;pio_latency=100000&#10;system=system">
-<path fill="#bab6ae" stroke="#000000" d="M3336,-163C3336,-163 3626,-163 3626,-163 3632,-163 3638,-169 3638,-175 3638,-175 3638,-242 3638,-242 3638,-248 3632,-254 3626,-254 3626,-254 3336,-254 3336,-254 3330,-254 3324,-248 3324,-242 3324,-242 3324,-175 3324,-175 3324,-169 3330,-163 3336,-163"/>
-<text text-anchor="middle" x="3481" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">interrupts </text>
-<text text-anchor="middle" x="3481" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86LocalApic</text>
-</a>
-</g>
-</g>
-<g id="clust41" class="cluster">
-<title>cluster_system_cpu1</title>
-<g id="a_clust41"><a xlink:title="branchPred=Null&#10;checker=Null&#10;clk_domain=system.cpu_clk_domain&#10;cpu_id=1&#10;do_checkpoint_insts=true&#10;do_statistics_insts=true&#10;dtb=system.cpu1.dtb&#10;eventq_index=0&#10;function_trace=false&#10;function_trace_start=0&#10;interrupts=system.cpu1.interrupts&#10;isa=system.cpu1.isa&#10;itb=system.cpu1.itb&#10;max_insts_all_threads=0&#10;max_insts_any_thread=0&#10;&#10;umThreads=1&#10;power_gating_on_idle=false&#10;power_model=&#10;power_state=system.cpu1.power_state&#10;progress_interval=0&#10;pwr_gating_latency=300&#10;simpoint_start_insts=&#10;socket_id=0&#10;switched_out=false&#10;syscallRetryLatency=10000&#10;system=system&#10;tracer=system.cpu1.tracer&#10;wait_for_remote_gdb=false&#10;workload=system.cpu0.workload">
-<path fill="#bbc6d9" stroke="#000000" d="M36,-24C36,-24 930,-24 930,-24 936,-24 942,-30 942,-36 942,-36 942,-334 942,-334 942,-340 936,-346 930,-346 930,-346 36,-346 36,-346 30,-346 24,-340 24,-334 24,-334 24,-36 24,-36 24,-30 30,-24 36,-24"/>
-<text text-anchor="middle" x="483" y="-330.8" font-family="Arial" font-size="14.00" fill="#000000">cpu1 </text>
-<text text-anchor="middle" x="483" y="-315.8" font-family="Arial" font-size="14.00" fill="#000000">: TimingSimpleCPU</text>
-</a>
-</g>
-</g>
-<g id="clust42" class="cluster">
-<title>cluster_system_cpu1_dtb</title>
-<g id="a_clust42"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu1.dtb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M769,-155C769,-155 922,-155 922,-155 928,-155 934,-161 934,-167 934,-167 934,-288 934,-288 934,-294 928,-300 922,-300 922,-300 769,-300 769,-300 763,-300 757,-294 757,-288 757,-288 757,-167 757,-167 757,-161 763,-155 769,-155"/>
-<text text-anchor="middle" x="845.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">dtb </text>
-<text text-anchor="middle" x="845.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust43" class="cluster">
-<title>cluster_system_cpu1_dtb_walker</title>
-<g id="a_clust43"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu1.dtb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M777,-163C777,-163 914,-163 914,-163 920,-163 926,-169 926,-175 926,-175 926,-242 926,-242 926,-248 920,-254 914,-254 914,-254 777,-254 777,-254 771,-254 765,-248 765,-242 765,-242 765,-175 765,-175 765,-169 771,-163 777,-163"/>
-<text text-anchor="middle" x="845.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="845.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust45" class="cluster">
-<title>cluster_system_cpu1_itb</title>
-<g id="a_clust45"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu1.itb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M584,-155C584,-155 737,-155 737,-155 743,-155 749,-161 749,-167 749,-167 749,-288 749,-288 749,-294 743,-300 737,-300 737,-300 584,-300 584,-300 578,-300 572,-294 572,-288 572,-288 572,-167 572,-167 572,-161 578,-155 584,-155"/>
-<text text-anchor="middle" x="660.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">itb </text>
-<text text-anchor="middle" x="660.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust46" class="cluster">
-<title>cluster_system_cpu1_itb_walker</title>
-<g id="a_clust46"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu1.itb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M592,-163C592,-163 729,-163 729,-163 735,-163 741,-169 741,-175 741,-175 741,-242 741,-242 741,-248 735,-254 729,-254 729,-254 592,-254 592,-254 586,-254 580,-248 580,-242 580,-242 580,-175 580,-175 580,-169 586,-163 592,-163"/>
-<text text-anchor="middle" x="660.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="660.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust51" class="cluster">
-<title>cluster_system_cpu1_icache</title>
-<g id="a_clust51"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=true&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu1.icache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu1.icache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=32768&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu1.icache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=true">
-<path fill="#bab6ae" stroke="#000000" d="M299,-32C299,-32 469,-32 469,-32 475,-32 481,-38 481,-44 481,-44 481,-111 481,-111 481,-117 475,-123 469,-123 469,-123 299,-123 299,-123 293,-123 287,-117 287,-111 287,-111 287,-44 287,-44 287,-38 293,-32 299,-32"/>
-<text text-anchor="middle" x="384" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">icache </text>
-<text text-anchor="middle" x="384" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_ICache</text>
-</a>
-</g>
-</g>
-<g id="clust57" class="cluster">
-<title>cluster_system_cpu1_dcache</title>
-<g id="a_clust57"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu1.dcache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu1.dcache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=65536&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu1.dcache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M72,-32C72,-32 242,-32 242,-32 248,-32 254,-38 254,-44 254,-44 254,-111 254,-111 254,-117 248,-123 242,-123 242,-123 72,-123 72,-123 66,-123 60,-117 60,-111 60,-111 60,-44 60,-44 60,-38 66,-32 72,-32"/>
-<text text-anchor="middle" x="157" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dcache </text>
-<text text-anchor="middle" x="157" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_DCache</text>
-</a>
-</g>
-</g>
-<g id="clust63" class="cluster">
-<title>cluster_system_cpu1_itb_walker_cache</title>
-<g id="a_clust63"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu1.itb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu1.itb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu1.itb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M550,-32C550,-32 720,-32 720,-32 726,-32 732,-38 732,-44 732,-44 732,-111 732,-111 732,-117 726,-123 720,-123 720,-123 550,-123 550,-123 544,-123 538,-117 538,-111 538,-111 538,-44 538,-44 538,-38 544,-32 550,-32"/>
-<text text-anchor="middle" x="635" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">itb_walker_cache </text>
-<text text-anchor="middle" x="635" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust69" class="cluster">
-<title>cluster_system_cpu1_dtb_walker_cache</title>
-<g id="a_clust69"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu1.dtb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu1.dtb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu1.dtb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M752,-32C752,-32 922,-32 922,-32 928,-32 934,-38 934,-44 934,-44 934,-111 934,-111 934,-117 928,-123 922,-123 922,-123 752,-123 752,-123 746,-123 740,-117 740,-111 740,-111 740,-44 740,-44 740,-38 746,-32 752,-32"/>
-<text text-anchor="middle" x="837" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dtb_walker_cache </text>
-<text text-anchor="middle" x="837" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust75" class="cluster">
-<title>cluster_system_cpu1_interrupts</title>
-<g id="a_clust75"><a xlink:title="clk_domain=system.cpu1.interrupts.clk_domain&#10;eventq_index=0&#10;int_latency=1000&#10;pio_latency=100000&#10;system=system">
-<path fill="#bab6ae" stroke="#000000" d="M262,-163C262,-163 552,-163 552,-163 558,-163 564,-169 564,-175 564,-175 564,-242 564,-242 564,-248 558,-254 552,-254 552,-254 262,-254 262,-254 256,-254 250,-248 250,-242 250,-242 250,-175 250,-175 250,-169 256,-163 262,-163"/>
-<text text-anchor="middle" x="407" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">interrupts </text>
-<text text-anchor="middle" x="407" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86LocalApic</text>
-</a>
-</g>
-</g>
-<g id="clust77" class="cluster">
-<title>cluster_system_cpu2</title>
-<g id="a_clust77"><a xlink:title="branchPred=Null&#10;checker=Null&#10;clk_domain=system.cpu_clk_domain&#10;cpu_id=2&#10;do_checkpoint_insts=true&#10;do_statistics_insts=true&#10;dtb=system.cpu2.dtb&#10;eventq_index=0&#10;function_trace=false&#10;function_trace_start=0&#10;interrupts=system.cpu2.interrupts&#10;isa=system.cpu2.isa&#10;itb=system.cpu2.itb&#10;max_insts_all_threads=0&#10;max_insts_any_thread=0&#10;&#10;umThreads=1&#10;power_gating_on_idle=false&#10;power_model=&#10;power_state=system.cpu2.power_state&#10;progress_interval=0&#10;pwr_gating_latency=300&#10;simpoint_start_insts=&#10;socket_id=0&#10;switched_out=false&#10;syscallRetryLatency=10000&#10;system=system&#10;tracer=system.cpu2.tracer&#10;wait_for_remote_gdb=false&#10;workload=system.cpu0.workload">
-<path fill="#bbc6d9" stroke="#000000" d="M2184,-24C2184,-24 3078,-24 3078,-24 3084,-24 3090,-30 3090,-36 3090,-36 3090,-334 3090,-334 3090,-340 3084,-346 3078,-346 3078,-346 2184,-346 2184,-346 2178,-346 2172,-340 2172,-334 2172,-334 2172,-36 2172,-36 2172,-30 2178,-24 2184,-24"/>
-<text text-anchor="middle" x="2631" y="-330.8" font-family="Arial" font-size="14.00" fill="#000000">cpu2 </text>
-<text text-anchor="middle" x="2631" y="-315.8" font-family="Arial" font-size="14.00" fill="#000000">: TimingSimpleCPU</text>
-</a>
-</g>
-</g>
-<g id="clust78" class="cluster">
-<title>cluster_system_cpu2_dtb</title>
-<g id="a_clust78"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu2.dtb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M2917,-155C2917,-155 3070,-155 3070,-155 3076,-155 3082,-161 3082,-167 3082,-167 3082,-288 3082,-288 3082,-294 3076,-300 3070,-300 3070,-300 2917,-300 2917,-300 2911,-300 2905,-294 2905,-288 2905,-288 2905,-167 2905,-167 2905,-161 2911,-155 2917,-155"/>
-<text text-anchor="middle" x="2993.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">dtb </text>
-<text text-anchor="middle" x="2993.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust79" class="cluster">
-<title>cluster_system_cpu2_dtb_walker</title>
-<g id="a_clust79"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu2.dtb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M2925,-163C2925,-163 3062,-163 3062,-163 3068,-163 3074,-169 3074,-175 3074,-175 3074,-242 3074,-242 3074,-248 3068,-254 3062,-254 3062,-254 2925,-254 2925,-254 2919,-254 2913,-248 2913,-242 2913,-242 2913,-175 2913,-175 2913,-169 2919,-163 2925,-163"/>
-<text text-anchor="middle" x="2993.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="2993.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust81" class="cluster">
-<title>cluster_system_cpu2_itb</title>
-<g id="a_clust81"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu2.itb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M2732,-155C2732,-155 2885,-155 2885,-155 2891,-155 2897,-161 2897,-167 2897,-167 2897,-288 2897,-288 2897,-294 2891,-300 2885,-300 2885,-300 2732,-300 2732,-300 2726,-300 2720,-294 2720,-288 2720,-288 2720,-167 2720,-167 2720,-161 2726,-155 2732,-155"/>
-<text text-anchor="middle" x="2808.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">itb </text>
-<text text-anchor="middle" x="2808.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust82" class="cluster">
-<title>cluster_system_cpu2_itb_walker</title>
-<g id="a_clust82"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu2.itb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M2740,-163C2740,-163 2877,-163 2877,-163 2883,-163 2889,-169 2889,-175 2889,-175 2889,-242 2889,-242 2889,-248 2883,-254 2877,-254 2877,-254 2740,-254 2740,-254 2734,-254 2728,-248 2728,-242 2728,-242 2728,-175 2728,-175 2728,-169 2734,-163 2740,-163"/>
-<text text-anchor="middle" x="2808.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="2808.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust87" class="cluster">
-<title>cluster_system_cpu2_icache</title>
-<g id="a_clust87"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=true&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu2.icache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu2.icache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=32768&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu2.icache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=true">
-<path fill="#bab6ae" stroke="#000000" d="M2394,-32C2394,-32 2564,-32 2564,-32 2570,-32 2576,-38 2576,-44 2576,-44 2576,-111 2576,-111 2576,-117 2570,-123 2564,-123 2564,-123 2394,-123 2394,-123 2388,-123 2382,-117 2382,-111 2382,-111 2382,-44 2382,-44 2382,-38 2388,-32 2394,-32"/>
-<text text-anchor="middle" x="2479" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">icache </text>
-<text text-anchor="middle" x="2479" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_ICache</text>
-</a>
-</g>
-</g>
-<g id="clust93" class="cluster">
-<title>cluster_system_cpu2_dcache</title>
-<g id="a_clust93"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu2.dcache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu2.dcache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=65536&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu2.dcache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M2192,-32C2192,-32 2362,-32 2362,-32 2368,-32 2374,-38 2374,-44 2374,-44 2374,-111 2374,-111 2374,-117 2368,-123 2362,-123 2362,-123 2192,-123 2192,-123 2186,-123 2180,-117 2180,-111 2180,-111 2180,-44 2180,-44 2180,-38 2186,-32 2192,-32"/>
-<text text-anchor="middle" x="2277" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dcache </text>
-<text text-anchor="middle" x="2277" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_DCache</text>
-</a>
-</g>
-</g>
-<g id="clust99" class="cluster">
-<title>cluster_system_cpu2_itb_walker_cache</title>
-<g id="a_clust99"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu2.itb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu2.itb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu2.itb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M2603,-32C2603,-32 2773,-32 2773,-32 2779,-32 2785,-38 2785,-44 2785,-44 2785,-111 2785,-111 2785,-117 2779,-123 2773,-123 2773,-123 2603,-123 2603,-123 2597,-123 2591,-117 2591,-111 2591,-111 2591,-44 2591,-44 2591,-38 2597,-32 2603,-32"/>
-<text text-anchor="middle" x="2688" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">itb_walker_cache </text>
-<text text-anchor="middle" x="2688" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust105" class="cluster">
-<title>cluster_system_cpu2_dtb_walker_cache</title>
-<g id="a_clust105"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu2.dtb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu2.dtb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu2.dtb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M2808,-32C2808,-32 2978,-32 2978,-32 2984,-32 2990,-38 2990,-44 2990,-44 2990,-111 2990,-111 2990,-117 2984,-123 2978,-123 2978,-123 2808,-123 2808,-123 2802,-123 2796,-117 2796,-111 2796,-111 2796,-44 2796,-44 2796,-38 2802,-32 2808,-32"/>
-<text text-anchor="middle" x="2893" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dtb_walker_cache </text>
-<text text-anchor="middle" x="2893" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust111" class="cluster">
-<title>cluster_system_cpu2_interrupts</title>
-<g id="a_clust111"><a xlink:title="clk_domain=system.cpu2.interrupts.clk_domain&#10;eventq_index=0&#10;int_latency=1000&#10;pio_latency=100000&#10;system=system">
-<path fill="#bab6ae" stroke="#000000" d="M2410,-163C2410,-163 2700,-163 2700,-163 2706,-163 2712,-169 2712,-175 2712,-175 2712,-242 2712,-242 2712,-248 2706,-254 2700,-254 2700,-254 2410,-254 2410,-254 2404,-254 2398,-248 2398,-242 2398,-242 2398,-175 2398,-175 2398,-169 2404,-163 2410,-163"/>
-<text text-anchor="middle" x="2555" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">interrupts </text>
-<text text-anchor="middle" x="2555" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86LocalApic</text>
-</a>
-</g>
-</g>
-<g id="clust113" class="cluster">
-<title>cluster_system_cpu3</title>
-<g id="a_clust113"><a xlink:title="branchPred=Null&#10;checker=Null&#10;clk_domain=system.cpu_clk_domain&#10;cpu_id=3&#10;do_checkpoint_insts=true&#10;do_statistics_insts=true&#10;dtb=system.cpu3.dtb&#10;eventq_index=0&#10;function_trace=false&#10;function_trace_start=0&#10;interrupts=system.cpu3.interrupts&#10;isa=system.cpu3.isa&#10;itb=system.cpu3.itb&#10;max_insts_all_threads=0&#10;max_insts_any_thread=0&#10;&#10;umThreads=1&#10;power_gating_on_idle=false&#10;power_model=&#10;power_state=system.cpu3.power_state&#10;progress_interval=0&#10;pwr_gating_latency=300&#10;simpoint_start_insts=&#10;socket_id=0&#10;switched_out=false&#10;syscallRetryLatency=10000&#10;system=system&#10;tracer=system.cpu3.tracer&#10;wait_for_remote_gdb=false&#10;workload=system.cpu0.workload">
-<path fill="#bbc6d9" stroke="#000000" d="M962,-24C962,-24 1856,-24 1856,-24 1862,-24 1868,-30 1868,-36 1868,-36 1868,-334 1868,-334 1868,-340 1862,-346 1856,-346 1856,-346 962,-346 962,-346 956,-346 950,-340 950,-334 950,-334 950,-36 950,-36 950,-30 956,-24 962,-24"/>
-<text text-anchor="middle" x="1409" y="-330.8" font-family="Arial" font-size="14.00" fill="#000000">cpu3 </text>
-<text text-anchor="middle" x="1409" y="-315.8" font-family="Arial" font-size="14.00" fill="#000000">: TimingSimpleCPU</text>
-</a>
-</g>
-</g>
-<g id="clust114" class="cluster">
-<title>cluster_system_cpu3_dtb</title>
-<g id="a_clust114"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu3.dtb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M1695,-155C1695,-155 1848,-155 1848,-155 1854,-155 1860,-161 1860,-167 1860,-167 1860,-288 1860,-288 1860,-294 1854,-300 1848,-300 1848,-300 1695,-300 1695,-300 1689,-300 1683,-294 1683,-288 1683,-288 1683,-167 1683,-167 1683,-161 1689,-155 1695,-155"/>
-<text text-anchor="middle" x="1771.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">dtb </text>
-<text text-anchor="middle" x="1771.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust115" class="cluster">
-<title>cluster_system_cpu3_dtb_walker</title>
-<g id="a_clust115"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu3.dtb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M1703,-163C1703,-163 1840,-163 1840,-163 1846,-163 1852,-169 1852,-175 1852,-175 1852,-242 1852,-242 1852,-248 1846,-254 1840,-254 1840,-254 1703,-254 1703,-254 1697,-254 1691,-248 1691,-242 1691,-242 1691,-175 1691,-175 1691,-169 1697,-163 1703,-163"/>
-<text text-anchor="middle" x="1771.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="1771.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust117" class="cluster">
-<title>cluster_system_cpu3_itb</title>
-<g id="a_clust117"><a xlink:title="eventq_index=0&#10;size=64&#10;system=system&#10;walker=system.cpu3.itb.walker">
-<path fill="#bab6ae" stroke="#000000" d="M1510,-155C1510,-155 1663,-155 1663,-155 1669,-155 1675,-161 1675,-167 1675,-167 1675,-288 1675,-288 1675,-294 1669,-300 1663,-300 1663,-300 1510,-300 1510,-300 1504,-300 1498,-294 1498,-288 1498,-288 1498,-167 1498,-167 1498,-161 1504,-155 1510,-155"/>
-<text text-anchor="middle" x="1586.5" y="-284.8" font-family="Arial" font-size="14.00" fill="#000000">itb </text>
-<text text-anchor="middle" x="1586.5" y="-269.8" font-family="Arial" font-size="14.00" fill="#000000">: X86TLB</text>
-</a>
-</g>
-</g>
-<g id="clust118" class="cluster">
-<title>cluster_system_cpu3_itb_walker</title>
-<g id="a_clust118"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;&#10;um_squash_per_cycle=4&#10;power_model=&#10;power_state=system.cpu3.itb.walker.power_state&#10;system=system">
-<path fill="#9f9c95" stroke="#000000" d="M1518,-163C1518,-163 1655,-163 1655,-163 1661,-163 1667,-169 1667,-175 1667,-175 1667,-242 1667,-242 1667,-248 1661,-254 1655,-254 1655,-254 1518,-254 1518,-254 1512,-254 1506,-248 1506,-242 1506,-242 1506,-175 1506,-175 1506,-169 1512,-163 1518,-163"/>
-<text text-anchor="middle" x="1586.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">walker </text>
-<text text-anchor="middle" x="1586.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86PagetableWalker</text>
-</a>
-</g>
-</g>
-<g id="clust123" class="cluster">
-<title>cluster_system_cpu3_icache</title>
-<g id="a_clust123"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=true&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu3.icache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu3.icache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=32768&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu3.icache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=true">
-<path fill="#bab6ae" stroke="#000000" d="M1225,-32C1225,-32 1395,-32 1395,-32 1401,-32 1407,-38 1407,-44 1407,-44 1407,-111 1407,-111 1407,-117 1401,-123 1395,-123 1395,-123 1225,-123 1225,-123 1219,-123 1213,-117 1213,-111 1213,-111 1213,-44 1213,-44 1213,-38 1219,-32 1225,-32"/>
-<text text-anchor="middle" x="1310" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">icache </text>
-<text text-anchor="middle" x="1310" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_ICache</text>
-</a>
-</g>
-</g>
-<g id="clust129" class="cluster">
-<title>cluster_system_cpu3_dcache</title>
-<g id="a_clust129"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=4&#10;power_model=&#10;power_state=system.cpu3.dcache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu3.dcache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=65536&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu3.dcache.tags&#10;tgts_per_mshr=20&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M998,-32C998,-32 1168,-32 1168,-32 1174,-32 1180,-38 1180,-44 1180,-44 1180,-111 1180,-111 1180,-117 1174,-123 1168,-123 1168,-123 998,-123 998,-123 992,-123 986,-117 986,-111 986,-111 986,-44 986,-44 986,-38 992,-32 998,-32"/>
-<text text-anchor="middle" x="1083" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dcache </text>
-<text text-anchor="middle" x="1083" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L1_DCache</text>
-</a>
-</g>
-</g>
-<g id="clust135" class="cluster">
-<title>cluster_system_cpu3_itb_walker_cache</title>
-<g id="a_clust135"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu3.itb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu3.itb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu3.itb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M1476,-32C1476,-32 1646,-32 1646,-32 1652,-32 1658,-38 1658,-44 1658,-44 1658,-111 1658,-111 1658,-117 1652,-123 1646,-123 1646,-123 1476,-123 1476,-123 1470,-123 1464,-117 1464,-111 1464,-111 1464,-44 1464,-44 1464,-38 1470,-32 1476,-32"/>
-<text text-anchor="middle" x="1561" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">itb_walker_cache </text>
-<text text-anchor="middle" x="1561" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust141" class="cluster">
-<title>cluster_system_cpu3_dtb_walker_cache</title>
-<g id="a_clust141"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=2&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=2&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=10&#10;power_model=&#10;power_state=system.cpu3.dtb_walker_cache.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.cpu3.dtb_walker_cache.replacement_policy&#10;&#13;esponse_latency=2&#10;sequential_access=false&#10;size=1024&#10;system=system&#10;tag_latency=2&#10;tags=system.cpu3.dtb_walker_cache.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M1678,-32C1678,-32 1848,-32 1848,-32 1854,-32 1860,-38 1860,-44 1860,-44 1860,-111 1860,-111 1860,-117 1854,-123 1848,-123 1848,-123 1678,-123 1678,-123 1672,-123 1666,-117 1666,-111 1666,-111 1666,-44 1666,-44 1666,-38 1672,-32 1678,-32"/>
-<text text-anchor="middle" x="1763" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">dtb_walker_cache </text>
-<text text-anchor="middle" x="1763" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: PageTableWalkerCache</text>
-</a>
-</g>
-</g>
-<g id="clust147" class="cluster">
-<title>cluster_system_cpu3_interrupts</title>
-<g id="a_clust147"><a xlink:title="clk_domain=system.cpu3.interrupts.clk_domain&#10;eventq_index=0&#10;int_latency=1000&#10;pio_latency=100000&#10;system=system">
-<path fill="#bab6ae" stroke="#000000" d="M1188,-163C1188,-163 1478,-163 1478,-163 1484,-163 1490,-169 1490,-175 1490,-175 1490,-242 1490,-242 1490,-248 1484,-254 1478,-254 1478,-254 1188,-254 1188,-254 1182,-254 1176,-248 1176,-242 1176,-242 1176,-175 1176,-175 1176,-169 1182,-163 1188,-163"/>
-<text text-anchor="middle" x="1333" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">interrupts </text>
-<text text-anchor="middle" x="1333" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: X86LocalApic</text>
-</a>
-</g>
-</g>
-<g id="clust153" class="cluster">
-<title>cluster_system_membus</title>
-<g id="a_clust153"><a xlink:title="clk_domain=system.clk_domain&#10;eventq_index=0&#10;forward_latency=4&#10;frontend_latency=3&#10;header_latency=1&#10;max_outstanding_snoops=512&#10;max_routing_table_size=512&#10;point_of_coherency=true&#10;point_of_unification=true&#10;power_model=&#10;power_state=system.membus.power_state&#10;&#13;esponse_latency=2&#10;snoop_filter=system.membus.snoop_filter&#10;snoop_response_latency=4&#10;system=system&#10;use_default_range=false&#10;width=16">
-<path fill="#6f798c" stroke="#000000" d="M2026,-354C2026,-354 2278,-354 2278,-354 2284,-354 2290,-360 2290,-366 2290,-366 2290,-433 2290,-433 2290,-439 2284,-445 2278,-445 2278,-445 2026,-445 2026,-445 2020,-445 2014,-439 2014,-433 2014,-433 2014,-366 2014,-366 2014,-360 2020,-354 2026,-354"/>
-<text text-anchor="middle" x="2152" y="-429.8" font-family="Arial" font-size="14.00" fill="#000000">membus </text>
-<text text-anchor="middle" x="2152" y="-414.8" font-family="Arial" font-size="14.00" fill="#000000">: SystemXBar</text>
-</a>
-</g>
-</g>
-<g id="clust156" class="cluster">
-<title>cluster_system_l2</title>
-<g id="a_clust156"><a xlink:title="addr_ranges=0:18446744073709551615&#10;assoc=8&#10;clk_domain=system.cpu_clk_domain&#10;clusivity=mostly_incl&#10;compressor=Null&#10;data_latency=20&#10;demand_mshr_reserve=1&#10;eventq_index=0&#10;is_read_only=false&#10;max_miss_count=0&#10;mshrs=20&#10;power_model=&#10;power_state=system.l2.power_state&#10;prefetch_on_access=false&#10;prefetcher=Null&#10;&#13;eplacement_policy=system.l2.replacement_policy&#10;&#13;esponse_latency=20&#10;sequential_access=false&#10;size=2097152&#10;system=system&#10;tag_latency=20&#10;tags=system.l2.tags&#10;tgts_per_mshr=12&#10;warmup_percentage=0&#10;write_allocator=Null&#10;write_buffers=8&#10;writeback_clean=false">
-<path fill="#bab6ae" stroke="#000000" d="M1922,-32C1922,-32 2092,-32 2092,-32 2098,-32 2104,-38 2104,-44 2104,-44 2104,-111 2104,-111 2104,-117 2098,-123 2092,-123 2092,-123 1922,-123 1922,-123 1916,-123 1910,-117 1910,-111 1910,-111 1910,-44 1910,-44 1910,-38 1916,-32 1922,-32"/>
-<text text-anchor="middle" x="2007" y="-107.8" font-family="Arial" font-size="14.00" fill="#000000">l2 </text>
-<text text-anchor="middle" x="2007" y="-92.8" font-family="Arial" font-size="14.00" fill="#000000">: L2Cache</text>
-</a>
-</g>
-</g>
-<g id="clust162" class="cluster">
-<title>cluster_system_tol2bus</title>
-<g id="a_clust162"><a xlink:title="clk_domain=system.cpu_clk_domain&#10;eventq_index=0&#10;forward_latency=0&#10;frontend_latency=1&#10;header_latency=1&#10;max_outstanding_snoops=512&#10;max_routing_table_size=512&#10;point_of_coherency=false&#10;point_of_unification=true&#10;power_model=&#10;power_state=system.tol2bus.power_state&#10;&#13;esponse_latency=1&#10;snoop_filter=system.tol2bus.snoop_filter&#10;snoop_response_latency=1&#10;system=system&#10;use_default_range=false&#10;width=32">
-<path fill="#6f798c" stroke="#000000" d="M1900,-163C1900,-163 2152,-163 2152,-163 2158,-163 2164,-169 2164,-175 2164,-175 2164,-242 2164,-242 2164,-248 2158,-254 2152,-254 2152,-254 1900,-254 1900,-254 1894,-254 1888,-248 1888,-242 1888,-242 1888,-175 1888,-175 1888,-169 1894,-163 1900,-163"/>
-<text text-anchor="middle" x="2026" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">tol2bus </text>
-<text text-anchor="middle" x="2026" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: L2XBar</text>
-</a>
-</g>
-</g>
-<g id="clust165" class="cluster">
-<title>cluster_system_mem_ctrls</title>
-<g id="a_clust165"><a xlink:title="clk_domain=system.clk_domain&#10;conf_table_reported=true&#10;config_file=ramulator_configs/DDR4&#45;config.cfg&#10;eventq_index=0&#10;image_file=&#10;in_addr_map=true&#10;kvm_map=true&#10;&#10;ull=false&#10;&#10;um_cpus=4&#10;output_dir=m5out/&#10;power_model=&#10;power_state=system.mem_ctrls.power_state&#10;&#13;ange=0:1073741824&#10;&#13;eal_warm_up=100">
-<path fill="#5e5958" stroke="#000000" d="M4036,-163C4036,-163 4103,-163 4103,-163 4109,-163 4115,-169 4115,-175 4115,-175 4115,-242 4115,-242 4115,-248 4109,-254 4103,-254 4103,-254 4036,-254 4036,-254 4030,-254 4024,-248 4024,-242 4024,-242 4024,-175 4024,-175 4024,-169 4030,-163 4036,-163"/>
-<text text-anchor="middle" x="4069.5" y="-238.8" font-family="Arial" font-size="14.00" fill="#000000">mem_ctrls </text>
-<text text-anchor="middle" x="4069.5" y="-223.8" font-family="Arial" font-size="14.00" fill="#000000">: Ramulator</text>
-</a>
-</g>
-</g>
-<!-- system_system_port -->
-<g id="node1" class="node">
-<title>system_system_port</title>
-<path fill="#b6b8bc" stroke="#000000" d="M2188,-493.5C2188,-493.5 2260,-493.5 2260,-493.5 2266,-493.5 2272,-499.5 2272,-505.5 2272,-505.5 2272,-517.5 2272,-517.5 2272,-523.5 2266,-529.5 2260,-529.5 2260,-529.5 2188,-529.5 2188,-529.5 2182,-529.5 2176,-523.5 2176,-517.5 2176,-517.5 2176,-505.5 2176,-505.5 2176,-499.5 2182,-493.5 2188,-493.5"/>
-<text text-anchor="middle" x="2224" y="-507.8" font-family="Arial" font-size="14.00" fill="#000000">system_port</text>
-</g>
-<!-- system_membus_cpu_side_ports -->
-<g id="node62" class="node">
-<title>system_membus_cpu_side_ports</title>
-<path fill="#586070" stroke="#000000" d="M2178,-362.5C2178,-362.5 2270,-362.5 2270,-362.5 2276,-362.5 2282,-368.5 2282,-374.5 2282,-374.5 2282,-386.5 2282,-386.5 2282,-392.5 2276,-398.5 2270,-398.5 2270,-398.5 2178,-398.5 2178,-398.5 2172,-398.5 2166,-392.5 2166,-386.5 2166,-386.5 2166,-374.5 2166,-374.5 2166,-368.5 2172,-362.5 2178,-362.5"/>
-<text text-anchor="middle" x="2224" y="-376.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side_ports</text>
-</g>
-<!-- system_system_port&#45;&gt;system_membus_cpu_side_ports -->
-<g id="edge1" class="edge">
-<title>system_system_port&#45;&gt;system_membus_cpu_side_ports</title>
-<path fill="none" stroke="#000000" d="M2224,-493.285C2224,-471.3856 2224,-434.3861 2224,-408.7663"/>
-<polygon fill="#000000" stroke="#000000" points="2227.5001,-408.5603 2224,-398.5603 2220.5001,-408.5603 2227.5001,-408.5603"/>
-</g>
-<!-- system_cpu0_icache_port -->
-<g id="node2" class="node">
-<title>system_cpu0_icache_port</title>
-<path fill="#959ead" stroke="#000000" d="M3234,-171.5C3234,-171.5 3302,-171.5 3302,-171.5 3308,-171.5 3314,-177.5 3314,-183.5 3314,-183.5 3314,-195.5 3314,-195.5 3314,-201.5 3308,-207.5 3302,-207.5 3302,-207.5 3234,-207.5 3234,-207.5 3228,-207.5 3222,-201.5 3222,-195.5 3222,-195.5 3222,-183.5 3222,-183.5 3222,-177.5 3228,-171.5 3234,-171.5"/>
-<text text-anchor="middle" x="3268" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">icache_port</text>
-</g>
-<!-- system_cpu0_icache_cpu_side -->
-<g id="node6" class="node">
-<title>system_cpu0_icache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M3430,-40.5C3430,-40.5 3482,-40.5 3482,-40.5 3488,-40.5 3494,-46.5 3494,-52.5 3494,-52.5 3494,-64.5 3494,-64.5 3494,-70.5 3488,-76.5 3482,-76.5 3482,-76.5 3430,-76.5 3430,-76.5 3424,-76.5 3418,-70.5 3418,-64.5 3418,-64.5 3418,-52.5 3418,-52.5 3418,-46.5 3424,-40.5 3430,-40.5"/>
-<text text-anchor="middle" x="3456" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu0_icache_port&#45;&gt;system_cpu0_icache_cpu_side -->
-<g id="edge2" class="edge">
-<title>system_cpu0_icache_port&#45;&gt;system_cpu0_icache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M3292.6553,-171.3866C3301.0698,-165.6869 3310.7059,-159.6683 3320,-155 3357.5627,-136.1331 3375.3626,-148.2079 3409,-123 3422.2046,-113.1044 3433.2951,-98.4568 3441.3808,-85.6201"/>
-<polygon fill="#000000" stroke="#000000" points="3444.5946,-87.0654 3446.7247,-76.6869 3438.5874,-83.4719 3444.5946,-87.0654"/>
-</g>
-<!-- system_cpu0_dcache_port -->
-<g id="node3" class="node">
-<title>system_cpu0_dcache_port</title>
-<path fill="#959ead" stroke="#000000" d="M3118,-171.5C3118,-171.5 3192,-171.5 3192,-171.5 3198,-171.5 3204,-177.5 3204,-183.5 3204,-183.5 3204,-195.5 3204,-195.5 3204,-201.5 3198,-207.5 3192,-207.5 3192,-207.5 3118,-207.5 3118,-207.5 3112,-207.5 3106,-201.5 3106,-195.5 3106,-195.5 3106,-183.5 3106,-183.5 3106,-177.5 3112,-171.5 3118,-171.5"/>
-<text text-anchor="middle" x="3155" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">dcache_port</text>
-</g>
-<!-- system_cpu0_dcache_cpu_side -->
-<g id="node8" class="node">
-<title>system_cpu0_dcache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M3228,-40.5C3228,-40.5 3280,-40.5 3280,-40.5 3286,-40.5 3292,-46.5 3292,-52.5 3292,-52.5 3292,-64.5 3292,-64.5 3292,-70.5 3286,-76.5 3280,-76.5 3280,-76.5 3228,-76.5 3228,-76.5 3222,-76.5 3216,-70.5 3216,-64.5 3216,-64.5 3216,-52.5 3216,-52.5 3216,-46.5 3222,-40.5 3228,-40.5"/>
-<text text-anchor="middle" x="3254" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu0_dcache_port&#45;&gt;system_cpu0_dcache_cpu_side -->
-<g id="edge3" class="edge">
-<title>system_cpu0_dcache_port&#45;&gt;system_cpu0_dcache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M3169.5148,-171.2823C3180.0386,-157.9906 3194.5488,-139.4922 3207,-123 3216.4051,-110.5426 3226.6343,-96.5585 3235.141,-84.8038"/>
-<polygon fill="#000000" stroke="#000000" points="3237.9809,-86.8496 3240.9943,-76.6923 3232.3044,-82.7534 3237.9809,-86.8496"/>
-</g>
-<!-- system_cpu0_dtb_walker_port -->
-<g id="node4" class="node">
-<title>system_cpu0_dtb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M3859,-171.5C3859,-171.5 3889,-171.5 3889,-171.5 3895,-171.5 3901,-177.5 3901,-183.5 3901,-183.5 3901,-195.5 3901,-195.5 3901,-201.5 3895,-207.5 3889,-207.5 3889,-207.5 3859,-207.5 3859,-207.5 3853,-207.5 3847,-201.5 3847,-195.5 3847,-195.5 3847,-183.5 3847,-183.5 3847,-177.5 3853,-171.5 3859,-171.5"/>
-<text text-anchor="middle" x="3874" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu0_dtb_walker_cache_cpu_side -->
-<g id="node12" class="node">
-<title>system_cpu0_dtb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M3844,-40.5C3844,-40.5 3896,-40.5 3896,-40.5 3902,-40.5 3908,-46.5 3908,-52.5 3908,-52.5 3908,-64.5 3908,-64.5 3908,-70.5 3902,-76.5 3896,-76.5 3896,-76.5 3844,-76.5 3844,-76.5 3838,-76.5 3832,-70.5 3832,-64.5 3832,-64.5 3832,-52.5 3832,-52.5 3832,-46.5 3838,-40.5 3844,-40.5"/>
-<text text-anchor="middle" x="3870" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu0_dtb_walker_port&#45;&gt;system_cpu0_dtb_walker_cache_cpu_side -->
-<g id="edge4" class="edge">
-<title>system_cpu0_dtb_walker_port&#45;&gt;system_cpu0_dtb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M3873.4438,-171.285C3872.7751,-149.3856 3871.6454,-112.3861 3870.8631,-86.7663"/>
-<polygon fill="#000000" stroke="#000000" points="3874.3551,-86.4488 3870.5515,-76.5603 3867.3584,-86.6625 3874.3551,-86.4488"/>
-</g>
-<!-- system_cpu0_itb_walker_port -->
-<g id="node5" class="node">
-<title>system_cpu0_itb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M3674,-171.5C3674,-171.5 3704,-171.5 3704,-171.5 3710,-171.5 3716,-177.5 3716,-183.5 3716,-183.5 3716,-195.5 3716,-195.5 3716,-201.5 3710,-207.5 3704,-207.5 3704,-207.5 3674,-207.5 3674,-207.5 3668,-207.5 3662,-201.5 3662,-195.5 3662,-195.5 3662,-183.5 3662,-183.5 3662,-177.5 3668,-171.5 3674,-171.5"/>
-<text text-anchor="middle" x="3689" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu0_itb_walker_cache_cpu_side -->
-<g id="node10" class="node">
-<title>system_cpu0_itb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M3639,-40.5C3639,-40.5 3691,-40.5 3691,-40.5 3697,-40.5 3703,-46.5 3703,-52.5 3703,-52.5 3703,-64.5 3703,-64.5 3703,-70.5 3697,-76.5 3691,-76.5 3691,-76.5 3639,-76.5 3639,-76.5 3633,-76.5 3627,-70.5 3627,-64.5 3627,-64.5 3627,-52.5 3627,-52.5 3627,-46.5 3633,-40.5 3639,-40.5"/>
-<text text-anchor="middle" x="3665" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu0_itb_walker_port&#45;&gt;system_cpu0_itb_walker_cache_cpu_side -->
-<g id="edge5" class="edge">
-<title>system_cpu0_itb_walker_port&#45;&gt;system_cpu0_itb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M3685.6629,-171.285C3681.6329,-149.2878 3674.8117,-112.0554 3670.1158,-86.4238"/>
-<polygon fill="#000000" stroke="#000000" points="3673.5536,-85.7658 3668.3088,-76.5603 3666.6682,-87.0273 3673.5536,-85.7658"/>
-</g>
-<!-- system_cpu0_icache_mem_side -->
-<g id="node7" class="node">
-<title>system_cpu0_icache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M3328,-40.5C3328,-40.5 3388,-40.5 3388,-40.5 3394,-40.5 3400,-46.5 3400,-52.5 3400,-52.5 3400,-64.5 3400,-64.5 3400,-70.5 3394,-76.5 3388,-76.5 3388,-76.5 3328,-76.5 3328,-76.5 3322,-76.5 3316,-70.5 3316,-64.5 3316,-64.5 3316,-52.5 3316,-52.5 3316,-46.5 3322,-40.5 3328,-40.5"/>
-<text text-anchor="middle" x="3358" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu0_dcache_mem_side -->
-<g id="node9" class="node">
-<title>system_cpu0_dcache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M3126,-40.5C3126,-40.5 3186,-40.5 3186,-40.5 3192,-40.5 3198,-46.5 3198,-52.5 3198,-52.5 3198,-64.5 3198,-64.5 3198,-70.5 3192,-76.5 3186,-76.5 3186,-76.5 3126,-76.5 3126,-76.5 3120,-76.5 3114,-70.5 3114,-64.5 3114,-64.5 3114,-52.5 3114,-52.5 3114,-46.5 3120,-40.5 3126,-40.5"/>
-<text text-anchor="middle" x="3156" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu0_itb_walker_cache_mem_side -->
-<g id="node11" class="node">
-<title>system_cpu0_itb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M3537,-40.5C3537,-40.5 3597,-40.5 3597,-40.5 3603,-40.5 3609,-46.5 3609,-52.5 3609,-52.5 3609,-64.5 3609,-64.5 3609,-70.5 3603,-76.5 3597,-76.5 3597,-76.5 3537,-76.5 3537,-76.5 3531,-76.5 3525,-70.5 3525,-64.5 3525,-64.5 3525,-52.5 3525,-52.5 3525,-46.5 3531,-40.5 3537,-40.5"/>
-<text text-anchor="middle" x="3567" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu0_dtb_walker_cache_mem_side -->
-<g id="node13" class="node">
-<title>system_cpu0_dtb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M3742,-40.5C3742,-40.5 3802,-40.5 3802,-40.5 3808,-40.5 3814,-46.5 3814,-52.5 3814,-52.5 3814,-64.5 3814,-64.5 3814,-70.5 3808,-76.5 3802,-76.5 3802,-76.5 3742,-76.5 3742,-76.5 3736,-76.5 3730,-70.5 3730,-64.5 3730,-64.5 3730,-52.5 3730,-52.5 3730,-46.5 3736,-40.5 3742,-40.5"/>
-<text text-anchor="middle" x="3772" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu0_interrupts_int_requestor -->
-<g id="node14" class="node">
-<title>system_cpu0_interrupts_int_requestor</title>
-<path fill="#94918b" stroke="#000000" d="M3540.5,-171.5C3540.5,-171.5 3617.5,-171.5 3617.5,-171.5 3623.5,-171.5 3629.5,-177.5 3629.5,-183.5 3629.5,-183.5 3629.5,-195.5 3629.5,-195.5 3629.5,-201.5 3623.5,-207.5 3617.5,-207.5 3617.5,-207.5 3540.5,-207.5 3540.5,-207.5 3534.5,-207.5 3528.5,-201.5 3528.5,-195.5 3528.5,-195.5 3528.5,-183.5 3528.5,-183.5 3528.5,-177.5 3534.5,-171.5 3540.5,-171.5"/>
-<text text-anchor="middle" x="3579" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_requestor</text>
-</g>
-<!-- system_cpu0_interrupts_int_responder -->
-<g id="node15" class="node">
-<title>system_cpu0_interrupts_int_responder</title>
-<path fill="#94918b" stroke="#000000" d="M3416,-171.5C3416,-171.5 3498,-171.5 3498,-171.5 3504,-171.5 3510,-177.5 3510,-183.5 3510,-183.5 3510,-195.5 3510,-195.5 3510,-201.5 3504,-207.5 3498,-207.5 3498,-207.5 3416,-207.5 3416,-207.5 3410,-207.5 3404,-201.5 3404,-195.5 3404,-195.5 3404,-183.5 3404,-183.5 3404,-177.5 3410,-171.5 3416,-171.5"/>
-<text text-anchor="middle" x="3457" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_responder</text>
-</g>
-<!-- system_cpu0_interrupts_pio -->
-<g id="node16" class="node">
-<title>system_cpu0_interrupts_pio</title>
-<path fill="#94918b" stroke="#000000" d="M3344,-171.5C3344,-171.5 3374,-171.5 3374,-171.5 3380,-171.5 3386,-177.5 3386,-183.5 3386,-183.5 3386,-195.5 3386,-195.5 3386,-201.5 3380,-207.5 3374,-207.5 3374,-207.5 3344,-207.5 3344,-207.5 3338,-207.5 3332,-201.5 3332,-195.5 3332,-195.5 3332,-183.5 3332,-183.5 3332,-177.5 3338,-171.5 3344,-171.5"/>
-<text text-anchor="middle" x="3359" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">pio</text>
-</g>
-<!-- system_cpu1_icache_port -->
-<g id="node17" class="node">
-<title>system_cpu1_icache_port</title>
-<path fill="#959ead" stroke="#000000" d="M160,-171.5C160,-171.5 228,-171.5 228,-171.5 234,-171.5 240,-177.5 240,-183.5 240,-183.5 240,-195.5 240,-195.5 240,-201.5 234,-207.5 228,-207.5 228,-207.5 160,-207.5 160,-207.5 154,-207.5 148,-201.5 148,-195.5 148,-195.5 148,-183.5 148,-183.5 148,-177.5 154,-171.5 160,-171.5"/>
-<text text-anchor="middle" x="194" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">icache_port</text>
-</g>
-<!-- system_cpu1_icache_cpu_side -->
-<g id="node21" class="node">
-<title>system_cpu1_icache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M307,-40.5C307,-40.5 359,-40.5 359,-40.5 365,-40.5 371,-46.5 371,-52.5 371,-52.5 371,-64.5 371,-64.5 371,-70.5 365,-76.5 359,-76.5 359,-76.5 307,-76.5 307,-76.5 301,-76.5 295,-70.5 295,-64.5 295,-64.5 295,-52.5 295,-52.5 295,-46.5 301,-40.5 307,-40.5"/>
-<text text-anchor="middle" x="333" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu1_icache_port&#45;&gt;system_cpu1_icache_cpu_side -->
-<g id="edge6" class="edge">
-<title>system_cpu1_icache_port&#45;&gt;system_cpu1_icache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M213.3274,-171.285C237.4978,-148.5057 279.0038,-109.3885 306.2239,-83.735"/>
-<polygon fill="#000000" stroke="#000000" points="308.9599,-85.966 313.8368,-76.5603 304.1589,-80.8718 308.9599,-85.966"/>
-</g>
-<!-- system_cpu1_dcache_port -->
-<g id="node18" class="node">
-<title>system_cpu1_dcache_port</title>
-<path fill="#959ead" stroke="#000000" d="M44,-171.5C44,-171.5 118,-171.5 118,-171.5 124,-171.5 130,-177.5 130,-183.5 130,-183.5 130,-195.5 130,-195.5 130,-201.5 124,-207.5 118,-207.5 118,-207.5 44,-207.5 44,-207.5 38,-207.5 32,-201.5 32,-195.5 32,-195.5 32,-183.5 32,-183.5 32,-177.5 38,-171.5 44,-171.5"/>
-<text text-anchor="middle" x="81" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">dcache_port</text>
-</g>
-<!-- system_cpu1_dcache_cpu_side -->
-<g id="node23" class="node">
-<title>system_cpu1_dcache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M80,-40.5C80,-40.5 132,-40.5 132,-40.5 138,-40.5 144,-46.5 144,-52.5 144,-52.5 144,-64.5 144,-64.5 144,-70.5 138,-76.5 132,-76.5 132,-76.5 80,-76.5 80,-76.5 74,-76.5 68,-70.5 68,-64.5 68,-64.5 68,-52.5 68,-52.5 68,-46.5 74,-40.5 80,-40.5"/>
-<text text-anchor="middle" x="106" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu1_dcache_port&#45;&gt;system_cpu1_dcache_cpu_side -->
-<g id="edge7" class="edge">
-<title>system_cpu1_dcache_port&#45;&gt;system_cpu1_dcache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M84.4761,-171.285C88.6741,-149.2878 95.7795,-112.0554 100.671,-86.4238"/>
-<polygon fill="#000000" stroke="#000000" points="104.1167,-87.0391 102.5534,-76.5603 97.2408,-85.7269 104.1167,-87.0391"/>
-</g>
-<!-- system_cpu1_dtb_walker_port -->
-<g id="node19" class="node">
-<title>system_cpu1_dtb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M785,-171.5C785,-171.5 815,-171.5 815,-171.5 821,-171.5 827,-177.5 827,-183.5 827,-183.5 827,-195.5 827,-195.5 827,-201.5 821,-207.5 815,-207.5 815,-207.5 785,-207.5 785,-207.5 779,-207.5 773,-201.5 773,-195.5 773,-195.5 773,-183.5 773,-183.5 773,-177.5 779,-171.5 785,-171.5"/>
-<text text-anchor="middle" x="800" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu1_dtb_walker_cache_cpu_side -->
-<g id="node27" class="node">
-<title>system_cpu1_dtb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M760,-40.5C760,-40.5 812,-40.5 812,-40.5 818,-40.5 824,-46.5 824,-52.5 824,-52.5 824,-64.5 824,-64.5 824,-70.5 818,-76.5 812,-76.5 812,-76.5 760,-76.5 760,-76.5 754,-76.5 748,-70.5 748,-64.5 748,-64.5 748,-52.5 748,-52.5 748,-46.5 754,-40.5 760,-40.5"/>
-<text text-anchor="middle" x="786" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu1_dtb_walker_port&#45;&gt;system_cpu1_dtb_walker_cache_cpu_side -->
-<g id="edge8" class="edge">
-<title>system_cpu1_dtb_walker_port&#45;&gt;system_cpu1_dtb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M798.0534,-171.285C795.713,-149.3856 791.7588,-112.3861 789.0208,-86.7663"/>
-<polygon fill="#000000" stroke="#000000" points="792.473,-86.1317 787.9301,-76.5603 785.5127,-86.8756 792.473,-86.1317"/>
-</g>
-<!-- system_cpu1_itb_walker_port -->
-<g id="node20" class="node">
-<title>system_cpu1_itb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M600,-171.5C600,-171.5 630,-171.5 630,-171.5 636,-171.5 642,-177.5 642,-183.5 642,-183.5 642,-195.5 642,-195.5 642,-201.5 636,-207.5 630,-207.5 630,-207.5 600,-207.5 600,-207.5 594,-207.5 588,-201.5 588,-195.5 588,-195.5 588,-183.5 588,-183.5 588,-177.5 594,-171.5 600,-171.5"/>
-<text text-anchor="middle" x="615" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu1_itb_walker_cache_cpu_side -->
-<g id="node25" class="node">
-<title>system_cpu1_itb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M558,-40.5C558,-40.5 610,-40.5 610,-40.5 616,-40.5 622,-46.5 622,-52.5 622,-52.5 622,-64.5 622,-64.5 622,-70.5 616,-76.5 610,-76.5 610,-76.5 558,-76.5 558,-76.5 552,-76.5 546,-70.5 546,-64.5 546,-64.5 546,-52.5 546,-52.5 546,-46.5 552,-40.5 558,-40.5"/>
-<text text-anchor="middle" x="584" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu1_itb_walker_port&#45;&gt;system_cpu1_itb_walker_cache_cpu_side -->
-<g id="edge9" class="edge">
-<title>system_cpu1_itb_walker_port&#45;&gt;system_cpu1_itb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M610.6896,-171.285C605.4841,-149.2878 596.6734,-112.0554 590.6079,-86.4238"/>
-<polygon fill="#000000" stroke="#000000" points="593.9826,-85.4855 588.2738,-76.5603 587.1708,-87.0975 593.9826,-85.4855"/>
-</g>
-<!-- system_cpu1_icache_mem_side -->
-<g id="node22" class="node">
-<title>system_cpu1_icache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M401,-40.5C401,-40.5 461,-40.5 461,-40.5 467,-40.5 473,-46.5 473,-52.5 473,-52.5 473,-64.5 473,-64.5 473,-70.5 467,-76.5 461,-76.5 461,-76.5 401,-76.5 401,-76.5 395,-76.5 389,-70.5 389,-64.5 389,-64.5 389,-52.5 389,-52.5 389,-46.5 395,-40.5 401,-40.5"/>
-<text text-anchor="middle" x="431" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu1_dcache_mem_side -->
-<g id="node24" class="node">
-<title>system_cpu1_dcache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M174,-40.5C174,-40.5 234,-40.5 234,-40.5 240,-40.5 246,-46.5 246,-52.5 246,-52.5 246,-64.5 246,-64.5 246,-70.5 240,-76.5 234,-76.5 234,-76.5 174,-76.5 174,-76.5 168,-76.5 162,-70.5 162,-64.5 162,-64.5 162,-52.5 162,-52.5 162,-46.5 168,-40.5 174,-40.5"/>
-<text text-anchor="middle" x="204" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu1_itb_walker_cache_mem_side -->
-<g id="node26" class="node">
-<title>system_cpu1_itb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M652,-40.5C652,-40.5 712,-40.5 712,-40.5 718,-40.5 724,-46.5 724,-52.5 724,-52.5 724,-64.5 724,-64.5 724,-70.5 718,-76.5 712,-76.5 712,-76.5 652,-76.5 652,-76.5 646,-76.5 640,-70.5 640,-64.5 640,-64.5 640,-52.5 640,-52.5 640,-46.5 646,-40.5 652,-40.5"/>
-<text text-anchor="middle" x="682" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu1_dtb_walker_cache_mem_side -->
-<g id="node28" class="node">
-<title>system_cpu1_dtb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M854,-40.5C854,-40.5 914,-40.5 914,-40.5 920,-40.5 926,-46.5 926,-52.5 926,-52.5 926,-64.5 926,-64.5 926,-70.5 920,-76.5 914,-76.5 914,-76.5 854,-76.5 854,-76.5 848,-76.5 842,-70.5 842,-64.5 842,-64.5 842,-52.5 842,-52.5 842,-46.5 848,-40.5 854,-40.5"/>
-<text text-anchor="middle" x="884" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu1_interrupts_int_requestor -->
-<g id="node29" class="node">
-<title>system_cpu1_interrupts_int_requestor</title>
-<path fill="#94918b" stroke="#000000" d="M466.5,-171.5C466.5,-171.5 543.5,-171.5 543.5,-171.5 549.5,-171.5 555.5,-177.5 555.5,-183.5 555.5,-183.5 555.5,-195.5 555.5,-195.5 555.5,-201.5 549.5,-207.5 543.5,-207.5 543.5,-207.5 466.5,-207.5 466.5,-207.5 460.5,-207.5 454.5,-201.5 454.5,-195.5 454.5,-195.5 454.5,-183.5 454.5,-183.5 454.5,-177.5 460.5,-171.5 466.5,-171.5"/>
-<text text-anchor="middle" x="505" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_requestor</text>
-</g>
-<!-- system_cpu1_interrupts_int_responder -->
-<g id="node30" class="node">
-<title>system_cpu1_interrupts_int_responder</title>
-<path fill="#94918b" stroke="#000000" d="M342,-171.5C342,-171.5 424,-171.5 424,-171.5 430,-171.5 436,-177.5 436,-183.5 436,-183.5 436,-195.5 436,-195.5 436,-201.5 430,-207.5 424,-207.5 424,-207.5 342,-207.5 342,-207.5 336,-207.5 330,-201.5 330,-195.5 330,-195.5 330,-183.5 330,-183.5 330,-177.5 336,-171.5 342,-171.5"/>
-<text text-anchor="middle" x="383" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_responder</text>
-</g>
-<!-- system_cpu1_interrupts_pio -->
-<g id="node31" class="node">
-<title>system_cpu1_interrupts_pio</title>
-<path fill="#94918b" stroke="#000000" d="M270,-171.5C270,-171.5 300,-171.5 300,-171.5 306,-171.5 312,-177.5 312,-183.5 312,-183.5 312,-195.5 312,-195.5 312,-201.5 306,-207.5 300,-207.5 300,-207.5 270,-207.5 270,-207.5 264,-207.5 258,-201.5 258,-195.5 258,-195.5 258,-183.5 258,-183.5 258,-177.5 264,-171.5 270,-171.5"/>
-<text text-anchor="middle" x="285" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">pio</text>
-</g>
-<!-- system_cpu2_icache_port -->
-<g id="node32" class="node">
-<title>system_cpu2_icache_port</title>
-<path fill="#959ead" stroke="#000000" d="M2308,-171.5C2308,-171.5 2376,-171.5 2376,-171.5 2382,-171.5 2388,-177.5 2388,-183.5 2388,-183.5 2388,-195.5 2388,-195.5 2388,-201.5 2382,-207.5 2376,-207.5 2376,-207.5 2308,-207.5 2308,-207.5 2302,-207.5 2296,-201.5 2296,-195.5 2296,-195.5 2296,-183.5 2296,-183.5 2296,-177.5 2302,-171.5 2308,-171.5"/>
-<text text-anchor="middle" x="2342" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">icache_port</text>
-</g>
-<!-- system_cpu2_icache_cpu_side -->
-<g id="node36" class="node">
-<title>system_cpu2_icache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M2504,-40.5C2504,-40.5 2556,-40.5 2556,-40.5 2562,-40.5 2568,-46.5 2568,-52.5 2568,-52.5 2568,-64.5 2568,-64.5 2568,-70.5 2562,-76.5 2556,-76.5 2556,-76.5 2504,-76.5 2504,-76.5 2498,-76.5 2492,-70.5 2492,-64.5 2492,-64.5 2492,-52.5 2492,-52.5 2492,-46.5 2498,-40.5 2504,-40.5"/>
-<text text-anchor="middle" x="2530" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu2_icache_port&#45;&gt;system_cpu2_icache_cpu_side -->
-<g id="edge10" class="edge">
-<title>system_cpu2_icache_port&#45;&gt;system_cpu2_icache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M2366.6553,-171.3866C2375.0698,-165.6869 2384.7059,-159.6683 2394,-155 2431.5627,-136.1331 2449.3626,-148.2079 2483,-123 2496.2046,-113.1044 2507.2951,-98.4568 2515.3808,-85.6201"/>
-<polygon fill="#000000" stroke="#000000" points="2518.5946,-87.0654 2520.7247,-76.6869 2512.5874,-83.4719 2518.5946,-87.0654"/>
-</g>
-<!-- system_cpu2_dcache_port -->
-<g id="node33" class="node">
-<title>system_cpu2_dcache_port</title>
-<path fill="#959ead" stroke="#000000" d="M2192,-171.5C2192,-171.5 2266,-171.5 2266,-171.5 2272,-171.5 2278,-177.5 2278,-183.5 2278,-183.5 2278,-195.5 2278,-195.5 2278,-201.5 2272,-207.5 2266,-207.5 2266,-207.5 2192,-207.5 2192,-207.5 2186,-207.5 2180,-201.5 2180,-195.5 2180,-195.5 2180,-183.5 2180,-183.5 2180,-177.5 2186,-171.5 2192,-171.5"/>
-<text text-anchor="middle" x="2229" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">dcache_port</text>
-</g>
-<!-- system_cpu2_dcache_cpu_side -->
-<g id="node38" class="node">
-<title>system_cpu2_dcache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M2302,-40.5C2302,-40.5 2354,-40.5 2354,-40.5 2360,-40.5 2366,-46.5 2366,-52.5 2366,-52.5 2366,-64.5 2366,-64.5 2366,-70.5 2360,-76.5 2354,-76.5 2354,-76.5 2302,-76.5 2302,-76.5 2296,-76.5 2290,-70.5 2290,-64.5 2290,-64.5 2290,-52.5 2290,-52.5 2290,-46.5 2296,-40.5 2302,-40.5"/>
-<text text-anchor="middle" x="2328" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu2_dcache_port&#45;&gt;system_cpu2_dcache_cpu_side -->
-<g id="edge11" class="edge">
-<title>system_cpu2_dcache_port&#45;&gt;system_cpu2_dcache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M2243.5148,-171.2823C2254.0386,-157.9906 2268.5488,-139.4922 2281,-123 2290.4051,-110.5426 2300.6343,-96.5585 2309.141,-84.8038"/>
-<polygon fill="#000000" stroke="#000000" points="2311.9809,-86.8496 2314.9943,-76.6923 2306.3044,-82.7534 2311.9809,-86.8496"/>
-</g>
-<!-- system_cpu2_dtb_walker_port -->
-<g id="node34" class="node">
-<title>system_cpu2_dtb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M2933,-171.5C2933,-171.5 2963,-171.5 2963,-171.5 2969,-171.5 2975,-177.5 2975,-183.5 2975,-183.5 2975,-195.5 2975,-195.5 2975,-201.5 2969,-207.5 2963,-207.5 2963,-207.5 2933,-207.5 2933,-207.5 2927,-207.5 2921,-201.5 2921,-195.5 2921,-195.5 2921,-183.5 2921,-183.5 2921,-177.5 2927,-171.5 2933,-171.5"/>
-<text text-anchor="middle" x="2948" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu2_dtb_walker_cache_cpu_side -->
-<g id="node42" class="node">
-<title>system_cpu2_dtb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M2918,-40.5C2918,-40.5 2970,-40.5 2970,-40.5 2976,-40.5 2982,-46.5 2982,-52.5 2982,-52.5 2982,-64.5 2982,-64.5 2982,-70.5 2976,-76.5 2970,-76.5 2970,-76.5 2918,-76.5 2918,-76.5 2912,-76.5 2906,-70.5 2906,-64.5 2906,-64.5 2906,-52.5 2906,-52.5 2906,-46.5 2912,-40.5 2918,-40.5"/>
-<text text-anchor="middle" x="2944" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu2_dtb_walker_port&#45;&gt;system_cpu2_dtb_walker_cache_cpu_side -->
-<g id="edge12" class="edge">
-<title>system_cpu2_dtb_walker_port&#45;&gt;system_cpu2_dtb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M2947.4438,-171.285C2946.7751,-149.3856 2945.6454,-112.3861 2944.8631,-86.7663"/>
-<polygon fill="#000000" stroke="#000000" points="2948.3551,-86.4488 2944.5515,-76.5603 2941.3584,-86.6625 2948.3551,-86.4488"/>
-</g>
-<!-- system_cpu2_itb_walker_port -->
-<g id="node35" class="node">
-<title>system_cpu2_itb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M2748,-171.5C2748,-171.5 2778,-171.5 2778,-171.5 2784,-171.5 2790,-177.5 2790,-183.5 2790,-183.5 2790,-195.5 2790,-195.5 2790,-201.5 2784,-207.5 2778,-207.5 2778,-207.5 2748,-207.5 2748,-207.5 2742,-207.5 2736,-201.5 2736,-195.5 2736,-195.5 2736,-183.5 2736,-183.5 2736,-177.5 2742,-171.5 2748,-171.5"/>
-<text text-anchor="middle" x="2763" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu2_itb_walker_cache_cpu_side -->
-<g id="node40" class="node">
-<title>system_cpu2_itb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M2713,-40.5C2713,-40.5 2765,-40.5 2765,-40.5 2771,-40.5 2777,-46.5 2777,-52.5 2777,-52.5 2777,-64.5 2777,-64.5 2777,-70.5 2771,-76.5 2765,-76.5 2765,-76.5 2713,-76.5 2713,-76.5 2707,-76.5 2701,-70.5 2701,-64.5 2701,-64.5 2701,-52.5 2701,-52.5 2701,-46.5 2707,-40.5 2713,-40.5"/>
-<text text-anchor="middle" x="2739" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu2_itb_walker_port&#45;&gt;system_cpu2_itb_walker_cache_cpu_side -->
-<g id="edge13" class="edge">
-<title>system_cpu2_itb_walker_port&#45;&gt;system_cpu2_itb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M2759.6629,-171.285C2755.6329,-149.2878 2748.8117,-112.0554 2744.1158,-86.4238"/>
-<polygon fill="#000000" stroke="#000000" points="2747.5536,-85.7658 2742.3088,-76.5603 2740.6682,-87.0273 2747.5536,-85.7658"/>
-</g>
-<!-- system_cpu2_icache_mem_side -->
-<g id="node37" class="node">
-<title>system_cpu2_icache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M2402,-40.5C2402,-40.5 2462,-40.5 2462,-40.5 2468,-40.5 2474,-46.5 2474,-52.5 2474,-52.5 2474,-64.5 2474,-64.5 2474,-70.5 2468,-76.5 2462,-76.5 2462,-76.5 2402,-76.5 2402,-76.5 2396,-76.5 2390,-70.5 2390,-64.5 2390,-64.5 2390,-52.5 2390,-52.5 2390,-46.5 2396,-40.5 2402,-40.5"/>
-<text text-anchor="middle" x="2432" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu2_dcache_mem_side -->
-<g id="node39" class="node">
-<title>system_cpu2_dcache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M2200,-40.5C2200,-40.5 2260,-40.5 2260,-40.5 2266,-40.5 2272,-46.5 2272,-52.5 2272,-52.5 2272,-64.5 2272,-64.5 2272,-70.5 2266,-76.5 2260,-76.5 2260,-76.5 2200,-76.5 2200,-76.5 2194,-76.5 2188,-70.5 2188,-64.5 2188,-64.5 2188,-52.5 2188,-52.5 2188,-46.5 2194,-40.5 2200,-40.5"/>
-<text text-anchor="middle" x="2230" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu2_itb_walker_cache_mem_side -->
-<g id="node41" class="node">
-<title>system_cpu2_itb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M2611,-40.5C2611,-40.5 2671,-40.5 2671,-40.5 2677,-40.5 2683,-46.5 2683,-52.5 2683,-52.5 2683,-64.5 2683,-64.5 2683,-70.5 2677,-76.5 2671,-76.5 2671,-76.5 2611,-76.5 2611,-76.5 2605,-76.5 2599,-70.5 2599,-64.5 2599,-64.5 2599,-52.5 2599,-52.5 2599,-46.5 2605,-40.5 2611,-40.5"/>
-<text text-anchor="middle" x="2641" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu2_dtb_walker_cache_mem_side -->
-<g id="node43" class="node">
-<title>system_cpu2_dtb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M2816,-40.5C2816,-40.5 2876,-40.5 2876,-40.5 2882,-40.5 2888,-46.5 2888,-52.5 2888,-52.5 2888,-64.5 2888,-64.5 2888,-70.5 2882,-76.5 2876,-76.5 2876,-76.5 2816,-76.5 2816,-76.5 2810,-76.5 2804,-70.5 2804,-64.5 2804,-64.5 2804,-52.5 2804,-52.5 2804,-46.5 2810,-40.5 2816,-40.5"/>
-<text text-anchor="middle" x="2846" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu2_interrupts_int_requestor -->
-<g id="node44" class="node">
-<title>system_cpu2_interrupts_int_requestor</title>
-<path fill="#94918b" stroke="#000000" d="M2614.5,-171.5C2614.5,-171.5 2691.5,-171.5 2691.5,-171.5 2697.5,-171.5 2703.5,-177.5 2703.5,-183.5 2703.5,-183.5 2703.5,-195.5 2703.5,-195.5 2703.5,-201.5 2697.5,-207.5 2691.5,-207.5 2691.5,-207.5 2614.5,-207.5 2614.5,-207.5 2608.5,-207.5 2602.5,-201.5 2602.5,-195.5 2602.5,-195.5 2602.5,-183.5 2602.5,-183.5 2602.5,-177.5 2608.5,-171.5 2614.5,-171.5"/>
-<text text-anchor="middle" x="2653" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_requestor</text>
-</g>
-<!-- system_cpu2_interrupts_int_responder -->
-<g id="node45" class="node">
-<title>system_cpu2_interrupts_int_responder</title>
-<path fill="#94918b" stroke="#000000" d="M2490,-171.5C2490,-171.5 2572,-171.5 2572,-171.5 2578,-171.5 2584,-177.5 2584,-183.5 2584,-183.5 2584,-195.5 2584,-195.5 2584,-201.5 2578,-207.5 2572,-207.5 2572,-207.5 2490,-207.5 2490,-207.5 2484,-207.5 2478,-201.5 2478,-195.5 2478,-195.5 2478,-183.5 2478,-183.5 2478,-177.5 2484,-171.5 2490,-171.5"/>
-<text text-anchor="middle" x="2531" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_responder</text>
-</g>
-<!-- system_cpu2_interrupts_pio -->
-<g id="node46" class="node">
-<title>system_cpu2_interrupts_pio</title>
-<path fill="#94918b" stroke="#000000" d="M2418,-171.5C2418,-171.5 2448,-171.5 2448,-171.5 2454,-171.5 2460,-177.5 2460,-183.5 2460,-183.5 2460,-195.5 2460,-195.5 2460,-201.5 2454,-207.5 2448,-207.5 2448,-207.5 2418,-207.5 2418,-207.5 2412,-207.5 2406,-201.5 2406,-195.5 2406,-195.5 2406,-183.5 2406,-183.5 2406,-177.5 2412,-171.5 2418,-171.5"/>
-<text text-anchor="middle" x="2433" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">pio</text>
-</g>
-<!-- system_cpu3_icache_port -->
-<g id="node47" class="node">
-<title>system_cpu3_icache_port</title>
-<path fill="#959ead" stroke="#000000" d="M1086,-171.5C1086,-171.5 1154,-171.5 1154,-171.5 1160,-171.5 1166,-177.5 1166,-183.5 1166,-183.5 1166,-195.5 1166,-195.5 1166,-201.5 1160,-207.5 1154,-207.5 1154,-207.5 1086,-207.5 1086,-207.5 1080,-207.5 1074,-201.5 1074,-195.5 1074,-195.5 1074,-183.5 1074,-183.5 1074,-177.5 1080,-171.5 1086,-171.5"/>
-<text text-anchor="middle" x="1120" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">icache_port</text>
-</g>
-<!-- system_cpu3_icache_cpu_side -->
-<g id="node51" class="node">
-<title>system_cpu3_icache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M1233,-40.5C1233,-40.5 1285,-40.5 1285,-40.5 1291,-40.5 1297,-46.5 1297,-52.5 1297,-52.5 1297,-64.5 1297,-64.5 1297,-70.5 1291,-76.5 1285,-76.5 1285,-76.5 1233,-76.5 1233,-76.5 1227,-76.5 1221,-70.5 1221,-64.5 1221,-64.5 1221,-52.5 1221,-52.5 1221,-46.5 1227,-40.5 1233,-40.5"/>
-<text text-anchor="middle" x="1259" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu3_icache_port&#45;&gt;system_cpu3_icache_cpu_side -->
-<g id="edge14" class="edge">
-<title>system_cpu3_icache_port&#45;&gt;system_cpu3_icache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M1139.3274,-171.285C1163.4978,-148.5057 1205.0038,-109.3885 1232.2239,-83.735"/>
-<polygon fill="#000000" stroke="#000000" points="1234.9599,-85.966 1239.8368,-76.5603 1230.1589,-80.8718 1234.9599,-85.966"/>
-</g>
-<!-- system_cpu3_dcache_port -->
-<g id="node48" class="node">
-<title>system_cpu3_dcache_port</title>
-<path fill="#959ead" stroke="#000000" d="M970,-171.5C970,-171.5 1044,-171.5 1044,-171.5 1050,-171.5 1056,-177.5 1056,-183.5 1056,-183.5 1056,-195.5 1056,-195.5 1056,-201.5 1050,-207.5 1044,-207.5 1044,-207.5 970,-207.5 970,-207.5 964,-207.5 958,-201.5 958,-195.5 958,-195.5 958,-183.5 958,-183.5 958,-177.5 964,-171.5 970,-171.5"/>
-<text text-anchor="middle" x="1007" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">dcache_port</text>
-</g>
-<!-- system_cpu3_dcache_cpu_side -->
-<g id="node53" class="node">
-<title>system_cpu3_dcache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M1006,-40.5C1006,-40.5 1058,-40.5 1058,-40.5 1064,-40.5 1070,-46.5 1070,-52.5 1070,-52.5 1070,-64.5 1070,-64.5 1070,-70.5 1064,-76.5 1058,-76.5 1058,-76.5 1006,-76.5 1006,-76.5 1000,-76.5 994,-70.5 994,-64.5 994,-64.5 994,-52.5 994,-52.5 994,-46.5 1000,-40.5 1006,-40.5"/>
-<text text-anchor="middle" x="1032" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu3_dcache_port&#45;&gt;system_cpu3_dcache_cpu_side -->
-<g id="edge15" class="edge">
-<title>system_cpu3_dcache_port&#45;&gt;system_cpu3_dcache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M1010.4761,-171.285C1014.6741,-149.2878 1021.7795,-112.0554 1026.671,-86.4238"/>
-<polygon fill="#000000" stroke="#000000" points="1030.1167,-87.0391 1028.5534,-76.5603 1023.2408,-85.7269 1030.1167,-87.0391"/>
-</g>
-<!-- system_cpu3_dtb_walker_port -->
-<g id="node49" class="node">
-<title>system_cpu3_dtb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M1711,-171.5C1711,-171.5 1741,-171.5 1741,-171.5 1747,-171.5 1753,-177.5 1753,-183.5 1753,-183.5 1753,-195.5 1753,-195.5 1753,-201.5 1747,-207.5 1741,-207.5 1741,-207.5 1711,-207.5 1711,-207.5 1705,-207.5 1699,-201.5 1699,-195.5 1699,-195.5 1699,-183.5 1699,-183.5 1699,-177.5 1705,-171.5 1711,-171.5"/>
-<text text-anchor="middle" x="1726" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu3_dtb_walker_cache_cpu_side -->
-<g id="node57" class="node">
-<title>system_cpu3_dtb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M1686,-40.5C1686,-40.5 1738,-40.5 1738,-40.5 1744,-40.5 1750,-46.5 1750,-52.5 1750,-52.5 1750,-64.5 1750,-64.5 1750,-70.5 1744,-76.5 1738,-76.5 1738,-76.5 1686,-76.5 1686,-76.5 1680,-76.5 1674,-70.5 1674,-64.5 1674,-64.5 1674,-52.5 1674,-52.5 1674,-46.5 1680,-40.5 1686,-40.5"/>
-<text text-anchor="middle" x="1712" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu3_dtb_walker_port&#45;&gt;system_cpu3_dtb_walker_cache_cpu_side -->
-<g id="edge16" class="edge">
-<title>system_cpu3_dtb_walker_port&#45;&gt;system_cpu3_dtb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M1724.0534,-171.285C1721.713,-149.3856 1717.7588,-112.3861 1715.0208,-86.7663"/>
-<polygon fill="#000000" stroke="#000000" points="1718.473,-86.1317 1713.9301,-76.5603 1711.5127,-86.8756 1718.473,-86.1317"/>
-</g>
-<!-- system_cpu3_itb_walker_port -->
-<g id="node50" class="node">
-<title>system_cpu3_itb_walker_port</title>
-<path fill="#7f7c77" stroke="#000000" d="M1526,-171.5C1526,-171.5 1556,-171.5 1556,-171.5 1562,-171.5 1568,-177.5 1568,-183.5 1568,-183.5 1568,-195.5 1568,-195.5 1568,-201.5 1562,-207.5 1556,-207.5 1556,-207.5 1526,-207.5 1526,-207.5 1520,-207.5 1514,-201.5 1514,-195.5 1514,-195.5 1514,-183.5 1514,-183.5 1514,-177.5 1520,-171.5 1526,-171.5"/>
-<text text-anchor="middle" x="1541" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_cpu3_itb_walker_cache_cpu_side -->
-<g id="node55" class="node">
-<title>system_cpu3_itb_walker_cache_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M1484,-40.5C1484,-40.5 1536,-40.5 1536,-40.5 1542,-40.5 1548,-46.5 1548,-52.5 1548,-52.5 1548,-64.5 1548,-64.5 1548,-70.5 1542,-76.5 1536,-76.5 1536,-76.5 1484,-76.5 1484,-76.5 1478,-76.5 1472,-70.5 1472,-64.5 1472,-64.5 1472,-52.5 1472,-52.5 1472,-46.5 1478,-40.5 1484,-40.5"/>
-<text text-anchor="middle" x="1510" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_cpu3_itb_walker_port&#45;&gt;system_cpu3_itb_walker_cache_cpu_side -->
-<g id="edge17" class="edge">
-<title>system_cpu3_itb_walker_port&#45;&gt;system_cpu3_itb_walker_cache_cpu_side</title>
-<path fill="none" stroke="#000000" d="M1536.6896,-171.285C1531.4841,-149.2878 1522.6734,-112.0554 1516.6079,-86.4238"/>
-<polygon fill="#000000" stroke="#000000" points="1519.9826,-85.4855 1514.2738,-76.5603 1513.1708,-87.0975 1519.9826,-85.4855"/>
-</g>
-<!-- system_cpu3_icache_mem_side -->
-<g id="node52" class="node">
-<title>system_cpu3_icache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M1327,-40.5C1327,-40.5 1387,-40.5 1387,-40.5 1393,-40.5 1399,-46.5 1399,-52.5 1399,-52.5 1399,-64.5 1399,-64.5 1399,-70.5 1393,-76.5 1387,-76.5 1387,-76.5 1327,-76.5 1327,-76.5 1321,-76.5 1315,-70.5 1315,-64.5 1315,-64.5 1315,-52.5 1315,-52.5 1315,-46.5 1321,-40.5 1327,-40.5"/>
-<text text-anchor="middle" x="1357" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu3_dcache_mem_side -->
-<g id="node54" class="node">
-<title>system_cpu3_dcache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M1100,-40.5C1100,-40.5 1160,-40.5 1160,-40.5 1166,-40.5 1172,-46.5 1172,-52.5 1172,-52.5 1172,-64.5 1172,-64.5 1172,-70.5 1166,-76.5 1160,-76.5 1160,-76.5 1100,-76.5 1100,-76.5 1094,-76.5 1088,-70.5 1088,-64.5 1088,-64.5 1088,-52.5 1088,-52.5 1088,-46.5 1094,-40.5 1100,-40.5"/>
-<text text-anchor="middle" x="1130" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu3_itb_walker_cache_mem_side -->
-<g id="node56" class="node">
-<title>system_cpu3_itb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M1578,-40.5C1578,-40.5 1638,-40.5 1638,-40.5 1644,-40.5 1650,-46.5 1650,-52.5 1650,-52.5 1650,-64.5 1650,-64.5 1650,-70.5 1644,-76.5 1638,-76.5 1638,-76.5 1578,-76.5 1578,-76.5 1572,-76.5 1566,-70.5 1566,-64.5 1566,-64.5 1566,-52.5 1566,-52.5 1566,-46.5 1572,-40.5 1578,-40.5"/>
-<text text-anchor="middle" x="1608" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu3_dtb_walker_cache_mem_side -->
-<g id="node58" class="node">
-<title>system_cpu3_dtb_walker_cache_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M1780,-40.5C1780,-40.5 1840,-40.5 1840,-40.5 1846,-40.5 1852,-46.5 1852,-52.5 1852,-52.5 1852,-64.5 1852,-64.5 1852,-70.5 1846,-76.5 1840,-76.5 1840,-76.5 1780,-76.5 1780,-76.5 1774,-76.5 1768,-70.5 1768,-64.5 1768,-64.5 1768,-52.5 1768,-52.5 1768,-46.5 1774,-40.5 1780,-40.5"/>
-<text text-anchor="middle" x="1810" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_cpu3_interrupts_int_requestor -->
-<g id="node59" class="node">
-<title>system_cpu3_interrupts_int_requestor</title>
-<path fill="#94918b" stroke="#000000" d="M1392.5,-171.5C1392.5,-171.5 1469.5,-171.5 1469.5,-171.5 1475.5,-171.5 1481.5,-177.5 1481.5,-183.5 1481.5,-183.5 1481.5,-195.5 1481.5,-195.5 1481.5,-201.5 1475.5,-207.5 1469.5,-207.5 1469.5,-207.5 1392.5,-207.5 1392.5,-207.5 1386.5,-207.5 1380.5,-201.5 1380.5,-195.5 1380.5,-195.5 1380.5,-183.5 1380.5,-183.5 1380.5,-177.5 1386.5,-171.5 1392.5,-171.5"/>
-<text text-anchor="middle" x="1431" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_requestor</text>
-</g>
-<!-- system_cpu3_interrupts_int_responder -->
-<g id="node60" class="node">
-<title>system_cpu3_interrupts_int_responder</title>
-<path fill="#94918b" stroke="#000000" d="M1268,-171.5C1268,-171.5 1350,-171.5 1350,-171.5 1356,-171.5 1362,-177.5 1362,-183.5 1362,-183.5 1362,-195.5 1362,-195.5 1362,-201.5 1356,-207.5 1350,-207.5 1350,-207.5 1268,-207.5 1268,-207.5 1262,-207.5 1256,-201.5 1256,-195.5 1256,-195.5 1256,-183.5 1256,-183.5 1256,-177.5 1262,-171.5 1268,-171.5"/>
-<text text-anchor="middle" x="1309" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">int_responder</text>
-</g>
-<!-- system_cpu3_interrupts_pio -->
-<g id="node61" class="node">
-<title>system_cpu3_interrupts_pio</title>
-<path fill="#94918b" stroke="#000000" d="M1196,-171.5C1196,-171.5 1226,-171.5 1226,-171.5 1232,-171.5 1238,-177.5 1238,-183.5 1238,-183.5 1238,-195.5 1238,-195.5 1238,-201.5 1232,-207.5 1226,-207.5 1226,-207.5 1196,-207.5 1196,-207.5 1190,-207.5 1184,-201.5 1184,-195.5 1184,-195.5 1184,-183.5 1184,-183.5 1184,-177.5 1190,-171.5 1196,-171.5"/>
-<text text-anchor="middle" x="1211" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">pio</text>
-</g>
-<!-- system_membus_cpu_side_ports&#45;&gt;system_cpu0_interrupts_int_requestor -->
-<g id="edge19" class="edge">
-<title>system_membus_cpu_side_ports&#45;&gt;system_cpu0_interrupts_int_requestor</title>
-<path fill="none" stroke="#000000" d="M2292.3545,-379.7019C2556.0488,-376.4947 3493.7607,-363.8538 3519,-346 3564.7298,-313.6515 3575.6123,-241.4618 3578.1974,-207.6392"/>
-<polygon fill="#000000" stroke="#000000" points="2292.1075,-376.2045 2282.1506,-379.8253 2292.1922,-383.204 2292.1075,-376.2045"/>
-</g>
-<!-- system_membus_cpu_side_ports&#45;&gt;system_cpu1_interrupts_int_requestor -->
-<g id="edge20" class="edge">
-<title>system_membus_cpu_side_ports&#45;&gt;system_cpu1_interrupts_int_requestor</title>
-<path fill="none" stroke="#000000" d="M2175.7944,-359.007C2169.5726,-356.9572 2163.2061,-355.199 2157,-354 2135.4401,-349.8346 594.4278,-357.9414 576,-346 527.6765,-314.6858 511.8612,-241.6369 507.0036,-207.5796"/>
-<polygon fill="#000000" stroke="#000000" points="2174.8139,-362.3731 2185.4086,-362.4299 2177.1617,-355.7786 2174.8139,-362.3731"/>
-</g>
-<!-- system_membus_cpu_side_ports&#45;&gt;system_cpu2_interrupts_int_requestor -->
-<g id="edge21" class="edge">
-<title>system_membus_cpu_side_ports&#45;&gt;system_cpu2_interrupts_int_requestor</title>
-<path fill="none" stroke="#000000" d="M2292.0301,-377.9875C2392.0726,-373.719 2569.6139,-363.7398 2593,-346 2637.5117,-312.2351 2649.0058,-241.0863 2651.9709,-207.6222"/>
-<polygon fill="#000000" stroke="#000000" points="2291.8511,-374.4919 2282.0063,-378.4072 2292.144,-381.4857 2291.8511,-374.4919"/>
-</g>
-<!-- system_membus_cpu_side_ports&#45;&gt;system_cpu3_interrupts_int_requestor -->
-<g id="edge22" class="edge">
-<title>system_membus_cpu_side_ports&#45;&gt;system_cpu3_interrupts_int_requestor</title>
-<path fill="none" stroke="#000000" d="M2175.786,-359.0499C2169.5656,-356.9928 2163.2017,-355.2212 2157,-354 2139.147,-350.4845 1517.2345,-355.9497 1502,-346 1453.7888,-314.5132 1437.9164,-241.552 1433.024,-207.5483"/>
-<polygon fill="#000000" stroke="#000000" points="2174.8042,-362.4157 2185.3989,-362.4795 2177.1565,-355.8227 2174.8042,-362.4157"/>
-</g>
-<!-- system_l2_mem_side -->
-<g id="node65" class="node">
-<title>system_l2_mem_side</title>
-<path fill="#94918b" stroke="#000000" d="M1930,-40.5C1930,-40.5 1990,-40.5 1990,-40.5 1996,-40.5 2002,-46.5 2002,-52.5 2002,-52.5 2002,-64.5 2002,-64.5 2002,-70.5 1996,-76.5 1990,-76.5 1990,-76.5 1930,-76.5 1930,-76.5 1924,-76.5 1918,-70.5 1918,-64.5 1918,-64.5 1918,-52.5 1918,-52.5 1918,-46.5 1924,-40.5 1930,-40.5"/>
-<text text-anchor="middle" x="1960" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side</text>
-</g>
-<!-- system_membus_cpu_side_ports&#45;&gt;system_l2_mem_side -->
-<g id="edge18" class="edge">
-<title>system_membus_cpu_side_ports&#45;&gt;system_l2_mem_side</title>
-<path fill="none" stroke="#000000" d="M2175.5231,-359.0715C2169.3834,-357.031 2163.1107,-355.2576 2157,-354 2142.1383,-350.9414 1894.5708,-356.8851 1884,-346 1854.4301,-315.5509 1870.1035,-195.1051 1884,-155 1894.892,-123.566 1920.731,-94.6081 1939.2558,-76.7811"/>
-<polygon fill="#000000" stroke="#000000" points="2174.4247,-362.3957 2185.0194,-362.4622 2176.7786,-355.8033 2174.4247,-362.3957"/>
-</g>
-<!-- system_membus_mem_side_ports -->
-<g id="node63" class="node">
-<title>system_membus_mem_side_ports</title>
-<path fill="#586070" stroke="#000000" d="M2034.5,-362.5C2034.5,-362.5 2135.5,-362.5 2135.5,-362.5 2141.5,-362.5 2147.5,-368.5 2147.5,-374.5 2147.5,-374.5 2147.5,-386.5 2147.5,-386.5 2147.5,-392.5 2141.5,-398.5 2135.5,-398.5 2135.5,-398.5 2034.5,-398.5 2034.5,-398.5 2028.5,-398.5 2022.5,-392.5 2022.5,-386.5 2022.5,-386.5 2022.5,-374.5 2022.5,-374.5 2022.5,-368.5 2028.5,-362.5 2034.5,-362.5"/>
-<text text-anchor="middle" x="2085" y="-376.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side_ports</text>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu0_interrupts_int_responder -->
-<g id="edge24" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu0_interrupts_int_responder</title>
-<path fill="none" stroke="#000000" d="M2126.5759,-362.4368C2136.3741,-358.9591 2146.9087,-355.8318 2157,-354 2173.9183,-350.929 3380.8088,-355.7094 3395,-346 3437.2588,-317.0873 3450.7147,-254.446 3454.999,-217.786"/>
-<polygon fill="#000000" stroke="#000000" points="3458.4902,-218.0491 3456.0185,-207.7466 3451.5261,-217.3418 3458.4902,-218.0491"/>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu0_interrupts_pio -->
-<g id="edge23" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu0_interrupts_pio</title>
-<path fill="none" stroke="#000000" d="M2126.5764,-362.4396C2136.3746,-358.9617 2146.909,-355.8336 2157,-354 2173.0022,-351.0922 3315.467,-356.3658 3328,-346 3365.138,-315.2838 3366.1128,-254.0233 3362.9269,-217.9298"/>
-<polygon fill="#000000" stroke="#000000" points="3366.3671,-217.177 3361.84,-207.598 3359.4055,-217.9094 3366.3671,-217.177"/>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu1_interrupts_int_responder -->
-<g id="edge26" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu1_interrupts_int_responder</title>
-<path fill="none" stroke="#000000" d="M2022.1546,-380.1185C1725.5857,-378.2019 479.0024,-368.8002 446,-346 403.78,-316.8318 389.8413,-254.2847 385.2485,-217.7097"/>
-<polygon fill="#000000" stroke="#000000" points="388.7192,-217.2505 384.1434,-207.6948 381.7614,-218.0184 388.7192,-217.2505"/>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu1_interrupts_pio -->
-<g id="edge25" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu1_interrupts_pio</title>
-<path fill="none" stroke="#000000" d="M2022.4959,-380.3236C1712.6273,-379.3205 354.6961,-373.3674 321,-346 283.3443,-315.4167 280.2457,-254.1084 282.1242,-217.9707"/>
-<polygon fill="#000000" stroke="#000000" points="285.6412,-217.8417 282.8342,-207.6255 278.6576,-217.3624 285.6412,-217.8417"/>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu2_interrupts_int_responder -->
-<g id="edge28" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu2_interrupts_int_responder</title>
-<path fill="none" stroke="#000000" d="M2126.9844,-362.443C2136.6727,-359.0122 2147.0575,-355.9034 2157,-354 2174.0298,-350.7398 2454.7843,-355.9275 2469,-346 2510.9797,-316.6835 2524.5386,-254.1911 2528.9156,-217.6654"/>
-<polygon fill="#000000" stroke="#000000" points="2532.4023,-217.9746 2529.9619,-207.6647 2525.4403,-217.2462 2532.4023,-217.9746"/>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu2_interrupts_pio -->
-<g id="edge27" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu2_interrupts_pio</title>
-<path fill="none" stroke="#000000" d="M2126.9944,-362.4946C2136.6822,-359.0612 2147.0643,-355.9382 2157,-354 2170.3664,-351.3926 2391.6188,-354.8142 2402,-346 2438.6429,-314.8883 2439.8508,-254.0359 2436.8277,-218.0643"/>
-<polygon fill="#000000" stroke="#000000" points="2440.2743,-217.3582 2435.7882,-207.76 2433.3096,-218.0609 2440.2743,-217.3582"/>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu3_interrupts_int_responder -->
-<g id="edge30" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu3_interrupts_int_responder</title>
-<path fill="none" stroke="#000000" d="M2022.2752,-379.2921C1853.0843,-375.7919 1398.2736,-364.6864 1372,-346 1330.1821,-316.2581 1316.0952,-253.9226 1311.3687,-217.5383"/>
-<polygon fill="#000000" stroke="#000000" points="1314.843,-217.1138 1310.2249,-207.5784 1307.8887,-217.9125 1314.843,-217.1138"/>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_cpu3_interrupts_pio -->
-<g id="edge29" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_cpu3_interrupts_pio</title>
-<path fill="none" stroke="#000000" d="M2022.2102,-379.9805C1832.553,-378.1416 1276.7053,-370.6631 1247,-346 1209.6767,-315.0119 1206.4586,-253.8492 1208.2265,-217.8461"/>
-<polygon fill="#000000" stroke="#000000" points="1211.7403,-217.7496 1208.9029,-207.5418 1204.7553,-217.291 1211.7403,-217.7496"/>
-</g>
-<!-- system_mem_ctrls_port -->
-<g id="node68" class="node">
-<title>system_mem_ctrls_port</title>
-<path fill="#4b4746" stroke="#000000" d="M4044,-171.5C4044,-171.5 4074,-171.5 4074,-171.5 4080,-171.5 4086,-177.5 4086,-183.5 4086,-183.5 4086,-195.5 4086,-195.5 4086,-201.5 4080,-207.5 4074,-207.5 4074,-207.5 4044,-207.5 4044,-207.5 4038,-207.5 4032,-201.5 4032,-195.5 4032,-195.5 4032,-183.5 4032,-183.5 4032,-177.5 4038,-171.5 4044,-171.5"/>
-<text text-anchor="middle" x="4059" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">port</text>
-</g>
-<!-- system_membus_mem_side_ports&#45;&gt;system_mem_ctrls_port -->
-<g id="edge31" class="edge">
-<title>system_membus_mem_side_ports&#45;&gt;system_mem_ctrls_port</title>
-<path fill="none" stroke="#000000" d="M2126.5731,-362.421C2136.3714,-358.944 2146.9067,-355.821 2157,-354 2182.2454,-349.4452 3983.1005,-360.8758 4004,-346 4045.1078,-316.7404 4055.7094,-254.227 4058.3067,-217.6824"/>
-<polygon fill="#000000" stroke="#000000" points="4061.8024,-217.8553 4058.8635,-207.6762 4054.8132,-217.4663 4061.8024,-217.8553"/>
-</g>
-<!-- system_l2_cpu_side -->
-<g id="node64" class="node">
-<title>system_l2_cpu_side</title>
-<path fill="#94918b" stroke="#000000" d="M2032,-40.5C2032,-40.5 2084,-40.5 2084,-40.5 2090,-40.5 2096,-46.5 2096,-52.5 2096,-52.5 2096,-64.5 2096,-64.5 2096,-70.5 2090,-76.5 2084,-76.5 2084,-76.5 2032,-76.5 2032,-76.5 2026,-76.5 2020,-70.5 2020,-64.5 2020,-64.5 2020,-52.5 2020,-52.5 2020,-46.5 2026,-40.5 2032,-40.5"/>
-<text text-anchor="middle" x="2058" y="-54.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side</text>
-</g>
-<!-- system_tol2bus_cpu_side_ports -->
-<g id="node66" class="node">
-<title>system_tol2bus_cpu_side_ports</title>
-<path fill="#586070" stroke="#000000" d="M1908,-171.5C1908,-171.5 2000,-171.5 2000,-171.5 2006,-171.5 2012,-177.5 2012,-183.5 2012,-183.5 2012,-195.5 2012,-195.5 2012,-201.5 2006,-207.5 2000,-207.5 2000,-207.5 1908,-207.5 1908,-207.5 1902,-207.5 1896,-201.5 1896,-195.5 1896,-195.5 1896,-183.5 1896,-183.5 1896,-177.5 1902,-171.5 1908,-171.5"/>
-<text text-anchor="middle" x="1954" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">cpu_side_ports</text>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_icache_mem_side -->
-<g id="edge32" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_icache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1991.5505,-166.7351C2001.1542,-161.9684 2011.6895,-157.6024 2022,-155 2160.1562,-120.1297 3175.6571,-184.8963 3304,-123 3324.1262,-113.2937 3339.4837,-92.1505 3348.5837,-76.7081"/>
-<polygon fill="#000000" stroke="#000000" points="1989.9039,-163.6464 1982.6659,-171.3835 1993.149,-169.8488 1989.9039,-163.6464"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_dcache_mem_side -->
-<g id="edge33" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_dcache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1991.5652,-166.793C2001.1685,-162.0247 2011.6999,-157.6433 2022,-155 2231.3335,-101.2782 2782.4484,-167.1867 2994,-123 3039.6345,-113.4683 3088.9891,-92.0634 3121.074,-76.5194"/>
-<polygon fill="#000000" stroke="#000000" points="1989.9198,-163.7037 1982.6801,-171.4392 1993.1635,-169.9068 1989.9198,-163.7037"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_itb_walker_cache_mem_side -->
-<g id="edge34" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_itb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1991.5443,-166.7104C2001.1482,-161.9444 2011.6851,-157.5848 2022,-155 2181.9806,-114.9101 3355.2338,-189.862 3506,-123 3527.5565,-113.4401 3545.135,-92.2683 3555.7907,-76.7792"/>
-<polygon fill="#000000" stroke="#000000" points="1989.8972,-163.6219 1982.6599,-171.3597 1993.1429,-169.824 1989.8972,-163.6219"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_dtb_walker_cache_mem_side -->
-<g id="edge35" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu0_dtb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1991.5394,-166.691C2001.1435,-161.9255 2011.6816,-157.5711 2022,-155 2113.2812,-132.2546 3629.6084,-162.4701 3715,-123 3735.7543,-113.4068 3752.0608,-92.2415 3761.8226,-76.7631"/>
-<polygon fill="#000000" stroke="#000000" points="1989.892,-163.6028 1982.6553,-171.341 1993.1381,-169.8046 1989.892,-163.6028"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_icache_mem_side -->
-<g id="edge36" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_icache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1902.4186,-167.9372C1887.6802,-162.716 1871.4269,-157.8287 1856,-155 1711.4775,-128.5002 674.7192,-165.274 534,-123 502.8818,-113.6517 471.9293,-92.2094 452.2041,-76.6068"/>
-<polygon fill="#000000" stroke="#000000" points="1901.2676,-171.2429 1911.8613,-171.3982 1903.6766,-164.6705 1901.2676,-171.2429"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_dcache_mem_side -->
-<g id="edge37" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_dcache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1902.4257,-167.8982C1887.6873,-162.6767 1871.4323,-157.7989 1856,-155 1683.9922,-123.8036 447.064,-183.3566 283,-123 257.4095,-113.5857 234.0193,-92.1569 219.4427,-76.5753"/>
-<polygon fill="#000000" stroke="#000000" points="1901.2744,-171.2039 1911.8681,-171.3608 1903.6845,-164.6318 1901.2744,-171.2039"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_itb_walker_cache_mem_side -->
-<g id="edge38" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_itb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1902.4105,-167.9812C1887.672,-162.7605 1871.4207,-157.8623 1856,-155 1733.5955,-132.2797 848.038,-177.2822 736,-123 715.8913,-113.2574 700.5304,-92.1213 691.4248,-76.6905"/>
-<polygon fill="#000000" stroke="#000000" points="1901.2598,-171.287 1911.8535,-171.4404 1903.6676,-164.7142 1901.2598,-171.287"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_dtb_walker_cache_mem_side -->
-<g id="edge39" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu1_dtb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1901.5595,-167.7671C1887.0438,-162.6574 1871.1183,-157.8691 1856,-155 1665.0556,-118.7636 1167.1271,-182.1676 982,-123 952.1218,-113.4508 922.7268,-92.0494 904.0459,-76.5111"/>
-<polygon fill="#000000" stroke="#000000" points="1900.7623,-171.2016 1911.3563,-171.3363 1903.1585,-164.6245 1900.7623,-171.2016"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_icache_mem_side -->
-<g id="edge40" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_icache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1992.5139,-166.7894C2001.8856,-162.1652 2012.0752,-157.8494 2022,-155 2174.6918,-111.1623 2237.2176,-196.5993 2378,-123 2397.6723,-112.7155 2413.0209,-91.9051 2422.2449,-76.694"/>
-<polygon fill="#000000" stroke="#000000" points="1990.7303,-163.7714 1983.455,-171.4734 1993.9454,-169.9894 1990.7303,-163.7714"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_dcache_mem_side -->
-<g id="edge41" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_dcache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1996.9717,-166.7752C2005.201,-162.687 2013.8066,-158.5891 2022,-155 2059.3557,-138.6366 2070.7832,-139.677 2108,-123 2139.4838,-108.892 2174.1499,-90.2473 2198.4565,-76.6335"/>
-<polygon fill="#000000" stroke="#000000" points="1995.2352,-163.731 1987.8824,-171.3591 1998.3873,-169.9812 1995.2352,-163.731"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_itb_walker_cache_mem_side -->
-<g id="edge42" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_itb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1992.1788,-166.6891C2001.627,-162.0233 2011.9346,-157.7143 2022,-155 2141.92,-122.6619 2467.3781,-175.3725 2580,-123 2601.3823,-113.0566 2618.9948,-91.9597 2629.7061,-76.593"/>
-<polygon fill="#000000" stroke="#000000" points="1990.3179,-163.7117 1983.0578,-171.428 1993.5452,-169.9233 1990.3179,-163.7117"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_dtb_walker_cache_mem_side -->
-<g id="edge43" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu2_dtb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1992.1488,-166.5762C2001.5982,-161.9146 2011.9137,-157.6358 2022,-155 2187.0503,-111.869 2634.9751,-196.3364 2789,-123 2809.6436,-113.1709 2825.9717,-92.0517 2835.7688,-76.6485"/>
-<polygon fill="#000000" stroke="#000000" points="1990.2861,-163.5998 1983.0287,-171.3187 1993.5157,-169.8103 1990.2861,-163.5998"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_icache_mem_side -->
-<g id="edge44" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_icache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1900.6394,-167.9183C1886.3491,-162.9143 1870.7648,-158.1402 1856,-155 1683.2894,-118.2671 1627.6071,-178.5529 1460,-123 1429.5585,-112.9102 1398.9547,-92.0633 1379.1132,-76.7904"/>
-<polygon fill="#000000" stroke="#000000" points="1899.7055,-171.3021 1910.2999,-171.4021 1902.0802,-164.7172 1899.7055,-171.3021"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_dcache_mem_side -->
-<g id="edge45" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_dcache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1901.5345,-167.8962C1887.0189,-162.7865 1871.0996,-157.9659 1856,-155 1714.7457,-127.2542 1343.3644,-174.6606 1209,-123 1183.7144,-113.2782 1160.4347,-92.138 1145.7951,-76.7006"/>
-<polygon fill="#000000" stroke="#000000" points="1900.7382,-171.3309 1911.3323,-171.4607 1903.1314,-164.7527 1900.7382,-171.3309"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_itb_walker_cache_mem_side -->
-<g id="edge46" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_itb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1898.3762,-168.0231C1884.6654,-163.2573 1869.9191,-158.5687 1856,-155 1771.3507,-133.2967 1737.896,-166.3168 1662,-123 1642.8475,-112.0689 1627.5015,-91.5925 1618.135,-76.6344"/>
-<polygon fill="#000000" stroke="#000000" points="1897.5554,-171.4456 1908.1501,-171.4921 1899.8968,-164.8488 1897.5554,-171.4456"/>
-</g>
-<!-- system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_dtb_walker_cache_mem_side -->
-<g id="edge47" class="edge">
-<title>system_tol2bus_cpu_side_ports&#45;&gt;system_cpu3_dtb_walker_cache_mem_side</title>
-<path fill="none" stroke="#000000" d="M1926.4318,-164.4206C1898.1718,-138.7119 1854.9179,-99.3628 1829.8525,-76.5603"/>
-<polygon fill="#000000" stroke="#000000" points="1924.2251,-167.1447 1933.9774,-171.285 1928.9356,-161.9667 1924.2251,-167.1447"/>
-</g>
-<!-- system_tol2bus_mem_side_ports -->
-<g id="node67" class="node">
-<title>system_tol2bus_mem_side_ports</title>
-<path fill="#586070" stroke="#000000" d="M2042.5,-171.5C2042.5,-171.5 2143.5,-171.5 2143.5,-171.5 2149.5,-171.5 2155.5,-177.5 2155.5,-183.5 2155.5,-183.5 2155.5,-195.5 2155.5,-195.5 2155.5,-201.5 2149.5,-207.5 2143.5,-207.5 2143.5,-207.5 2042.5,-207.5 2042.5,-207.5 2036.5,-207.5 2030.5,-201.5 2030.5,-195.5 2030.5,-195.5 2030.5,-183.5 2030.5,-183.5 2030.5,-177.5 2036.5,-171.5 2042.5,-171.5"/>
-<text text-anchor="middle" x="2093" y="-185.8" font-family="Arial" font-size="14.00" fill="#000000">mem_side_ports</text>
-</g>
-<!-- system_tol2bus_mem_side_ports&#45;&gt;system_l2_cpu_side -->
-<g id="edge48" class="edge">
-<title>system_tol2bus_mem_side_ports&#45;&gt;system_l2_cpu_side</title>
-<path fill="none" stroke="#000000" d="M2088.1334,-171.285C2082.2563,-149.2878 2072.3087,-112.0554 2065.4606,-86.4238"/>
-<polygon fill="#000000" stroke="#000000" points="2068.788,-85.318 2062.8253,-76.5603 2062.0252,-87.1249 2068.788,-85.318"/>
-</g>
-</g>
-</svg>
diff --git a/m5out_default_DDR4/config.ini b/m5out_default_DDR4/config.ini
deleted file mode 100644
index 292596a39..000000000
--- a/m5out_default_DDR4/config.ini
+++ /dev/null
@@ -1,2138 +0,0 @@
-[root]
-type=Root
-children=system
-eventq_index=0
-full_system=false
-sim_quantum=0
-time_sync_enable=false
-time_sync_period=100000000000
-time_sync_spin_threshold=100000000
-
-[system]
-type=System
-children=clk_domain cpu0 cpu1 cpu2 cpu3 cpu_clk_domain cpu_voltage_domain dvfs_handler l2 mem_ctrls membus redirect_paths0 redirect_paths1 redirect_paths2 tol2bus voltage_domain
-byte_order=little
-cache_line_size=64
-eventq_index=0
-exit_on_work_items=false
-init_param=0
-kvm_vm=Null
-m5ops_base=4294901760
-mem_mode=timing
-mem_ranges=0:1073741824
-memories=system.mem_ctrls
-mmap_using_noreserve=false
-multi_thread=false
-num_work_ids=16
-readfile=
-redirect_paths=system.redirect_paths0 system.redirect_paths1 system.redirect_paths2
-shared_backstore=
-symbolfile=
-thermal_components=
-thermal_model=Null
-work_begin_ckpt_count=0
-work_begin_cpu_id_exit=-1
-work_begin_exit_count=0
-work_cpus_ckpt_count=0
-work_end_ckpt_count=0
-work_end_exit_count=0
-work_item_id=-1
-workload=Null
-system_port=system.membus.cpu_side_ports[0]
-
-[system.clk_domain]
-type=SrcClockDomain
-clock=1000
-domain_id=-1
-eventq_index=0
-init_perf_level=0
-voltage_domain=system.voltage_domain
-
-[system.cpu0]
-type=TimingSimpleCPU
-children=dcache dtb dtb_walker_cache icache interrupts isa itb itb_walker_cache power_state tracer workload
-branchPred=Null
-checker=Null
-clk_domain=system.cpu_clk_domain
-cpu_id=0
-do_checkpoint_insts=true
-do_statistics_insts=true
-dtb=system.cpu0.dtb
-eventq_index=0
-function_trace=false
-function_trace_start=0
-interrupts=system.cpu0.interrupts
-isa=system.cpu0.isa
-itb=system.cpu0.itb
-max_insts_all_threads=0
-max_insts_any_thread=0
-numThreads=1
-power_gating_on_idle=false
-power_model=
-power_state=system.cpu0.power_state
-progress_interval=0
-pwr_gating_latency=300
-simpoint_start_insts=
-socket_id=0
-switched_out=false
-syscallRetryLatency=10000
-system=system
-tracer=system.cpu0.tracer
-wait_for_remote_gdb=false
-workload=system.cpu0.workload
-dcache_port=system.cpu0.dcache.cpu_side
-icache_port=system.cpu0.icache.cpu_side
-
-[system.cpu0.dcache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu0.dcache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu0.dcache.replacement_policy
-response_latency=2
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-tags=system.cpu0.dcache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu0.dcache_port
-mem_side=system.tol2bus.cpu_side_ports[1]
-
-[system.cpu0.dcache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.dcache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu0.dcache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu0.dcache.tags.indexing_policy
-power_model=
-power_state=system.cpu0.dcache.tags.power_state
-replacement_policy=system.cpu0.dcache.replacement_policy
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu0.dcache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=65536
-
-[system.cpu0.dcache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.dtb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu0.dtb.walker
-
-[system.cpu0.dtb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu0.dtb.walker.power_state
-system=system
-port=system.cpu0.dtb_walker_cache.cpu_side
-
-[system.cpu0.dtb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.dtb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu0.dtb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu0.dtb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu0.dtb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu0.dtb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[3]
-
-[system.cpu0.dtb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.dtb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu0.dtb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu0.dtb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu0.dtb_walker_cache.tags.power_state
-replacement_policy=system.cpu0.dtb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu0.dtb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu0.dtb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.icache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=true
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu0.icache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu0.icache.replacement_policy
-response_latency=2
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-tags=system.cpu0.icache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=true
-cpu_side=system.cpu0.icache_port
-mem_side=system.tol2bus.cpu_side_ports[0]
-
-[system.cpu0.icache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.icache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu0.icache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu0.icache.tags.indexing_policy
-power_model=
-power_state=system.cpu0.icache.tags.power_state
-replacement_policy=system.cpu0.icache.replacement_policy
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu0.icache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=32768
-
-[system.cpu0.icache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.interrupts]
-type=X86LocalApic
-children=clk_domain
-clk_domain=system.cpu0.interrupts.clk_domain
-eventq_index=0
-int_latency=1000
-pio_latency=100000
-system=system
-int_requestor=system.membus.cpu_side_ports[2]
-int_responder=system.membus.mem_side_ports[1]
-pio=system.membus.mem_side_ports[0]
-
-[system.cpu0.interrupts.clk_domain]
-type=DerivedClockDomain
-clk_divider=16
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-
-[system.cpu0.isa]
-type=X86ISA
-eventq_index=0
-
-[system.cpu0.itb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu0.itb.walker
-
-[system.cpu0.itb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu0.itb.walker.power_state
-system=system
-port=system.cpu0.itb_walker_cache.cpu_side
-
-[system.cpu0.itb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.itb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu0.itb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu0.itb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu0.itb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu0.itb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[2]
-
-[system.cpu0.itb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.itb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu0.itb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu0.itb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu0.itb_walker_cache.tags.power_state
-replacement_policy=system.cpu0.itb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu0.itb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu0.itb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu0.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=ON CLK_GATED OFF
-
-[system.cpu0.tracer]
-type=ExeTracer
-eventq_index=0
-
-[system.cpu0.workload]
-type=Process
-cmd=main.out
-cwd=/usr/local/src/gem5_v20.1
-drivers=
-egid=100
-env=
-errout=cerr
-euid=100
-eventq_index=0
-executable=main.out
-gid=100
-input=cin
-kvmInSE=false
-maxStackSize=67108864
-output=cout
-pgid=100
-pid=100
-ppid=0
-release=5.1.0
-simpoint=0
-system=system
-uid=100
-useArchPT=false
-
-[system.cpu1]
-type=TimingSimpleCPU
-children=dcache dtb dtb_walker_cache icache interrupts isa itb itb_walker_cache power_state tracer
-branchPred=Null
-checker=Null
-clk_domain=system.cpu_clk_domain
-cpu_id=1
-do_checkpoint_insts=true
-do_statistics_insts=true
-dtb=system.cpu1.dtb
-eventq_index=0
-function_trace=false
-function_trace_start=0
-interrupts=system.cpu1.interrupts
-isa=system.cpu1.isa
-itb=system.cpu1.itb
-max_insts_all_threads=0
-max_insts_any_thread=0
-numThreads=1
-power_gating_on_idle=false
-power_model=
-power_state=system.cpu1.power_state
-progress_interval=0
-pwr_gating_latency=300
-simpoint_start_insts=
-socket_id=0
-switched_out=false
-syscallRetryLatency=10000
-system=system
-tracer=system.cpu1.tracer
-wait_for_remote_gdb=false
-workload=system.cpu0.workload
-dcache_port=system.cpu1.dcache.cpu_side
-icache_port=system.cpu1.icache.cpu_side
-
-[system.cpu1.dcache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu1.dcache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu1.dcache.replacement_policy
-response_latency=2
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-tags=system.cpu1.dcache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu1.dcache_port
-mem_side=system.tol2bus.cpu_side_ports[5]
-
-[system.cpu1.dcache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.dcache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu1.dcache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu1.dcache.tags.indexing_policy
-power_model=
-power_state=system.cpu1.dcache.tags.power_state
-replacement_policy=system.cpu1.dcache.replacement_policy
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu1.dcache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=65536
-
-[system.cpu1.dcache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.dtb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu1.dtb.walker
-
-[system.cpu1.dtb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu1.dtb.walker.power_state
-system=system
-port=system.cpu1.dtb_walker_cache.cpu_side
-
-[system.cpu1.dtb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.dtb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu1.dtb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu1.dtb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu1.dtb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu1.dtb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[7]
-
-[system.cpu1.dtb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.dtb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu1.dtb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu1.dtb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu1.dtb_walker_cache.tags.power_state
-replacement_policy=system.cpu1.dtb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu1.dtb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu1.dtb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.icache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=true
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu1.icache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu1.icache.replacement_policy
-response_latency=2
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-tags=system.cpu1.icache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=true
-cpu_side=system.cpu1.icache_port
-mem_side=system.tol2bus.cpu_side_ports[4]
-
-[system.cpu1.icache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.icache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu1.icache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu1.icache.tags.indexing_policy
-power_model=
-power_state=system.cpu1.icache.tags.power_state
-replacement_policy=system.cpu1.icache.replacement_policy
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu1.icache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=32768
-
-[system.cpu1.icache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.interrupts]
-type=X86LocalApic
-children=clk_domain
-clk_domain=system.cpu1.interrupts.clk_domain
-eventq_index=0
-int_latency=1000
-pio_latency=100000
-system=system
-int_requestor=system.membus.cpu_side_ports[3]
-int_responder=system.membus.mem_side_ports[3]
-pio=system.membus.mem_side_ports[2]
-
-[system.cpu1.interrupts.clk_domain]
-type=DerivedClockDomain
-clk_divider=16
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-
-[system.cpu1.isa]
-type=X86ISA
-eventq_index=0
-
-[system.cpu1.itb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu1.itb.walker
-
-[system.cpu1.itb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu1.itb.walker.power_state
-system=system
-port=system.cpu1.itb_walker_cache.cpu_side
-
-[system.cpu1.itb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.itb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu1.itb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu1.itb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu1.itb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu1.itb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[6]
-
-[system.cpu1.itb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.itb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu1.itb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu1.itb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu1.itb_walker_cache.tags.power_state
-replacement_policy=system.cpu1.itb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu1.itb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu1.itb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu1.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=ON CLK_GATED OFF
-
-[system.cpu1.tracer]
-type=ExeTracer
-eventq_index=0
-
-[system.cpu2]
-type=TimingSimpleCPU
-children=dcache dtb dtb_walker_cache icache interrupts isa itb itb_walker_cache power_state tracer
-branchPred=Null
-checker=Null
-clk_domain=system.cpu_clk_domain
-cpu_id=2
-do_checkpoint_insts=true
-do_statistics_insts=true
-dtb=system.cpu2.dtb
-eventq_index=0
-function_trace=false
-function_trace_start=0
-interrupts=system.cpu2.interrupts
-isa=system.cpu2.isa
-itb=system.cpu2.itb
-max_insts_all_threads=0
-max_insts_any_thread=0
-numThreads=1
-power_gating_on_idle=false
-power_model=
-power_state=system.cpu2.power_state
-progress_interval=0
-pwr_gating_latency=300
-simpoint_start_insts=
-socket_id=0
-switched_out=false
-syscallRetryLatency=10000
-system=system
-tracer=system.cpu2.tracer
-wait_for_remote_gdb=false
-workload=system.cpu0.workload
-dcache_port=system.cpu2.dcache.cpu_side
-icache_port=system.cpu2.icache.cpu_side
-
-[system.cpu2.dcache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu2.dcache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu2.dcache.replacement_policy
-response_latency=2
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-tags=system.cpu2.dcache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu2.dcache_port
-mem_side=system.tol2bus.cpu_side_ports[9]
-
-[system.cpu2.dcache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.dcache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu2.dcache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu2.dcache.tags.indexing_policy
-power_model=
-power_state=system.cpu2.dcache.tags.power_state
-replacement_policy=system.cpu2.dcache.replacement_policy
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu2.dcache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=65536
-
-[system.cpu2.dcache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.dtb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu2.dtb.walker
-
-[system.cpu2.dtb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu2.dtb.walker.power_state
-system=system
-port=system.cpu2.dtb_walker_cache.cpu_side
-
-[system.cpu2.dtb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.dtb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu2.dtb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu2.dtb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu2.dtb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu2.dtb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[11]
-
-[system.cpu2.dtb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.dtb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu2.dtb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu2.dtb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu2.dtb_walker_cache.tags.power_state
-replacement_policy=system.cpu2.dtb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu2.dtb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu2.dtb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.icache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=true
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu2.icache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu2.icache.replacement_policy
-response_latency=2
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-tags=system.cpu2.icache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=true
-cpu_side=system.cpu2.icache_port
-mem_side=system.tol2bus.cpu_side_ports[8]
-
-[system.cpu2.icache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.icache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu2.icache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu2.icache.tags.indexing_policy
-power_model=
-power_state=system.cpu2.icache.tags.power_state
-replacement_policy=system.cpu2.icache.replacement_policy
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu2.icache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=32768
-
-[system.cpu2.icache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.interrupts]
-type=X86LocalApic
-children=clk_domain
-clk_domain=system.cpu2.interrupts.clk_domain
-eventq_index=0
-int_latency=1000
-pio_latency=100000
-system=system
-int_requestor=system.membus.cpu_side_ports[4]
-int_responder=system.membus.mem_side_ports[5]
-pio=system.membus.mem_side_ports[4]
-
-[system.cpu2.interrupts.clk_domain]
-type=DerivedClockDomain
-clk_divider=16
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-
-[system.cpu2.isa]
-type=X86ISA
-eventq_index=0
-
-[system.cpu2.itb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu2.itb.walker
-
-[system.cpu2.itb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu2.itb.walker.power_state
-system=system
-port=system.cpu2.itb_walker_cache.cpu_side
-
-[system.cpu2.itb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.itb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu2.itb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu2.itb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu2.itb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu2.itb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[10]
-
-[system.cpu2.itb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.itb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu2.itb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu2.itb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu2.itb_walker_cache.tags.power_state
-replacement_policy=system.cpu2.itb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu2.itb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu2.itb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu2.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=ON CLK_GATED OFF
-
-[system.cpu2.tracer]
-type=ExeTracer
-eventq_index=0
-
-[system.cpu3]
-type=TimingSimpleCPU
-children=dcache dtb dtb_walker_cache icache interrupts isa itb itb_walker_cache power_state tracer
-branchPred=Null
-checker=Null
-clk_domain=system.cpu_clk_domain
-cpu_id=3
-do_checkpoint_insts=true
-do_statistics_insts=true
-dtb=system.cpu3.dtb
-eventq_index=0
-function_trace=false
-function_trace_start=0
-interrupts=system.cpu3.interrupts
-isa=system.cpu3.isa
-itb=system.cpu3.itb
-max_insts_all_threads=0
-max_insts_any_thread=0
-numThreads=1
-power_gating_on_idle=false
-power_model=
-power_state=system.cpu3.power_state
-progress_interval=0
-pwr_gating_latency=300
-simpoint_start_insts=
-socket_id=0
-switched_out=false
-syscallRetryLatency=10000
-system=system
-tracer=system.cpu3.tracer
-wait_for_remote_gdb=false
-workload=system.cpu0.workload
-dcache_port=system.cpu3.dcache.cpu_side
-icache_port=system.cpu3.icache.cpu_side
-
-[system.cpu3.dcache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu3.dcache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu3.dcache.replacement_policy
-response_latency=2
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-tags=system.cpu3.dcache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu3.dcache_port
-mem_side=system.tol2bus.cpu_side_ports[13]
-
-[system.cpu3.dcache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.dcache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu3.dcache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu3.dcache.tags.indexing_policy
-power_model=
-power_state=system.cpu3.dcache.tags.power_state
-replacement_policy=system.cpu3.dcache.replacement_policy
-sequential_access=false
-size=65536
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu3.dcache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=65536
-
-[system.cpu3.dcache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.dtb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu3.dtb.walker
-
-[system.cpu3.dtb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu3.dtb.walker.power_state
-system=system
-port=system.cpu3.dtb_walker_cache.cpu_side
-
-[system.cpu3.dtb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.dtb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu3.dtb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu3.dtb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu3.dtb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu3.dtb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[15]
-
-[system.cpu3.dtb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.dtb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu3.dtb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu3.dtb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu3.dtb_walker_cache.tags.power_state
-replacement_policy=system.cpu3.dtb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu3.dtb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu3.dtb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.icache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=true
-max_miss_count=0
-mshrs=4
-power_model=
-power_state=system.cpu3.icache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu3.icache.replacement_policy
-response_latency=2
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-tags=system.cpu3.icache.tags
-tgts_per_mshr=20
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=true
-cpu_side=system.cpu3.icache_port
-mem_side=system.tol2bus.cpu_side_ports[12]
-
-[system.cpu3.icache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.icache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu3.icache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu3.icache.tags.indexing_policy
-power_model=
-power_state=system.cpu3.icache.tags.power_state
-replacement_policy=system.cpu3.icache.replacement_policy
-sequential_access=false
-size=32768
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu3.icache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=32768
-
-[system.cpu3.icache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.interrupts]
-type=X86LocalApic
-children=clk_domain
-clk_domain=system.cpu3.interrupts.clk_domain
-eventq_index=0
-int_latency=1000
-pio_latency=100000
-system=system
-int_requestor=system.membus.cpu_side_ports[5]
-int_responder=system.membus.mem_side_ports[7]
-pio=system.membus.mem_side_ports[6]
-
-[system.cpu3.interrupts.clk_domain]
-type=DerivedClockDomain
-clk_divider=16
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-
-[system.cpu3.isa]
-type=X86ISA
-eventq_index=0
-
-[system.cpu3.itb]
-type=X86TLB
-children=walker
-eventq_index=0
-size=64
-system=system
-walker=system.cpu3.itb.walker
-
-[system.cpu3.itb.walker]
-type=X86PagetableWalker
-children=power_state
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-num_squash_per_cycle=4
-power_model=
-power_state=system.cpu3.itb.walker.power_state
-system=system
-port=system.cpu3.itb_walker_cache.cpu_side
-
-[system.cpu3.itb.walker.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.itb_walker_cache]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=2
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=2
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=10
-power_model=
-power_state=system.cpu3.itb_walker_cache.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.cpu3.itb_walker_cache.replacement_policy
-response_latency=2
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-tags=system.cpu3.itb_walker_cache.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.cpu3.itb.walker.port
-mem_side=system.tol2bus.cpu_side_ports[14]
-
-[system.cpu3.itb_walker_cache.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.itb_walker_cache.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.cpu3.itb_walker_cache.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=2
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.cpu3.itb_walker_cache.tags.indexing_policy
-power_model=
-power_state=system.cpu3.itb_walker_cache.tags.power_state
-replacement_policy=system.cpu3.itb_walker_cache.replacement_policy
-sequential_access=false
-size=1024
-system=system
-tag_latency=2
-warmup_percentage=0
-
-[system.cpu3.itb_walker_cache.tags.indexing_policy]
-type=SetAssociative
-assoc=2
-entry_size=64
-eventq_index=0
-size=1024
-
-[system.cpu3.itb_walker_cache.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.cpu3.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=ON CLK_GATED OFF
-
-[system.cpu3.tracer]
-type=ExeTracer
-eventq_index=0
-
-[system.cpu_clk_domain]
-type=SrcClockDomain
-clock=500
-domain_id=-1
-eventq_index=0
-init_perf_level=0
-voltage_domain=system.cpu_voltage_domain
-
-[system.cpu_voltage_domain]
-type=VoltageDomain
-eventq_index=0
-voltage=1.0
-
-[system.dvfs_handler]
-type=DVFSHandler
-domains=
-enable=false
-eventq_index=0
-sys_clk_domain=system.clk_domain
-transition_latency=100000000
-
-[system.l2]
-type=Cache
-children=power_state replacement_policy tags
-addr_ranges=0:18446744073709551615
-assoc=8
-clk_domain=system.cpu_clk_domain
-clusivity=mostly_incl
-compressor=Null
-data_latency=20
-demand_mshr_reserve=1
-eventq_index=0
-is_read_only=false
-max_miss_count=0
-mshrs=20
-power_model=
-power_state=system.l2.power_state
-prefetch_on_access=false
-prefetcher=Null
-replacement_policy=system.l2.replacement_policy
-response_latency=20
-sequential_access=false
-size=2097152
-system=system
-tag_latency=20
-tags=system.l2.tags
-tgts_per_mshr=12
-warmup_percentage=0
-write_allocator=Null
-write_buffers=8
-writeback_clean=false
-cpu_side=system.tol2bus.mem_side_ports[0]
-mem_side=system.membus.cpu_side_ports[1]
-
-[system.l2.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.l2.replacement_policy]
-type=LRURP
-eventq_index=0
-
-[system.l2.tags]
-type=BaseSetAssoc
-children=indexing_policy power_state
-assoc=8
-block_size=64
-clk_domain=system.cpu_clk_domain
-entry_size=64
-eventq_index=0
-indexing_policy=system.l2.tags.indexing_policy
-power_model=
-power_state=system.l2.tags.power_state
-replacement_policy=system.l2.replacement_policy
-sequential_access=false
-size=2097152
-system=system
-tag_latency=20
-warmup_percentage=0
-
-[system.l2.tags.indexing_policy]
-type=SetAssociative
-assoc=8
-entry_size=64
-eventq_index=0
-size=2097152
-
-[system.l2.tags.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.mem_ctrls]
-type=Ramulator
-children=power_state
-clk_domain=system.clk_domain
-conf_table_reported=true
-config_file=ramulator_configs/DDR4-config.cfg
-eventq_index=0
-image_file=
-in_addr_map=true
-kvm_map=true
-null=false
-num_cpus=4
-output_dir=m5out/
-power_model=
-power_state=system.mem_ctrls.power_state
-range=0:1073741824
-real_warm_up=100
-port=system.membus.mem_side_ports[8]
-
-[system.mem_ctrls.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.membus]
-type=CoherentXBar
-children=power_state snoop_filter
-clk_domain=system.clk_domain
-eventq_index=0
-forward_latency=4
-frontend_latency=3
-header_latency=1
-max_outstanding_snoops=512
-max_routing_table_size=512
-point_of_coherency=true
-point_of_unification=true
-power_model=
-power_state=system.membus.power_state
-response_latency=2
-snoop_filter=system.membus.snoop_filter
-snoop_response_latency=4
-system=system
-use_default_range=false
-width=16
-cpu_side_ports=system.system_port system.l2.mem_side system.cpu0.interrupts.int_requestor system.cpu1.interrupts.int_requestor system.cpu2.interrupts.int_requestor system.cpu3.interrupts.int_requestor
-mem_side_ports=system.cpu0.interrupts.pio system.cpu0.interrupts.int_responder system.cpu1.interrupts.pio system.cpu1.interrupts.int_responder system.cpu2.interrupts.pio system.cpu2.interrupts.int_responder system.cpu3.interrupts.pio system.cpu3.interrupts.int_responder system.mem_ctrls.port
-
-[system.membus.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.membus.snoop_filter]
-type=SnoopFilter
-eventq_index=0
-lookup_latency=1
-max_capacity=8388608
-system=system
-
-[system.redirect_paths0]
-type=RedirectPath
-app_path=/proc
-eventq_index=0
-host_paths=m5out/fs/proc
-
-[system.redirect_paths1]
-type=RedirectPath
-app_path=/sys
-eventq_index=0
-host_paths=m5out/fs/sys
-
-[system.redirect_paths2]
-type=RedirectPath
-app_path=/tmp
-eventq_index=0
-host_paths=m5out/fs/tmp
-
-[system.tol2bus]
-type=CoherentXBar
-children=power_state snoop_filter
-clk_domain=system.cpu_clk_domain
-eventq_index=0
-forward_latency=0
-frontend_latency=1
-header_latency=1
-max_outstanding_snoops=512
-max_routing_table_size=512
-point_of_coherency=false
-point_of_unification=true
-power_model=
-power_state=system.tol2bus.power_state
-response_latency=1
-snoop_filter=system.tol2bus.snoop_filter
-snoop_response_latency=1
-system=system
-use_default_range=false
-width=32
-cpu_side_ports=system.cpu0.icache.mem_side system.cpu0.dcache.mem_side system.cpu0.itb_walker_cache.mem_side system.cpu0.dtb_walker_cache.mem_side system.cpu1.icache.mem_side system.cpu1.dcache.mem_side system.cpu1.itb_walker_cache.mem_side system.cpu1.dtb_walker_cache.mem_side system.cpu2.icache.mem_side system.cpu2.dcache.mem_side system.cpu2.itb_walker_cache.mem_side system.cpu2.dtb_walker_cache.mem_side system.cpu3.icache.mem_side system.cpu3.dcache.mem_side system.cpu3.itb_walker_cache.mem_side system.cpu3.dtb_walker_cache.mem_side
-mem_side_ports=system.l2.cpu_side
-
-[system.tol2bus.power_state]
-type=PowerState
-clk_gate_bins=20
-clk_gate_max=1000000000000
-clk_gate_min=1000
-default_state=UNDEFINED
-eventq_index=0
-leaders=
-possible_states=
-
-[system.tol2bus.snoop_filter]
-type=SnoopFilter
-eventq_index=0
-lookup_latency=0
-max_capacity=8388608
-system=system
-
-[system.voltage_domain]
-type=VoltageDomain
-eventq_index=0
-voltage=1.0
-
diff --git a/m5out_default_DDR4/config.json b/m5out_default_DDR4/config.json
deleted file mode 100644
index ce1cdfc52..000000000
--- a/m5out_default_DDR4/config.json
+++ /dev/null
@@ -1,2854 +0,0 @@
-{
-    "type": "Root",
-    "cxx_class": "Root",
-    "name": null,
-    "path": "root",
-    "eventq_index": 0,
-    "full_system": false,
-    "sim_quantum": 0,
-    "time_sync_enable": false,
-    "time_sync_period": 100000000000,
-    "time_sync_spin_threshold": 100000000,
-    "system": {
-        "type": "System",
-        "cxx_class": "System",
-        "name": "system",
-        "path": "system",
-        "byte_order": "little",
-        "cache_line_size": 64,
-        "eventq_index": 0,
-        "exit_on_work_items": false,
-        "init_param": 0,
-        "kvm_vm": null,
-        "m5ops_base": 4294901760,
-        "mem_mode": "timing",
-        "mem_ranges": [
-            "0:1073741824"
-        ],
-        "memories": [
-            "system.mem_ctrls"
-        ],
-        "mmap_using_noreserve": false,
-        "multi_thread": false,
-        "num_work_ids": 16,
-        "readfile": "",
-        "redirect_paths": [
-            {
-                "type": "RedirectPath",
-                "cxx_class": "RedirectPath",
-                "name": "redirect_paths0",
-                "path": "system.redirect_paths0",
-                "app_path": "/proc",
-                "eventq_index": 0,
-                "host_paths": [
-                    "m5out/fs/proc"
-                ]
-            },
-            {
-                "type": "RedirectPath",
-                "cxx_class": "RedirectPath",
-                "name": "redirect_paths1",
-                "path": "system.redirect_paths1",
-                "app_path": "/sys",
-                "eventq_index": 0,
-                "host_paths": [
-                    "m5out/fs/sys"
-                ]
-            },
-            {
-                "type": "RedirectPath",
-                "cxx_class": "RedirectPath",
-                "name": "redirect_paths2",
-                "path": "system.redirect_paths2",
-                "app_path": "/tmp",
-                "eventq_index": 0,
-                "host_paths": [
-                    "m5out/fs/tmp"
-                ]
-            }
-        ],
-        "shared_backstore": "",
-        "symbolfile": "",
-        "thermal_components": [],
-        "thermal_model": null,
-        "work_begin_ckpt_count": 0,
-        "work_begin_cpu_id_exit": -1,
-        "work_begin_exit_count": 0,
-        "work_cpus_ckpt_count": 0,
-        "work_end_ckpt_count": 0,
-        "work_end_exit_count": 0,
-        "work_item_id": -1,
-        "workload": null,
-        "clk_domain": {
-            "type": "SrcClockDomain",
-            "cxx_class": "SrcClockDomain",
-            "name": "clk_domain",
-            "path": "system.clk_domain",
-            "clock": [
-                1000
-            ],
-            "domain_id": -1,
-            "eventq_index": 0,
-            "init_perf_level": 0,
-            "voltage_domain": "system.voltage_domain"
-        },
-        "cpu": [
-            {
-                "type": "TimingSimpleCPU",
-                "cxx_class": "TimingSimpleCPU",
-                "name": "cpu0",
-                "path": "system.cpu0",
-                "branchPred": null,
-                "checker": null,
-                "clk_domain": "system.cpu_clk_domain",
-                "cpu_id": 0,
-                "do_checkpoint_insts": true,
-                "do_statistics_insts": true,
-                "dtb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "dtb",
-                    "path": "system.cpu0.dtb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu0.dtb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu0.dtb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu0.dtb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "eventq_index": 0,
-                "function_trace": false,
-                "function_trace_start": 0,
-                "interrupts": [
-                    {
-                        "type": "X86LocalApic",
-                        "cxx_class": "X86ISA::Interrupts",
-                        "name": "interrupts",
-                        "path": "system.cpu0.interrupts",
-                        "clk_domain": {
-                            "type": "DerivedClockDomain",
-                            "cxx_class": "DerivedClockDomain",
-                            "name": "clk_domain",
-                            "path": "system.cpu0.interrupts.clk_domain",
-                            "clk_divider": 16,
-                            "clk_domain": "system.cpu_clk_domain",
-                            "eventq_index": 0
-                        },
-                        "eventq_index": 0,
-                        "int_latency": 1000,
-                        "pio_latency": 100000,
-                        "system": "system",
-                        "int_requestor": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.membus.cpu_side_ports[2]",
-                            "is_source": "True"
-                        },
-                        "int_responder": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[1]",
-                            "is_source": "False"
-                        },
-                        "pio": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[0]",
-                            "is_source": "False"
-                        }
-                    }
-                ],
-                "isa": [
-                    {
-                        "type": "X86ISA",
-                        "cxx_class": "X86ISA::ISA",
-                        "name": "isa",
-                        "path": "system.cpu0.isa",
-                        "eventq_index": 0
-                    }
-                ],
-                "itb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "itb",
-                    "path": "system.cpu0.itb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu0.itb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu0.itb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu0.itb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "max_insts_all_threads": 0,
-                "max_insts_any_thread": 0,
-                "numThreads": 1,
-                "power_gating_on_idle": false,
-                "power_model": [],
-                "power_state": {
-                    "type": "PowerState",
-                    "cxx_class": "PowerState",
-                    "name": "power_state",
-                    "path": "system.cpu0.power_state",
-                    "clk_gate_bins": 20,
-                    "clk_gate_max": 1000000000000,
-                    "clk_gate_min": 1000,
-                    "default_state": "UNDEFINED",
-                    "eventq_index": 0,
-                    "leaders": [],
-                    "possible_states": [
-                        "ON",
-                        "CLK_GATED",
-                        "OFF"
-                    ]
-                },
-                "progress_interval": 0,
-                "pwr_gating_latency": 300,
-                "simpoint_start_insts": [],
-                "socket_id": 0,
-                "switched_out": false,
-                "syscallRetryLatency": 10000,
-                "system": "system",
-                "tracer": {
-                    "type": "ExeTracer",
-                    "cxx_class": "Trace::ExeTracer",
-                    "name": "tracer",
-                    "path": "system.cpu0.tracer",
-                    "eventq_index": 0
-                },
-                "wait_for_remote_gdb": false,
-                "workload": [
-                    {
-                        "type": "Process",
-                        "cxx_class": "Process",
-                        "name": "workload",
-                        "path": "system.cpu0.workload",
-                        "cmd": [
-                            "main.out"
-                        ],
-                        "cwd": "/usr/local/src/gem5_v20.1",
-                        "drivers": [],
-                        "egid": 100,
-                        "env": [],
-                        "errout": "cerr",
-                        "euid": 100,
-                        "eventq_index": 0,
-                        "executable": "main.out",
-                        "gid": 100,
-                        "input": "cin",
-                        "kvmInSE": false,
-                        "maxStackSize": 67108864,
-                        "output": "cout",
-                        "pgid": 100,
-                        "pid": 100,
-                        "ppid": 0,
-                        "release": "5.1.0",
-                        "simpoint": 0,
-                        "system": "system",
-                        "uid": 100,
-                        "useArchPT": false
-                    }
-                ],
-                "dcache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dcache",
-                    "path": "system.cpu0.dcache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu0.dcache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu0.dcache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 65536,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu0.dcache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu0.dcache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 65536
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu0.dcache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu0.dcache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 65536,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu0.dcache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[1]",
-                        "is_source": "True"
-                    }
-                },
-                "dtb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dtb_walker_cache",
-                    "path": "system.cpu0.dtb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu0.dtb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu0.dtb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu0.dtb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu0.dtb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu0.dtb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu0.dtb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu0.dtb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[3]",
-                        "is_source": "True"
-                    }
-                },
-                "icache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "icache",
-                    "path": "system.cpu0.icache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": true,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu0.icache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu0.icache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 32768,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu0.icache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu0.icache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 32768
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu0.icache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu0.icache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 32768,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": true,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu0.icache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[0]",
-                        "is_source": "True"
-                    }
-                },
-                "itb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "itb_walker_cache",
-                    "path": "system.cpu0.itb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu0.itb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu0.itb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu0.itb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu0.itb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu0.itb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu0.itb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu0.itb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[2]",
-                        "is_source": "True"
-                    }
-                },
-                "dcache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu0.dcache.cpu_side",
-                    "is_source": "True"
-                },
-                "icache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu0.icache.cpu_side",
-                    "is_source": "True"
-                }
-            },
-            {
-                "type": "TimingSimpleCPU",
-                "cxx_class": "TimingSimpleCPU",
-                "name": "cpu1",
-                "path": "system.cpu1",
-                "branchPred": null,
-                "checker": null,
-                "clk_domain": "system.cpu_clk_domain",
-                "cpu_id": 1,
-                "do_checkpoint_insts": true,
-                "do_statistics_insts": true,
-                "dtb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "dtb",
-                    "path": "system.cpu1.dtb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu1.dtb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu1.dtb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu1.dtb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "eventq_index": 0,
-                "function_trace": false,
-                "function_trace_start": 0,
-                "interrupts": [
-                    {
-                        "type": "X86LocalApic",
-                        "cxx_class": "X86ISA::Interrupts",
-                        "name": "interrupts",
-                        "path": "system.cpu1.interrupts",
-                        "clk_domain": {
-                            "type": "DerivedClockDomain",
-                            "cxx_class": "DerivedClockDomain",
-                            "name": "clk_domain",
-                            "path": "system.cpu1.interrupts.clk_domain",
-                            "clk_divider": 16,
-                            "clk_domain": "system.cpu_clk_domain",
-                            "eventq_index": 0
-                        },
-                        "eventq_index": 0,
-                        "int_latency": 1000,
-                        "pio_latency": 100000,
-                        "system": "system",
-                        "int_requestor": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.membus.cpu_side_ports[3]",
-                            "is_source": "True"
-                        },
-                        "int_responder": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[3]",
-                            "is_source": "False"
-                        },
-                        "pio": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[2]",
-                            "is_source": "False"
-                        }
-                    }
-                ],
-                "isa": [
-                    {
-                        "type": "X86ISA",
-                        "cxx_class": "X86ISA::ISA",
-                        "name": "isa",
-                        "path": "system.cpu1.isa",
-                        "eventq_index": 0
-                    }
-                ],
-                "itb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "itb",
-                    "path": "system.cpu1.itb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu1.itb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu1.itb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu1.itb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "max_insts_all_threads": 0,
-                "max_insts_any_thread": 0,
-                "numThreads": 1,
-                "power_gating_on_idle": false,
-                "power_model": [],
-                "power_state": {
-                    "type": "PowerState",
-                    "cxx_class": "PowerState",
-                    "name": "power_state",
-                    "path": "system.cpu1.power_state",
-                    "clk_gate_bins": 20,
-                    "clk_gate_max": 1000000000000,
-                    "clk_gate_min": 1000,
-                    "default_state": "UNDEFINED",
-                    "eventq_index": 0,
-                    "leaders": [],
-                    "possible_states": [
-                        "ON",
-                        "CLK_GATED",
-                        "OFF"
-                    ]
-                },
-                "progress_interval": 0,
-                "pwr_gating_latency": 300,
-                "simpoint_start_insts": [],
-                "socket_id": 0,
-                "switched_out": false,
-                "syscallRetryLatency": 10000,
-                "system": "system",
-                "tracer": {
-                    "type": "ExeTracer",
-                    "cxx_class": "Trace::ExeTracer",
-                    "name": "tracer",
-                    "path": "system.cpu1.tracer",
-                    "eventq_index": 0
-                },
-                "wait_for_remote_gdb": false,
-                "workload": [
-                    "system.cpu0.workload"
-                ],
-                "dcache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dcache",
-                    "path": "system.cpu1.dcache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu1.dcache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu1.dcache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 65536,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu1.dcache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu1.dcache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 65536
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu1.dcache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu1.dcache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 65536,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu1.dcache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[5]",
-                        "is_source": "True"
-                    }
-                },
-                "dtb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dtb_walker_cache",
-                    "path": "system.cpu1.dtb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu1.dtb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu1.dtb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu1.dtb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu1.dtb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu1.dtb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu1.dtb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu1.dtb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[7]",
-                        "is_source": "True"
-                    }
-                },
-                "icache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "icache",
-                    "path": "system.cpu1.icache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": true,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu1.icache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu1.icache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 32768,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu1.icache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu1.icache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 32768
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu1.icache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu1.icache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 32768,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": true,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu1.icache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[4]",
-                        "is_source": "True"
-                    }
-                },
-                "itb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "itb_walker_cache",
-                    "path": "system.cpu1.itb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu1.itb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu1.itb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu1.itb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu1.itb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu1.itb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu1.itb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu1.itb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[6]",
-                        "is_source": "True"
-                    }
-                },
-                "dcache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu1.dcache.cpu_side",
-                    "is_source": "True"
-                },
-                "icache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu1.icache.cpu_side",
-                    "is_source": "True"
-                }
-            },
-            {
-                "type": "TimingSimpleCPU",
-                "cxx_class": "TimingSimpleCPU",
-                "name": "cpu2",
-                "path": "system.cpu2",
-                "branchPred": null,
-                "checker": null,
-                "clk_domain": "system.cpu_clk_domain",
-                "cpu_id": 2,
-                "do_checkpoint_insts": true,
-                "do_statistics_insts": true,
-                "dtb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "dtb",
-                    "path": "system.cpu2.dtb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu2.dtb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu2.dtb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu2.dtb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "eventq_index": 0,
-                "function_trace": false,
-                "function_trace_start": 0,
-                "interrupts": [
-                    {
-                        "type": "X86LocalApic",
-                        "cxx_class": "X86ISA::Interrupts",
-                        "name": "interrupts",
-                        "path": "system.cpu2.interrupts",
-                        "clk_domain": {
-                            "type": "DerivedClockDomain",
-                            "cxx_class": "DerivedClockDomain",
-                            "name": "clk_domain",
-                            "path": "system.cpu2.interrupts.clk_domain",
-                            "clk_divider": 16,
-                            "clk_domain": "system.cpu_clk_domain",
-                            "eventq_index": 0
-                        },
-                        "eventq_index": 0,
-                        "int_latency": 1000,
-                        "pio_latency": 100000,
-                        "system": "system",
-                        "int_requestor": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.membus.cpu_side_ports[4]",
-                            "is_source": "True"
-                        },
-                        "int_responder": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[5]",
-                            "is_source": "False"
-                        },
-                        "pio": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[4]",
-                            "is_source": "False"
-                        }
-                    }
-                ],
-                "isa": [
-                    {
-                        "type": "X86ISA",
-                        "cxx_class": "X86ISA::ISA",
-                        "name": "isa",
-                        "path": "system.cpu2.isa",
-                        "eventq_index": 0
-                    }
-                ],
-                "itb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "itb",
-                    "path": "system.cpu2.itb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu2.itb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu2.itb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu2.itb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "max_insts_all_threads": 0,
-                "max_insts_any_thread": 0,
-                "numThreads": 1,
-                "power_gating_on_idle": false,
-                "power_model": [],
-                "power_state": {
-                    "type": "PowerState",
-                    "cxx_class": "PowerState",
-                    "name": "power_state",
-                    "path": "system.cpu2.power_state",
-                    "clk_gate_bins": 20,
-                    "clk_gate_max": 1000000000000,
-                    "clk_gate_min": 1000,
-                    "default_state": "UNDEFINED",
-                    "eventq_index": 0,
-                    "leaders": [],
-                    "possible_states": [
-                        "ON",
-                        "CLK_GATED",
-                        "OFF"
-                    ]
-                },
-                "progress_interval": 0,
-                "pwr_gating_latency": 300,
-                "simpoint_start_insts": [],
-                "socket_id": 0,
-                "switched_out": false,
-                "syscallRetryLatency": 10000,
-                "system": "system",
-                "tracer": {
-                    "type": "ExeTracer",
-                    "cxx_class": "Trace::ExeTracer",
-                    "name": "tracer",
-                    "path": "system.cpu2.tracer",
-                    "eventq_index": 0
-                },
-                "wait_for_remote_gdb": false,
-                "workload": [
-                    "system.cpu0.workload"
-                ],
-                "dcache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dcache",
-                    "path": "system.cpu2.dcache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu2.dcache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu2.dcache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 65536,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu2.dcache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu2.dcache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 65536
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu2.dcache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu2.dcache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 65536,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu2.dcache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[9]",
-                        "is_source": "True"
-                    }
-                },
-                "dtb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dtb_walker_cache",
-                    "path": "system.cpu2.dtb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu2.dtb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu2.dtb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu2.dtb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu2.dtb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu2.dtb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu2.dtb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu2.dtb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[11]",
-                        "is_source": "True"
-                    }
-                },
-                "icache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "icache",
-                    "path": "system.cpu2.icache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": true,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu2.icache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu2.icache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 32768,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu2.icache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu2.icache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 32768
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu2.icache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu2.icache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 32768,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": true,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu2.icache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[8]",
-                        "is_source": "True"
-                    }
-                },
-                "itb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "itb_walker_cache",
-                    "path": "system.cpu2.itb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu2.itb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu2.itb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu2.itb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu2.itb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu2.itb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu2.itb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu2.itb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[10]",
-                        "is_source": "True"
-                    }
-                },
-                "dcache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu2.dcache.cpu_side",
-                    "is_source": "True"
-                },
-                "icache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu2.icache.cpu_side",
-                    "is_source": "True"
-                }
-            },
-            {
-                "type": "TimingSimpleCPU",
-                "cxx_class": "TimingSimpleCPU",
-                "name": "cpu3",
-                "path": "system.cpu3",
-                "branchPred": null,
-                "checker": null,
-                "clk_domain": "system.cpu_clk_domain",
-                "cpu_id": 3,
-                "do_checkpoint_insts": true,
-                "do_statistics_insts": true,
-                "dtb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "dtb",
-                    "path": "system.cpu3.dtb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu3.dtb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu3.dtb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu3.dtb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "eventq_index": 0,
-                "function_trace": false,
-                "function_trace_start": 0,
-                "interrupts": [
-                    {
-                        "type": "X86LocalApic",
-                        "cxx_class": "X86ISA::Interrupts",
-                        "name": "interrupts",
-                        "path": "system.cpu3.interrupts",
-                        "clk_domain": {
-                            "type": "DerivedClockDomain",
-                            "cxx_class": "DerivedClockDomain",
-                            "name": "clk_domain",
-                            "path": "system.cpu3.interrupts.clk_domain",
-                            "clk_divider": 16,
-                            "clk_domain": "system.cpu_clk_domain",
-                            "eventq_index": 0
-                        },
-                        "eventq_index": 0,
-                        "int_latency": 1000,
-                        "pio_latency": 100000,
-                        "system": "system",
-                        "int_requestor": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.membus.cpu_side_ports[5]",
-                            "is_source": "True"
-                        },
-                        "int_responder": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[7]",
-                            "is_source": "False"
-                        },
-                        "pio": {
-                            "role": "GEM5 RESPONDER",
-                            "peer": "system.membus.mem_side_ports[6]",
-                            "is_source": "False"
-                        }
-                    }
-                ],
-                "isa": [
-                    {
-                        "type": "X86ISA",
-                        "cxx_class": "X86ISA::ISA",
-                        "name": "isa",
-                        "path": "system.cpu3.isa",
-                        "eventq_index": 0
-                    }
-                ],
-                "itb": {
-                    "type": "X86TLB",
-                    "cxx_class": "X86ISA::TLB",
-                    "name": "itb",
-                    "path": "system.cpu3.itb",
-                    "eventq_index": 0,
-                    "size": 64,
-                    "system": "system",
-                    "walker": {
-                        "type": "X86PagetableWalker",
-                        "cxx_class": "X86ISA::Walker",
-                        "name": "walker",
-                        "path": "system.cpu3.itb.walker",
-                        "clk_domain": "system.cpu_clk_domain",
-                        "eventq_index": 0,
-                        "num_squash_per_cycle": 4,
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu3.itb.walker.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "system": "system",
-                        "port": {
-                            "role": "GEM5 REQUESTOR",
-                            "peer": "system.cpu3.itb_walker_cache.cpu_side",
-                            "is_source": "True"
-                        }
-                    }
-                },
-                "max_insts_all_threads": 0,
-                "max_insts_any_thread": 0,
-                "numThreads": 1,
-                "power_gating_on_idle": false,
-                "power_model": [],
-                "power_state": {
-                    "type": "PowerState",
-                    "cxx_class": "PowerState",
-                    "name": "power_state",
-                    "path": "system.cpu3.power_state",
-                    "clk_gate_bins": 20,
-                    "clk_gate_max": 1000000000000,
-                    "clk_gate_min": 1000,
-                    "default_state": "UNDEFINED",
-                    "eventq_index": 0,
-                    "leaders": [],
-                    "possible_states": [
-                        "ON",
-                        "CLK_GATED",
-                        "OFF"
-                    ]
-                },
-                "progress_interval": 0,
-                "pwr_gating_latency": 300,
-                "simpoint_start_insts": [],
-                "socket_id": 0,
-                "switched_out": false,
-                "syscallRetryLatency": 10000,
-                "system": "system",
-                "tracer": {
-                    "type": "ExeTracer",
-                    "cxx_class": "Trace::ExeTracer",
-                    "name": "tracer",
-                    "path": "system.cpu3.tracer",
-                    "eventq_index": 0
-                },
-                "wait_for_remote_gdb": false,
-                "workload": [
-                    "system.cpu0.workload"
-                ],
-                "dcache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dcache",
-                    "path": "system.cpu3.dcache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu3.dcache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu3.dcache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 65536,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu3.dcache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu3.dcache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 65536
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu3.dcache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu3.dcache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 65536,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu3.dcache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[13]",
-                        "is_source": "True"
-                    }
-                },
-                "dtb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "dtb_walker_cache",
-                    "path": "system.cpu3.dtb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu3.dtb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu3.dtb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu3.dtb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu3.dtb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu3.dtb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu3.dtb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu3.dtb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[15]",
-                        "is_source": "True"
-                    }
-                },
-                "icache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "icache",
-                    "path": "system.cpu3.icache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": true,
-                    "max_miss_count": 0,
-                    "mshrs": 4,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu3.icache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu3.icache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 32768,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu3.icache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu3.icache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 32768
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu3.icache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu3.icache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 32768,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 20,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": true,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu3.icache_port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[12]",
-                        "is_source": "True"
-                    }
-                },
-                "itb_walker_cache": {
-                    "type": "Cache",
-                    "cxx_class": "Cache",
-                    "name": "itb_walker_cache",
-                    "path": "system.cpu3.itb_walker_cache",
-                    "addr_ranges": [
-                        "0:18446744073709551615"
-                    ],
-                    "assoc": 2,
-                    "clk_domain": "system.cpu_clk_domain",
-                    "clusivity": "mostly_incl",
-                    "compressor": null,
-                    "data_latency": 2,
-                    "demand_mshr_reserve": 1,
-                    "eventq_index": 0,
-                    "is_read_only": false,
-                    "max_miss_count": 0,
-                    "mshrs": 10,
-                    "power_model": [],
-                    "power_state": {
-                        "type": "PowerState",
-                        "cxx_class": "PowerState",
-                        "name": "power_state",
-                        "path": "system.cpu3.itb_walker_cache.power_state",
-                        "clk_gate_bins": 20,
-                        "clk_gate_max": 1000000000000,
-                        "clk_gate_min": 1000,
-                        "default_state": "UNDEFINED",
-                        "eventq_index": 0,
-                        "leaders": [],
-                        "possible_states": []
-                    },
-                    "prefetch_on_access": false,
-                    "prefetcher": null,
-                    "replacement_policy": {
-                        "type": "LRURP",
-                        "cxx_class": "LRURP",
-                        "name": "replacement_policy",
-                        "path": "system.cpu3.itb_walker_cache.replacement_policy",
-                        "eventq_index": 0
-                    },
-                    "response_latency": 2,
-                    "sequential_access": false,
-                    "size": 1024,
-                    "system": "system",
-                    "tag_latency": 2,
-                    "tags": {
-                        "type": "BaseSetAssoc",
-                        "cxx_class": "BaseSetAssoc",
-                        "name": "tags",
-                        "path": "system.cpu3.itb_walker_cache.tags",
-                        "assoc": 2,
-                        "block_size": 64,
-                        "clk_domain": "system.cpu_clk_domain",
-                        "entry_size": 64,
-                        "eventq_index": 0,
-                        "indexing_policy": {
-                            "type": "SetAssociative",
-                            "cxx_class": "SetAssociative",
-                            "name": "indexing_policy",
-                            "path": "system.cpu3.itb_walker_cache.tags.indexing_policy",
-                            "assoc": 2,
-                            "entry_size": 64,
-                            "eventq_index": 0,
-                            "size": 1024
-                        },
-                        "power_model": [],
-                        "power_state": {
-                            "type": "PowerState",
-                            "cxx_class": "PowerState",
-                            "name": "power_state",
-                            "path": "system.cpu3.itb_walker_cache.tags.power_state",
-                            "clk_gate_bins": 20,
-                            "clk_gate_max": 1000000000000,
-                            "clk_gate_min": 1000,
-                            "default_state": "UNDEFINED",
-                            "eventq_index": 0,
-                            "leaders": [],
-                            "possible_states": []
-                        },
-                        "replacement_policy": "system.cpu3.itb_walker_cache.replacement_policy",
-                        "sequential_access": false,
-                        "size": 1024,
-                        "system": "system",
-                        "tag_latency": 2,
-                        "warmup_percentage": 0
-                    },
-                    "tgts_per_mshr": 12,
-                    "warmup_percentage": 0,
-                    "write_allocator": null,
-                    "write_buffers": 8,
-                    "writeback_clean": false,
-                    "cpu_side": {
-                        "role": "GEM5 RESPONDER",
-                        "peer": "system.cpu3.itb.walker.port",
-                        "is_source": "False"
-                    },
-                    "mem_side": {
-                        "role": "GEM5 REQUESTOR",
-                        "peer": "system.tol2bus.cpu_side_ports[14]",
-                        "is_source": "True"
-                    }
-                },
-                "dcache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu3.dcache.cpu_side",
-                    "is_source": "True"
-                },
-                "icache_port": {
-                    "role": "GEM5 REQUESTOR",
-                    "peer": "system.cpu3.icache.cpu_side",
-                    "is_source": "True"
-                }
-            }
-        ],
-        "cpu_clk_domain": {
-            "type": "SrcClockDomain",
-            "cxx_class": "SrcClockDomain",
-            "name": "cpu_clk_domain",
-            "path": "system.cpu_clk_domain",
-            "clock": [
-                500
-            ],
-            "domain_id": -1,
-            "eventq_index": 0,
-            "init_perf_level": 0,
-            "voltage_domain": "system.cpu_voltage_domain"
-        },
-        "cpu_voltage_domain": {
-            "type": "VoltageDomain",
-            "cxx_class": "VoltageDomain",
-            "name": "cpu_voltage_domain",
-            "path": "system.cpu_voltage_domain",
-            "eventq_index": 0,
-            "voltage": [
-                1.0
-            ]
-        },
-        "dvfs_handler": {
-            "type": "DVFSHandler",
-            "cxx_class": "DVFSHandler",
-            "name": "dvfs_handler",
-            "path": "system.dvfs_handler",
-            "domains": [],
-            "enable": false,
-            "eventq_index": 0,
-            "sys_clk_domain": "system.clk_domain",
-            "transition_latency": 100000000
-        },
-        "l2": {
-            "type": "Cache",
-            "cxx_class": "Cache",
-            "name": "l2",
-            "path": "system.l2",
-            "addr_ranges": [
-                "0:18446744073709551615"
-            ],
-            "assoc": 8,
-            "clk_domain": "system.cpu_clk_domain",
-            "clusivity": "mostly_incl",
-            "compressor": null,
-            "data_latency": 20,
-            "demand_mshr_reserve": 1,
-            "eventq_index": 0,
-            "is_read_only": false,
-            "max_miss_count": 0,
-            "mshrs": 20,
-            "power_model": [],
-            "power_state": {
-                "type": "PowerState",
-                "cxx_class": "PowerState",
-                "name": "power_state",
-                "path": "system.l2.power_state",
-                "clk_gate_bins": 20,
-                "clk_gate_max": 1000000000000,
-                "clk_gate_min": 1000,
-                "default_state": "UNDEFINED",
-                "eventq_index": 0,
-                "leaders": [],
-                "possible_states": []
-            },
-            "prefetch_on_access": false,
-            "prefetcher": null,
-            "replacement_policy": {
-                "type": "LRURP",
-                "cxx_class": "LRURP",
-                "name": "replacement_policy",
-                "path": "system.l2.replacement_policy",
-                "eventq_index": 0
-            },
-            "response_latency": 20,
-            "sequential_access": false,
-            "size": 2097152,
-            "system": "system",
-            "tag_latency": 20,
-            "tags": {
-                "type": "BaseSetAssoc",
-                "cxx_class": "BaseSetAssoc",
-                "name": "tags",
-                "path": "system.l2.tags",
-                "assoc": 8,
-                "block_size": 64,
-                "clk_domain": "system.cpu_clk_domain",
-                "entry_size": 64,
-                "eventq_index": 0,
-                "indexing_policy": {
-                    "type": "SetAssociative",
-                    "cxx_class": "SetAssociative",
-                    "name": "indexing_policy",
-                    "path": "system.l2.tags.indexing_policy",
-                    "assoc": 8,
-                    "entry_size": 64,
-                    "eventq_index": 0,
-                    "size": 2097152
-                },
-                "power_model": [],
-                "power_state": {
-                    "type": "PowerState",
-                    "cxx_class": "PowerState",
-                    "name": "power_state",
-                    "path": "system.l2.tags.power_state",
-                    "clk_gate_bins": 20,
-                    "clk_gate_max": 1000000000000,
-                    "clk_gate_min": 1000,
-                    "default_state": "UNDEFINED",
-                    "eventq_index": 0,
-                    "leaders": [],
-                    "possible_states": []
-                },
-                "replacement_policy": "system.l2.replacement_policy",
-                "sequential_access": false,
-                "size": 2097152,
-                "system": "system",
-                "tag_latency": 20,
-                "warmup_percentage": 0
-            },
-            "tgts_per_mshr": 12,
-            "warmup_percentage": 0,
-            "write_allocator": null,
-            "write_buffers": 8,
-            "writeback_clean": false,
-            "cpu_side": {
-                "role": "GEM5 RESPONDER",
-                "peer": "system.tol2bus.mem_side_ports[0]",
-                "is_source": "False"
-            },
-            "mem_side": {
-                "role": "GEM5 REQUESTOR",
-                "peer": "system.membus.cpu_side_ports[1]",
-                "is_source": "True"
-            }
-        },
-        "mem_ctrls": [
-            {
-                "type": "Ramulator",
-                "cxx_class": "Ramulator",
-                "name": "mem_ctrls",
-                "path": "system.mem_ctrls",
-                "clk_domain": "system.clk_domain",
-                "conf_table_reported": true,
-                "config_file": "ramulator_configs/DDR4-config.cfg",
-                "eventq_index": 0,
-                "image_file": "",
-                "in_addr_map": true,
-                "kvm_map": true,
-                "null": false,
-                "num_cpus": 4,
-                "output_dir": "m5out/",
-                "power_model": [],
-                "power_state": {
-                    "type": "PowerState",
-                    "cxx_class": "PowerState",
-                    "name": "power_state",
-                    "path": "system.mem_ctrls.power_state",
-                    "clk_gate_bins": 20,
-                    "clk_gate_max": 1000000000000,
-                    "clk_gate_min": 1000,
-                    "default_state": "UNDEFINED",
-                    "eventq_index": 0,
-                    "leaders": [],
-                    "possible_states": []
-                },
-                "range": "0:1073741824",
-                "real_warm_up": 100,
-                "port": {
-                    "role": "GEM5 RESPONDER",
-                    "peer": "system.membus.mem_side_ports[8]",
-                    "is_source": "False"
-                }
-            }
-        ],
-        "membus": {
-            "type": "CoherentXBar",
-            "cxx_class": "CoherentXBar",
-            "name": "membus",
-            "path": "system.membus",
-            "clk_domain": "system.clk_domain",
-            "eventq_index": 0,
-            "forward_latency": 4,
-            "frontend_latency": 3,
-            "header_latency": 1,
-            "max_outstanding_snoops": 512,
-            "max_routing_table_size": 512,
-            "point_of_coherency": true,
-            "point_of_unification": true,
-            "power_model": [],
-            "power_state": {
-                "type": "PowerState",
-                "cxx_class": "PowerState",
-                "name": "power_state",
-                "path": "system.membus.power_state",
-                "clk_gate_bins": 20,
-                "clk_gate_max": 1000000000000,
-                "clk_gate_min": 1000,
-                "default_state": "UNDEFINED",
-                "eventq_index": 0,
-                "leaders": [],
-                "possible_states": []
-            },
-            "response_latency": 2,
-            "snoop_filter": {
-                "type": "SnoopFilter",
-                "cxx_class": "SnoopFilter",
-                "name": "snoop_filter",
-                "path": "system.membus.snoop_filter",
-                "eventq_index": 0,
-                "lookup_latency": 1,
-                "max_capacity": 8388608,
-                "system": "system"
-            },
-            "snoop_response_latency": 4,
-            "system": "system",
-            "use_default_range": false,
-            "width": 16,
-            "cpu_side_ports": {
-                "role": "GEM5 RESPONDER",
-                "peer": [
-                    "system.system_port",
-                    "system.l2.mem_side",
-                    "system.cpu0.interrupts.int_requestor",
-                    "system.cpu1.interrupts.int_requestor",
-                    "system.cpu2.interrupts.int_requestor",
-                    "system.cpu3.interrupts.int_requestor"
-                ],
-                "is_source": "False"
-            },
-            "mem_side_ports": {
-                "role": "GEM5 REQUESTOR",
-                "peer": [
-                    "system.cpu0.interrupts.pio",
-                    "system.cpu0.interrupts.int_responder",
-                    "system.cpu1.interrupts.pio",
-                    "system.cpu1.interrupts.int_responder",
-                    "system.cpu2.interrupts.pio",
-                    "system.cpu2.interrupts.int_responder",
-                    "system.cpu3.interrupts.pio",
-                    "system.cpu3.interrupts.int_responder",
-                    "system.mem_ctrls.port"
-                ],
-                "is_source": "True"
-            }
-        },
-        "tol2bus": {
-            "type": "CoherentXBar",
-            "cxx_class": "CoherentXBar",
-            "name": "tol2bus",
-            "path": "system.tol2bus",
-            "clk_domain": "system.cpu_clk_domain",
-            "eventq_index": 0,
-            "forward_latency": 0,
-            "frontend_latency": 1,
-            "header_latency": 1,
-            "max_outstanding_snoops": 512,
-            "max_routing_table_size": 512,
-            "point_of_coherency": false,
-            "point_of_unification": true,
-            "power_model": [],
-            "power_state": {
-                "type": "PowerState",
-                "cxx_class": "PowerState",
-                "name": "power_state",
-                "path": "system.tol2bus.power_state",
-                "clk_gate_bins": 20,
-                "clk_gate_max": 1000000000000,
-                "clk_gate_min": 1000,
-                "default_state": "UNDEFINED",
-                "eventq_index": 0,
-                "leaders": [],
-                "possible_states": []
-            },
-            "response_latency": 1,
-            "snoop_filter": {
-                "type": "SnoopFilter",
-                "cxx_class": "SnoopFilter",
-                "name": "snoop_filter",
-                "path": "system.tol2bus.snoop_filter",
-                "eventq_index": 0,
-                "lookup_latency": 0,
-                "max_capacity": 8388608,
-                "system": "system"
-            },
-            "snoop_response_latency": 1,
-            "system": "system",
-            "use_default_range": false,
-            "width": 32,
-            "cpu_side_ports": {
-                "role": "GEM5 RESPONDER",
-                "peer": [
-                    "system.cpu0.icache.mem_side",
-                    "system.cpu0.dcache.mem_side",
-                    "system.cpu0.itb_walker_cache.mem_side",
-                    "system.cpu0.dtb_walker_cache.mem_side",
-                    "system.cpu1.icache.mem_side",
-                    "system.cpu1.dcache.mem_side",
-                    "system.cpu1.itb_walker_cache.mem_side",
-                    "system.cpu1.dtb_walker_cache.mem_side",
-                    "system.cpu2.icache.mem_side",
-                    "system.cpu2.dcache.mem_side",
-                    "system.cpu2.itb_walker_cache.mem_side",
-                    "system.cpu2.dtb_walker_cache.mem_side",
-                    "system.cpu3.icache.mem_side",
-                    "system.cpu3.dcache.mem_side",
-                    "system.cpu3.itb_walker_cache.mem_side",
-                    "system.cpu3.dtb_walker_cache.mem_side"
-                ],
-                "is_source": "False"
-            },
-            "mem_side_ports": {
-                "role": "GEM5 REQUESTOR",
-                "peer": [
-                    "system.l2.cpu_side"
-                ],
-                "is_source": "True"
-            }
-        },
-        "voltage_domain": {
-            "type": "VoltageDomain",
-            "cxx_class": "VoltageDomain",
-            "name": "voltage_domain",
-            "path": "system.voltage_domain",
-            "eventq_index": 0,
-            "voltage": [
-                1.0
-            ]
-        },
-        "system_port": {
-            "role": "GEM5 REQUESTOR",
-            "peer": "system.membus.cpu_side_ports[0]",
-            "is_source": "True"
-        }
-    }
-}
\ No newline at end of file
diff --git a/m5out_default_DDR4/debug.txt b/m5out_default_DDR4/debug.txt
deleted file mode 100644
index e69de29bb..000000000
diff --git a/m5out_default_DDR4/fs/proc/cpuinfo b/m5out_default_DDR4/fs/proc/cpuinfo
deleted file mode 100644
index d04b18229..000000000
--- a/m5out_default_DDR4/fs/proc/cpuinfo
+++ /dev/null
@@ -1,76 +0,0 @@
-processor       : 0
-vendor_id       : Generic
-cpu family      : 0
-model           : 0
-model name      : Generic
-stepping        : 0
-cpu MHz         : 2000.000
-cache size:     : 2048.0K
-physical id     : 0
-siblings        : 4
-core id         : 0
-cpu cores       : 4
-fpu             : yes
-fpu exception   : yes
-cpuid level     : 1
-wp              : yes
-flags           : fpu
-cache alignment : 64
-
-processor       : 1
-vendor_id       : Generic
-cpu family      : 0
-model           : 0
-model name      : Generic
-stepping        : 0
-cpu MHz         : 2000.000
-cache size:     : 2048.0K
-physical id     : 0
-siblings        : 4
-core id         : 1
-cpu cores       : 4
-fpu             : yes
-fpu exception   : yes
-cpuid level     : 1
-wp              : yes
-flags           : fpu
-cache alignment : 64
-
-processor       : 2
-vendor_id       : Generic
-cpu family      : 0
-model           : 0
-model name      : Generic
-stepping        : 0
-cpu MHz         : 2000.000
-cache size:     : 2048.0K
-physical id     : 0
-siblings        : 4
-core id         : 2
-cpu cores       : 4
-fpu             : yes
-fpu exception   : yes
-cpuid level     : 1
-wp              : yes
-flags           : fpu
-cache alignment : 64
-
-processor       : 3
-vendor_id       : Generic
-cpu family      : 0
-model           : 0
-model name      : Generic
-stepping        : 0
-cpu MHz         : 2000.000
-cache size:     : 2048.0K
-physical id     : 0
-siblings        : 4
-core id         : 3
-cpu cores       : 4
-fpu             : yes
-fpu exception   : yes
-cpuid level     : 1
-wp              : yes
-flags           : fpu
-cache alignment : 64
-
diff --git a/m5out_default_DDR4/fs/proc/stat b/m5out_default_DDR4/fs/proc/stat
deleted file mode 100644
index 812f42b31..000000000
--- a/m5out_default_DDR4/fs/proc/stat
+++ /dev/null
@@ -1,5 +0,0 @@
-cpu 0 0 0 0 0 0 0
-cpu0 0 0 0 0 0 0 0
-cpu1 0 0 0 0 0 0 0
-cpu2 0 0 0 0 0 0 0
-cpu3 0 0 0 0 0 0 0
diff --git a/m5out_default_DDR4/fs/sys/devices/system/cpu/online b/m5out_default_DDR4/fs/sys/devices/system/cpu/online
deleted file mode 100644
index 8b0ad1be2..000000000
--- a/m5out_default_DDR4/fs/sys/devices/system/cpu/online
+++ /dev/null
@@ -1 +0,0 @@
-0-3
\ No newline at end of file
diff --git a/m5out_default_DDR4/fs/sys/devices/system/cpu/possible b/m5out_default_DDR4/fs/sys/devices/system/cpu/possible
deleted file mode 100644
index 8b0ad1be2..000000000
--- a/m5out_default_DDR4/fs/sys/devices/system/cpu/possible
+++ /dev/null
@@ -1 +0,0 @@
-0-3
\ No newline at end of file
diff --git a/m5out_default_DDR4/stats.txt b/m5out_default_DDR4/stats.txt
deleted file mode 100644
index 70f97da75..000000000
--- a/m5out_default_DDR4/stats.txt
+++ /dev/null
@@ -1,1230 +0,0 @@
-
----------- Begin Simulation Statistics ----------
-final_tick                                 1268411500                       # Number of ticks from beginning of simulation (restored from checkpoints and never reset)
-host_inst_rate                                 295240                       # Simulator instruction rate (inst/s)
-host_mem_usage                                1301184                       # Number of bytes of host memory used
-host_op_rate                                   545168                       # Simulator op (including micro ops) rate (op/s)
-host_seconds                                     2.09                       # Real time elapsed on the host
-host_tick_rate                              607229619                       # Simulator tick rate (ticks/s)
-ramulator.active_cycles_0                       35156                       # Total active cycles for level _0
-ramulator.active_cycles_0_0                     35156                       # Total active cycles for level _0_0
-ramulator.active_cycles_0_0_0                   10736                       # Total active cycles for level _0_0_0
-ramulator.active_cycles_0_0_0_0                  5024                       # Total active cycles for level _0_0_0_0
-ramulator.active_cycles_0_0_0_1                  1796                       # Total active cycles for level _0_0_0_1
-ramulator.active_cycles_0_0_0_2                  2268                       # Total active cycles for level _0_0_0_2
-ramulator.active_cycles_0_0_0_3                  1648                       # Total active cycles for level _0_0_0_3
-ramulator.active_cycles_0_0_1                    8568                       # Total active cycles for level _0_0_1
-ramulator.active_cycles_0_0_1_0                  4196                       # Total active cycles for level _0_0_1_0
-ramulator.active_cycles_0_0_1_1                   952                       # Total active cycles for level _0_0_1_1
-ramulator.active_cycles_0_0_1_2                  1084                       # Total active cycles for level _0_0_1_2
-ramulator.active_cycles_0_0_1_3                  2336                       # Total active cycles for level _0_0_1_3
-ramulator.active_cycles_0_0_2                    8628                       # Total active cycles for level _0_0_2
-ramulator.active_cycles_0_0_2_0                  2300                       # Total active cycles for level _0_0_2_0
-ramulator.active_cycles_0_0_2_1                  1408                       # Total active cycles for level _0_0_2_1
-ramulator.active_cycles_0_0_2_2                   768                       # Total active cycles for level _0_0_2_2
-ramulator.active_cycles_0_0_2_3                  4152                       # Total active cycles for level _0_0_2_3
-ramulator.active_cycles_0_0_3                    7224                       # Total active cycles for level _0_0_3
-ramulator.active_cycles_0_0_3_0                  1072                       # Total active cycles for level _0_0_3_0
-ramulator.active_cycles_0_0_3_1                   984                       # Total active cycles for level _0_0_3_1
-ramulator.active_cycles_0_0_3_2                  2252                       # Total active cycles for level _0_0_3_2
-ramulator.active_cycles_0_0_3_3                  2916                       # Total active cycles for level _0_0_3_3
-ramulator.average_serving_requests_0         0.046176                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0
-ramulator.average_serving_requests_0_0       0.046176                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0
-ramulator.average_serving_requests_0_0_0     0.014101                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0
-ramulator.average_serving_requests_0_0_0_0     0.006599                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_0
-ramulator.average_serving_requests_0_0_0_1     0.002359                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_1
-ramulator.average_serving_requests_0_0_0_2     0.002979                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_2
-ramulator.average_serving_requests_0_0_0_3     0.002165                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_3
-ramulator.average_serving_requests_0_0_1     0.011254                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1
-ramulator.average_serving_requests_0_0_1_0     0.005511                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_0
-ramulator.average_serving_requests_0_0_1_1     0.001250                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_1
-ramulator.average_serving_requests_0_0_1_2     0.001424                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_2
-ramulator.average_serving_requests_0_0_1_3     0.003068                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_3
-ramulator.average_serving_requests_0_0_2     0.011332                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2
-ramulator.average_serving_requests_0_0_2_0     0.003021                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_0
-ramulator.average_serving_requests_0_0_2_1     0.001849                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_1
-ramulator.average_serving_requests_0_0_2_2     0.001009                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_2
-ramulator.average_serving_requests_0_0_2_3     0.005453                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_3
-ramulator.average_serving_requests_0_0_3     0.009488                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3
-ramulator.average_serving_requests_0_0_3_0     0.001408                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_0
-ramulator.average_serving_requests_0_0_3_1     0.001292                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_1
-ramulator.average_serving_requests_0_0_3_2     0.002958                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_2
-ramulator.average_serving_requests_0_0_3_3     0.003830                       # The average of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_3
-ramulator.busy_cycles_0                         35156                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0
-ramulator.busy_cycles_0_0                       60428                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0
-ramulator.busy_cycles_0_0_0                     10736                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_0
-ramulator.busy_cycles_0_0_0_0                    5024                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_0_0
-ramulator.busy_cycles_0_0_0_1                    1796                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_0_1
-ramulator.busy_cycles_0_0_0_2                    2268                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_0_2
-ramulator.busy_cycles_0_0_0_3                    1648                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_0_3
-ramulator.busy_cycles_0_0_1                      8568                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_1
-ramulator.busy_cycles_0_0_1_0                    4196                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_1_0
-ramulator.busy_cycles_0_0_1_1                     952                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_1_1
-ramulator.busy_cycles_0_0_1_2                    1084                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_1_2
-ramulator.busy_cycles_0_0_1_3                    2336                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_1_3
-ramulator.busy_cycles_0_0_2                      8628                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_2
-ramulator.busy_cycles_0_0_2_0                    2300                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_2_0
-ramulator.busy_cycles_0_0_2_1                    1408                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_2_1
-ramulator.busy_cycles_0_0_2_2                     768                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_2_2
-ramulator.busy_cycles_0_0_2_3                    4152                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_2_3
-ramulator.busy_cycles_0_0_3                      7224                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_3
-ramulator.busy_cycles_0_0_3_0                    1072                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_3_0
-ramulator.busy_cycles_0_0_3_1                     984                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_3_1
-ramulator.busy_cycles_0_0_3_2                    2252                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_3_2
-ramulator.busy_cycles_0_0_3_3                    2916                       # (All-bank refresh only. busy cycles only include refresh time in rank level) The sum of cycles that the DRAM part is active or under refresh for level _0_0_3_3
-ramulator.demand_read_latency_avg_0         29.194041                       # The average memory latency cycles (in memory time domain) per request for demand read requests in this channel
-ramulator.demand_read_latency_sum_0             38215                       # The memory latency cycles (in memory time domain) sum for demand read requests in this channel
-ramulator.dram_capacity                    4294967296                       # Number of bytes in simulated DRAM
-ramulator.dram_cycles                          761352                       # Number of DRAM cycles simulated
-ramulator.in_queue_read_req_num_avg          0.039245                       # Average of read queue length per memory cycle
-ramulator.in_queue_read_req_num_sum             29879                       # Sum of read queue length
-ramulator.in_queue_req_num_avg               0.039245                       # Average of read/write queue length per memory cycle
-ramulator.in_queue_req_num_sum                  29879                       # Sum of read/write queue length
-ramulator.in_queue_write_req_num_avg         0.000000                       # Average of write queue length per memory cycle
-ramulator.in_queue_write_req_num_sum                0                       # Sum of write queue length
-ramulator.incoming_demand_read_reqs_per_channel         1309                       # Number of incoming demand read requests to each DRAM channel
-ramulator.incoming_prefetch_read_reqs_per_channel            0                       # Number of incoming prefetch read requests to each DRAM channel
-ramulator.incoming_read_reqs_per_channel         1309                       # Number of incoming read requests to each DRAM channel
-ramulator.incoming_requests                      1309                       # Number of incoming requests to DRAM
-ramulator.incoming_requests_per_channel          1309                       # Number of incoming requests to each DRAM channel
-ramulator.maximum_bandwidth               19200000000                       # The theoretical maximum bandwidth (Bps)
-ramulator.physical_page_replacement                 0                       # The number of times that physical page replacement happens.
-ramulator.prefetch_read_latency_avg_0             nan                       # The average memory latency cycles (in memory time domain) per request for prefetch read requests in this channel
-ramulator.prefetch_read_latency_sum_0               0                       # The memory latency cycles (in memory time domain) sum for prefetch read requests in this channel
-ramulator.prefetch_to_demand_read_promotion            0                       # Number of incoming prefetch read requests promoted to demand request
-ramulator.ramulator_active_cycles               35156                       # The total number of cycles that the DRAM part is active (serving R/W)
-ramulator.read_latency_avg_0                29.194041                       # The average memory latency cycles (in memory time domain) per request for all read requests in this channel
-ramulator.read_latency_sum_0                    38215                       # The memory latency cycles (in memory time domain) sum for all read requests in this channel
-ramulator.read_req_queue_length_avg_0        0.039245                       # Read queue length average per memory cycle per channel.
-ramulator.read_req_queue_length_sum_0           29879                       # Read queue length sum per memory cycle per channel.
-ramulator.read_requests::0                       1309                       # Number of incoming read requests to DRAM per core
-ramulator.read_requests::1                          0                       # Number of incoming read requests to DRAM per core
-ramulator.read_requests::2                          0                       # Number of incoming read requests to DRAM per core
-ramulator.read_requests::3                          0                       # Number of incoming read requests to DRAM per core
-ramulator.read_row_conflicts_channel_0_core::0           40                       # Number of row conflicts for read requests per channel per core
-ramulator.read_row_conflicts_channel_0_core::1            0                       # Number of row conflicts for read requests per channel per core
-ramulator.read_row_conflicts_channel_0_core::2            0                       # Number of row conflicts for read requests per channel per core
-ramulator.read_row_conflicts_channel_0_core::3            0                       # Number of row conflicts for read requests per channel per core
-ramulator.read_row_hits_channel_0_core::0          788                       # Number of row hits for read requests per channel per core
-ramulator.read_row_hits_channel_0_core::1            0                       # Number of row hits for read requests per channel per core
-ramulator.read_row_hits_channel_0_core::2            0                       # Number of row hits for read requests per channel per core
-ramulator.read_row_hits_channel_0_core::3            0                       # Number of row hits for read requests per channel per core
-ramulator.read_row_misses_channel_0_core::0          481                       # Number of row misses for read requests per channel per core
-ramulator.read_row_misses_channel_0_core::1            0                       # Number of row misses for read requests per channel per core
-ramulator.read_row_misses_channel_0_core::2            0                       # Number of row misses for read requests per channel per core
-ramulator.read_row_misses_channel_0_core::3            0                       # Number of row misses for read requests per channel per core
-ramulator.read_transaction_bytes_0              83776                       # The total byte of read transaction per channel
-ramulator.refresh_cycles_0_0                    25272                       # (All-bank refresh only, only valid for rank level) The sum of cycles that is under refresh per memory cycle for level _0_0
-ramulator.req_queue_length_avg_0             0.039245                       # Average of read and write queue length per memory cycle per channel.
-ramulator.req_queue_length_sum_0                29879                       # Sum of read and write queue length per memory cycle per channel.
-ramulator.row_conflicts_channel_0_core             40                       # Number of row conflicts per channel per core
-ramulator.row_hits_channel_0_core                 788                       # Number of row hits per channel per core
-ramulator.row_misses_channel_0_core               481                       # Number of row misses per channel per core
-ramulator.serving_requests_0                    35156                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0
-ramulator.serving_requests_0_0                  35156                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0
-ramulator.serving_requests_0_0_0                10736                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0
-ramulator.serving_requests_0_0_0_0               5024                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_0
-ramulator.serving_requests_0_0_0_1               1796                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_1
-ramulator.serving_requests_0_0_0_2               2268                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_2
-ramulator.serving_requests_0_0_0_3               1648                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_0_3
-ramulator.serving_requests_0_0_1                 8568                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1
-ramulator.serving_requests_0_0_1_0               4196                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_0
-ramulator.serving_requests_0_0_1_1                952                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_1
-ramulator.serving_requests_0_0_1_2               1084                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_2
-ramulator.serving_requests_0_0_1_3               2336                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_1_3
-ramulator.serving_requests_0_0_2                 8628                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2
-ramulator.serving_requests_0_0_2_0               2300                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_0
-ramulator.serving_requests_0_0_2_1               1408                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_1
-ramulator.serving_requests_0_0_2_2                768                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_2
-ramulator.serving_requests_0_0_2_3               4152                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_2_3
-ramulator.serving_requests_0_0_3                 7224                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3
-ramulator.serving_requests_0_0_3_0               1072                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_0
-ramulator.serving_requests_0_0_3_1                984                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_1
-ramulator.serving_requests_0_0_3_2               2252                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_2
-ramulator.serving_requests_0_0_3_3               2916                       # The sum of read and write requests that are served in this DRAM element per memory cycle for level _0_0_3_3
-ramulator.useless_activates_0_core                  0                       # Number of useless activations. E.g, ACT -> PRE w/o RD or WR
-ramulator.write_req_queue_length_avg_0       0.000000                       # Write queue length average per memory cycle per channel.
-ramulator.write_req_queue_length_sum_0              0                       # Write queue length sum per memory cycle per channel.
-ramulator.write_requests::0                         0                       # Number of incoming write requests to DRAM per core
-ramulator.write_requests::1                         0                       # Number of incoming write requests to DRAM per core
-ramulator.write_requests::2                         0                       # Number of incoming write requests to DRAM per core
-ramulator.write_requests::3                         0                       # Number of incoming write requests to DRAM per core
-ramulator.write_row_conflicts_channel_0_core::0            0                       # Number of row conflicts for write requests per channel per core
-ramulator.write_row_conflicts_channel_0_core::1            0                       # Number of row conflicts for write requests per channel per core
-ramulator.write_row_conflicts_channel_0_core::2            0                       # Number of row conflicts for write requests per channel per core
-ramulator.write_row_conflicts_channel_0_core::3            0                       # Number of row conflicts for write requests per channel per core
-ramulator.write_row_hits_channel_0_core::0            0                       # Number of row hits for write requests per channel per core
-ramulator.write_row_hits_channel_0_core::1            0                       # Number of row hits for write requests per channel per core
-ramulator.write_row_hits_channel_0_core::2            0                       # Number of row hits for write requests per channel per core
-ramulator.write_row_hits_channel_0_core::3            0                       # Number of row hits for write requests per channel per core
-ramulator.write_row_misses_channel_0_core::0            0                       # Number of row misses for write requests per channel per core
-ramulator.write_row_misses_channel_0_core::1            0                       # Number of row misses for write requests per channel per core
-ramulator.write_row_misses_channel_0_core::2            0                       # Number of row misses for write requests per channel per core
-ramulator.write_row_misses_channel_0_core::3            0                       # Number of row misses for write requests per channel per core
-ramulator.write_transaction_bytes_0                 0                       # The total byte of write transaction per channel
-sim_freq                                 1000000000000                       # Frequency of simulated ticks
-sim_insts                                      616665                       # Number of instructions simulated
-sim_ops                                       1138760                       # Number of ops (including micro ops) simulated
-sim_seconds                                  0.001268                       # Number of seconds simulated
-sim_ticks                                  1268411500                       # Number of ticks simulated
-system.cpu0.Branches                           111751                       # Number of branches fetched
-system.cpu0.committedInsts                     616665                       # Number of instructions committed
-system.cpu0.committedOps                      1138760                       # Number of ops (including micro ops) committed
-system.cpu0.idle_fraction                    0.000000                       # Percentage of idle cycles
-system.cpu0.not_idle_fraction                1.000000                       # Percentage of non-idle cycles
-system.cpu0.numCycles                         2536823                       # number of cpu cycles simulated
-system.cpu0.numWorkItemsCompleted                   0                       # number of work items this cpu completed
-system.cpu0.numWorkItemsStarted                     0                       # number of work items this cpu started
-system.cpu0.num_busy_cycles              2536822.998000                       # Number of busy cycles
-system.cpu0.num_cc_register_reads              364455                       # number of times the CC registers were read
-system.cpu0.num_cc_register_writes             199852                       # number of times the CC registers were written
-system.cpu0.num_conditional_control_insts        37058                       # number of instructions that are conditional controls
-system.cpu0.num_fp_alu_accesses                  4706                       # Number of float alu accesses
-system.cpu0.num_fp_insts                         4706                       # number of float instructions
-system.cpu0.num_fp_register_reads                8312                       # number of times the floating registers were read
-system.cpu0.num_fp_register_writes               3802                       # number of times the floating registers were written
-system.cpu0.num_func_calls                      61188                       # number of times a function call or return occured
-system.cpu0.num_idle_cycles                  0.002000                       # Number of idle cycles
-system.cpu0.num_int_alu_accesses              1131377                       # Number of integer alu accesses
-system.cpu0.num_int_insts                     1131377                       # number of integer instructions
-system.cpu0.num_int_register_reads            2567852                       # number of times the integer registers were read
-system.cpu0.num_int_register_writes            855373                       # number of times the integer registers were written
-system.cpu0.num_load_insts                     227677                       # Number of load instructions
-system.cpu0.num_mem_refs                       392282                       # number of memory refs
-system.cpu0.num_store_insts                    164605                       # Number of store instructions
-system.cpu0.num_vec_alu_accesses                    0                       # Number of vector alu accesses
-system.cpu0.num_vec_insts                           0                       # number of vector instructions
-system.cpu0.num_vec_register_reads                  0                       # number of times the vector registers were read
-system.cpu0.num_vec_register_writes                 0                       # number of times the vector registers were written
-system.cpu0.op_class::No_OpClass                  772      0.07%      0.07% # Class of executed instruction
-system.cpu0.op_class::IntAlu                   742086     65.16%     65.23% # Class of executed instruction
-system.cpu0.op_class::IntMult                     392      0.03%     65.27% # Class of executed instruction
-system.cpu0.op_class::IntDiv                       56      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatAdd                     10      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatCmp                      0      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatCvt                      0      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatMult                     0      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatMultAcc                  0      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatDiv                      0      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatMisc                     0      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::FloatSqrt                     0      0.00%     65.27% # Class of executed instruction
-system.cpu0.op_class::SimdAdd                     390      0.03%     65.31% # Class of executed instruction
-system.cpu0.op_class::SimdAddAcc                    0      0.00%     65.31% # Class of executed instruction
-system.cpu0.op_class::SimdAlu                    1478      0.13%     65.44% # Class of executed instruction
-system.cpu0.op_class::SimdCmp                       0      0.00%     65.44% # Class of executed instruction
-system.cpu0.op_class::SimdCvt                     520      0.05%     65.48% # Class of executed instruction
-system.cpu0.op_class::SimdMisc                    610      0.05%     65.54% # Class of executed instruction
-system.cpu0.op_class::SimdMult                      0      0.00%     65.54% # Class of executed instruction
-system.cpu0.op_class::SimdMultAcc                   0      0.00%     65.54% # Class of executed instruction
-system.cpu0.op_class::SimdShift                   186      0.02%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdShiftAcc                  0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdDiv                       0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdSqrt                      0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatAdd                  0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatAlu                  0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatCmp                  0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatCvt                  0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatDiv                  0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatMisc                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatMult                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatMultAcc              0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatSqrt                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdReduceAdd                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdReduceAlu                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdReduceCmp                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatReduceAdd            0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdFloatReduceCmp            0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdAes                       0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdAesMix                    0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdSha1Hash                  0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdSha1Hash2                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdSha256Hash                0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdSha256Hash2               0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdShaSigma2                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdShaSigma3                 0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::SimdPredAlu                   0      0.00%     65.55% # Class of executed instruction
-system.cpu0.op_class::MemRead                  227137     19.95%     85.50% # Class of executed instruction
-system.cpu0.op_class::MemWrite                 164145     14.41%     99.91% # Class of executed instruction
-system.cpu0.op_class::FloatMemRead                540      0.05%     99.96% # Class of executed instruction
-system.cpu0.op_class::FloatMemWrite               460      0.04%    100.00% # Class of executed instruction
-system.cpu0.op_class::IprAccess                     0      0.00%    100.00% # Class of executed instruction
-system.cpu0.op_class::InstPrefetch                  0      0.00%    100.00% # Class of executed instruction
-system.cpu0.op_class::total                   1138782                       # Class of executed instruction
-system.cpu0.workload.numSyscalls                   18                       # Number of system calls
-system.cpu1.committedInsts                          0                       # Number of instructions committed
-system.cpu1.committedOps                            0                       # Number of ops (including micro ops) committed
-system.cpu1.idle_fraction                           1                       # Percentage of idle cycles
-system.cpu1.not_idle_fraction                       0                       # Percentage of non-idle cycles
-system.cpu1.numCycles                               0                       # number of cpu cycles simulated
-system.cpu1.numWorkItemsCompleted                   0                       # number of work items this cpu completed
-system.cpu1.numWorkItemsStarted                     0                       # number of work items this cpu started
-system.cpu1.num_busy_cycles                         0                       # Number of busy cycles
-system.cpu1.num_conditional_control_insts            0                       # number of instructions that are conditional controls
-system.cpu1.num_fp_alu_accesses                     0                       # Number of float alu accesses
-system.cpu1.num_fp_insts                            0                       # number of float instructions
-system.cpu1.num_fp_register_reads                   0                       # number of times the floating registers were read
-system.cpu1.num_fp_register_writes                  0                       # number of times the floating registers were written
-system.cpu1.num_func_calls                          0                       # number of times a function call or return occured
-system.cpu1.num_idle_cycles                         0                       # Number of idle cycles
-system.cpu1.num_int_alu_accesses                    0                       # Number of integer alu accesses
-system.cpu1.num_int_insts                           0                       # number of integer instructions
-system.cpu1.num_int_register_reads                  0                       # number of times the integer registers were read
-system.cpu1.num_int_register_writes                 0                       # number of times the integer registers were written
-system.cpu1.num_load_insts                          0                       # Number of load instructions
-system.cpu1.num_mem_refs                            0                       # number of memory refs
-system.cpu1.num_store_insts                         0                       # Number of store instructions
-system.cpu1.num_vec_alu_accesses                    0                       # Number of vector alu accesses
-system.cpu1.num_vec_insts                           0                       # number of vector instructions
-system.cpu1.num_vec_register_reads                  0                       # number of times the vector registers were read
-system.cpu1.num_vec_register_writes                 0                       # number of times the vector registers were written
-system.cpu1.op_class::No_OpClass                    0                       # Class of executed instruction
-system.cpu1.op_class::IntAlu                        0                       # Class of executed instruction
-system.cpu1.op_class::IntMult                       0                       # Class of executed instruction
-system.cpu1.op_class::IntDiv                        0                       # Class of executed instruction
-system.cpu1.op_class::FloatAdd                      0                       # Class of executed instruction
-system.cpu1.op_class::FloatCmp                      0                       # Class of executed instruction
-system.cpu1.op_class::FloatCvt                      0                       # Class of executed instruction
-system.cpu1.op_class::FloatMult                     0                       # Class of executed instruction
-system.cpu1.op_class::FloatMultAcc                  0                       # Class of executed instruction
-system.cpu1.op_class::FloatDiv                      0                       # Class of executed instruction
-system.cpu1.op_class::FloatMisc                     0                       # Class of executed instruction
-system.cpu1.op_class::FloatSqrt                     0                       # Class of executed instruction
-system.cpu1.op_class::SimdAdd                       0                       # Class of executed instruction
-system.cpu1.op_class::SimdAddAcc                    0                       # Class of executed instruction
-system.cpu1.op_class::SimdAlu                       0                       # Class of executed instruction
-system.cpu1.op_class::SimdCmp                       0                       # Class of executed instruction
-system.cpu1.op_class::SimdCvt                       0                       # Class of executed instruction
-system.cpu1.op_class::SimdMisc                      0                       # Class of executed instruction
-system.cpu1.op_class::SimdMult                      0                       # Class of executed instruction
-system.cpu1.op_class::SimdMultAcc                   0                       # Class of executed instruction
-system.cpu1.op_class::SimdShift                     0                       # Class of executed instruction
-system.cpu1.op_class::SimdShiftAcc                  0                       # Class of executed instruction
-system.cpu1.op_class::SimdDiv                       0                       # Class of executed instruction
-system.cpu1.op_class::SimdSqrt                      0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatAdd                  0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatAlu                  0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatCmp                  0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatCvt                  0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatDiv                  0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatMisc                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatMult                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatMultAcc              0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatSqrt                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdReduceAdd                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdReduceAlu                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdReduceCmp                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatReduceAdd            0                       # Class of executed instruction
-system.cpu1.op_class::SimdFloatReduceCmp            0                       # Class of executed instruction
-system.cpu1.op_class::SimdAes                       0                       # Class of executed instruction
-system.cpu1.op_class::SimdAesMix                    0                       # Class of executed instruction
-system.cpu1.op_class::SimdSha1Hash                  0                       # Class of executed instruction
-system.cpu1.op_class::SimdSha1Hash2                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdSha256Hash                0                       # Class of executed instruction
-system.cpu1.op_class::SimdSha256Hash2               0                       # Class of executed instruction
-system.cpu1.op_class::SimdShaSigma2                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdShaSigma3                 0                       # Class of executed instruction
-system.cpu1.op_class::SimdPredAlu                   0                       # Class of executed instruction
-system.cpu1.op_class::MemRead                       0                       # Class of executed instruction
-system.cpu1.op_class::MemWrite                      0                       # Class of executed instruction
-system.cpu1.op_class::FloatMemRead                  0                       # Class of executed instruction
-system.cpu1.op_class::FloatMemWrite                 0                       # Class of executed instruction
-system.cpu1.op_class::IprAccess                     0                       # Class of executed instruction
-system.cpu1.op_class::InstPrefetch                  0                       # Class of executed instruction
-system.cpu1.op_class::total                         0                       # Class of executed instruction
-system.cpu2.committedInsts                          0                       # Number of instructions committed
-system.cpu2.committedOps                            0                       # Number of ops (including micro ops) committed
-system.cpu2.idle_fraction                           1                       # Percentage of idle cycles
-system.cpu2.not_idle_fraction                       0                       # Percentage of non-idle cycles
-system.cpu2.numCycles                               0                       # number of cpu cycles simulated
-system.cpu2.numWorkItemsCompleted                   0                       # number of work items this cpu completed
-system.cpu2.numWorkItemsStarted                     0                       # number of work items this cpu started
-system.cpu2.num_busy_cycles                         0                       # Number of busy cycles
-system.cpu2.num_conditional_control_insts            0                       # number of instructions that are conditional controls
-system.cpu2.num_fp_alu_accesses                     0                       # Number of float alu accesses
-system.cpu2.num_fp_insts                            0                       # number of float instructions
-system.cpu2.num_fp_register_reads                   0                       # number of times the floating registers were read
-system.cpu2.num_fp_register_writes                  0                       # number of times the floating registers were written
-system.cpu2.num_func_calls                          0                       # number of times a function call or return occured
-system.cpu2.num_idle_cycles                         0                       # Number of idle cycles
-system.cpu2.num_int_alu_accesses                    0                       # Number of integer alu accesses
-system.cpu2.num_int_insts                           0                       # number of integer instructions
-system.cpu2.num_int_register_reads                  0                       # number of times the integer registers were read
-system.cpu2.num_int_register_writes                 0                       # number of times the integer registers were written
-system.cpu2.num_load_insts                          0                       # Number of load instructions
-system.cpu2.num_mem_refs                            0                       # number of memory refs
-system.cpu2.num_store_insts                         0                       # Number of store instructions
-system.cpu2.num_vec_alu_accesses                    0                       # Number of vector alu accesses
-system.cpu2.num_vec_insts                           0                       # number of vector instructions
-system.cpu2.num_vec_register_reads                  0                       # number of times the vector registers were read
-system.cpu2.num_vec_register_writes                 0                       # number of times the vector registers were written
-system.cpu2.op_class::No_OpClass                    0                       # Class of executed instruction
-system.cpu2.op_class::IntAlu                        0                       # Class of executed instruction
-system.cpu2.op_class::IntMult                       0                       # Class of executed instruction
-system.cpu2.op_class::IntDiv                        0                       # Class of executed instruction
-system.cpu2.op_class::FloatAdd                      0                       # Class of executed instruction
-system.cpu2.op_class::FloatCmp                      0                       # Class of executed instruction
-system.cpu2.op_class::FloatCvt                      0                       # Class of executed instruction
-system.cpu2.op_class::FloatMult                     0                       # Class of executed instruction
-system.cpu2.op_class::FloatMultAcc                  0                       # Class of executed instruction
-system.cpu2.op_class::FloatDiv                      0                       # Class of executed instruction
-system.cpu2.op_class::FloatMisc                     0                       # Class of executed instruction
-system.cpu2.op_class::FloatSqrt                     0                       # Class of executed instruction
-system.cpu2.op_class::SimdAdd                       0                       # Class of executed instruction
-system.cpu2.op_class::SimdAddAcc                    0                       # Class of executed instruction
-system.cpu2.op_class::SimdAlu                       0                       # Class of executed instruction
-system.cpu2.op_class::SimdCmp                       0                       # Class of executed instruction
-system.cpu2.op_class::SimdCvt                       0                       # Class of executed instruction
-system.cpu2.op_class::SimdMisc                      0                       # Class of executed instruction
-system.cpu2.op_class::SimdMult                      0                       # Class of executed instruction
-system.cpu2.op_class::SimdMultAcc                   0                       # Class of executed instruction
-system.cpu2.op_class::SimdShift                     0                       # Class of executed instruction
-system.cpu2.op_class::SimdShiftAcc                  0                       # Class of executed instruction
-system.cpu2.op_class::SimdDiv                       0                       # Class of executed instruction
-system.cpu2.op_class::SimdSqrt                      0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatAdd                  0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatAlu                  0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatCmp                  0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatCvt                  0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatDiv                  0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatMisc                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatMult                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatMultAcc              0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatSqrt                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdReduceAdd                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdReduceAlu                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdReduceCmp                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatReduceAdd            0                       # Class of executed instruction
-system.cpu2.op_class::SimdFloatReduceCmp            0                       # Class of executed instruction
-system.cpu2.op_class::SimdAes                       0                       # Class of executed instruction
-system.cpu2.op_class::SimdAesMix                    0                       # Class of executed instruction
-system.cpu2.op_class::SimdSha1Hash                  0                       # Class of executed instruction
-system.cpu2.op_class::SimdSha1Hash2                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdSha256Hash                0                       # Class of executed instruction
-system.cpu2.op_class::SimdSha256Hash2               0                       # Class of executed instruction
-system.cpu2.op_class::SimdShaSigma2                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdShaSigma3                 0                       # Class of executed instruction
-system.cpu2.op_class::SimdPredAlu                   0                       # Class of executed instruction
-system.cpu2.op_class::MemRead                       0                       # Class of executed instruction
-system.cpu2.op_class::MemWrite                      0                       # Class of executed instruction
-system.cpu2.op_class::FloatMemRead                  0                       # Class of executed instruction
-system.cpu2.op_class::FloatMemWrite                 0                       # Class of executed instruction
-system.cpu2.op_class::IprAccess                     0                       # Class of executed instruction
-system.cpu2.op_class::InstPrefetch                  0                       # Class of executed instruction
-system.cpu2.op_class::total                         0                       # Class of executed instruction
-system.cpu3.committedInsts                          0                       # Number of instructions committed
-system.cpu3.committedOps                            0                       # Number of ops (including micro ops) committed
-system.cpu3.idle_fraction                           1                       # Percentage of idle cycles
-system.cpu3.not_idle_fraction                       0                       # Percentage of non-idle cycles
-system.cpu3.numCycles                               0                       # number of cpu cycles simulated
-system.cpu3.numWorkItemsCompleted                   0                       # number of work items this cpu completed
-system.cpu3.numWorkItemsStarted                     0                       # number of work items this cpu started
-system.cpu3.num_busy_cycles                         0                       # Number of busy cycles
-system.cpu3.num_conditional_control_insts            0                       # number of instructions that are conditional controls
-system.cpu3.num_fp_alu_accesses                     0                       # Number of float alu accesses
-system.cpu3.num_fp_insts                            0                       # number of float instructions
-system.cpu3.num_fp_register_reads                   0                       # number of times the floating registers were read
-system.cpu3.num_fp_register_writes                  0                       # number of times the floating registers were written
-system.cpu3.num_func_calls                          0                       # number of times a function call or return occured
-system.cpu3.num_idle_cycles                         0                       # Number of idle cycles
-system.cpu3.num_int_alu_accesses                    0                       # Number of integer alu accesses
-system.cpu3.num_int_insts                           0                       # number of integer instructions
-system.cpu3.num_int_register_reads                  0                       # number of times the integer registers were read
-system.cpu3.num_int_register_writes                 0                       # number of times the integer registers were written
-system.cpu3.num_load_insts                          0                       # Number of load instructions
-system.cpu3.num_mem_refs                            0                       # number of memory refs
-system.cpu3.num_store_insts                         0                       # Number of store instructions
-system.cpu3.num_vec_alu_accesses                    0                       # Number of vector alu accesses
-system.cpu3.num_vec_insts                           0                       # number of vector instructions
-system.cpu3.num_vec_register_reads                  0                       # number of times the vector registers were read
-system.cpu3.num_vec_register_writes                 0                       # number of times the vector registers were written
-system.cpu3.op_class::No_OpClass                    0                       # Class of executed instruction
-system.cpu3.op_class::IntAlu                        0                       # Class of executed instruction
-system.cpu3.op_class::IntMult                       0                       # Class of executed instruction
-system.cpu3.op_class::IntDiv                        0                       # Class of executed instruction
-system.cpu3.op_class::FloatAdd                      0                       # Class of executed instruction
-system.cpu3.op_class::FloatCmp                      0                       # Class of executed instruction
-system.cpu3.op_class::FloatCvt                      0                       # Class of executed instruction
-system.cpu3.op_class::FloatMult                     0                       # Class of executed instruction
-system.cpu3.op_class::FloatMultAcc                  0                       # Class of executed instruction
-system.cpu3.op_class::FloatDiv                      0                       # Class of executed instruction
-system.cpu3.op_class::FloatMisc                     0                       # Class of executed instruction
-system.cpu3.op_class::FloatSqrt                     0                       # Class of executed instruction
-system.cpu3.op_class::SimdAdd                       0                       # Class of executed instruction
-system.cpu3.op_class::SimdAddAcc                    0                       # Class of executed instruction
-system.cpu3.op_class::SimdAlu                       0                       # Class of executed instruction
-system.cpu3.op_class::SimdCmp                       0                       # Class of executed instruction
-system.cpu3.op_class::SimdCvt                       0                       # Class of executed instruction
-system.cpu3.op_class::SimdMisc                      0                       # Class of executed instruction
-system.cpu3.op_class::SimdMult                      0                       # Class of executed instruction
-system.cpu3.op_class::SimdMultAcc                   0                       # Class of executed instruction
-system.cpu3.op_class::SimdShift                     0                       # Class of executed instruction
-system.cpu3.op_class::SimdShiftAcc                  0                       # Class of executed instruction
-system.cpu3.op_class::SimdDiv                       0                       # Class of executed instruction
-system.cpu3.op_class::SimdSqrt                      0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatAdd                  0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatAlu                  0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatCmp                  0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatCvt                  0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatDiv                  0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatMisc                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatMult                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatMultAcc              0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatSqrt                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdReduceAdd                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdReduceAlu                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdReduceCmp                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatReduceAdd            0                       # Class of executed instruction
-system.cpu3.op_class::SimdFloatReduceCmp            0                       # Class of executed instruction
-system.cpu3.op_class::SimdAes                       0                       # Class of executed instruction
-system.cpu3.op_class::SimdAesMix                    0                       # Class of executed instruction
-system.cpu3.op_class::SimdSha1Hash                  0                       # Class of executed instruction
-system.cpu3.op_class::SimdSha1Hash2                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdSha256Hash                0                       # Class of executed instruction
-system.cpu3.op_class::SimdSha256Hash2               0                       # Class of executed instruction
-system.cpu3.op_class::SimdShaSigma2                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdShaSigma3                 0                       # Class of executed instruction
-system.cpu3.op_class::SimdPredAlu                   0                       # Class of executed instruction
-system.cpu3.op_class::MemRead                       0                       # Class of executed instruction
-system.cpu3.op_class::MemWrite                      0                       # Class of executed instruction
-system.cpu3.op_class::FloatMemRead                  0                       # Class of executed instruction
-system.cpu3.op_class::FloatMemWrite                 0                       # Class of executed instruction
-system.cpu3.op_class::IprAccess                     0                       # Class of executed instruction
-system.cpu3.op_class::InstPrefetch                  0                       # Class of executed instruction
-system.cpu3.op_class::total                         0                       # Class of executed instruction
-system.membus.snoop_filter.hit_multi_requests            0                       # Number of requests hitting in the snoop filter with multiple (>1) holders of the requested data.
-system.membus.snoop_filter.hit_multi_snoops            0                       # Number of snoops hitting in the snoop filter with multiple (>1) holders of the requested data.
-system.membus.snoop_filter.hit_single_requests            0                       # Number of requests hitting in the snoop filter with a single holder of the requested data.
-system.membus.snoop_filter.hit_single_snoops            0                       # Number of snoops hitting in the snoop filter with a single holder of the requested data.
-system.membus.snoop_filter.tot_requests          1310                       # Total number of requests made to the snoop filter.
-system.membus.snoop_filter.tot_snoops               0                       # Total number of snoops made to the snoop filter.
-system.tol2bus.snoop_filter.hit_multi_requests            0                       # Number of requests hitting in the snoop filter with multiple (>1) holders of the requested data.
-system.tol2bus.snoop_filter.hit_multi_snoops            0                       # Number of snoops hitting in the snoop filter with multiple (>1) holders of the requested data.
-system.tol2bus.snoop_filter.hit_single_requests          740                       # Number of requests hitting in the snoop filter with a single holder of the requested data.
-system.tol2bus.snoop_filter.hit_single_snoops            0                       # Number of snoops hitting in the snoop filter with a single holder of the requested data.
-system.tol2bus.snoop_filter.tot_requests         2387                       # Total number of requests made to the snoop filter.
-system.tol2bus.snoop_filter.tot_snoops              0                       # Total number of snoops made to the snoop filter.
-system.clk_domain.clock                          1000                       # Clock period in ticks
-system.cpu0.dcache.demand_hits::.cpu0.data       391868                       # number of demand (read+write) hits
-system.cpu0.dcache.demand_hits::total          391868                       # number of demand (read+write) hits
-system.cpu0.dcache.overall_hits::.cpu0.data       391868                       # number of overall hits
-system.cpu0.dcache.overall_hits::total         391868                       # number of overall hits
-system.cpu0.dcache.demand_misses::.cpu0.data          435                       # number of demand (read+write) misses
-system.cpu0.dcache.demand_misses::total           435                       # number of demand (read+write) misses
-system.cpu0.dcache.overall_misses::.cpu0.data          435                       # number of overall misses
-system.cpu0.dcache.overall_misses::total          435                       # number of overall misses
-system.cpu0.dcache.demand_miss_latency::.cpu0.data     32607500                       # number of demand (read+write) miss cycles
-system.cpu0.dcache.demand_miss_latency::total     32607500                       # number of demand (read+write) miss cycles
-system.cpu0.dcache.overall_miss_latency::.cpu0.data     32607500                       # number of overall miss cycles
-system.cpu0.dcache.overall_miss_latency::total     32607500                       # number of overall miss cycles
-system.cpu0.dcache.demand_accesses::.cpu0.data       392303                       # number of demand (read+write) accesses
-system.cpu0.dcache.demand_accesses::total       392303                       # number of demand (read+write) accesses
-system.cpu0.dcache.overall_accesses::.cpu0.data       392303                       # number of overall (read+write) accesses
-system.cpu0.dcache.overall_accesses::total       392303                       # number of overall (read+write) accesses
-system.cpu0.dcache.demand_miss_rate::.cpu0.data     0.001109                       # miss rate for demand accesses
-system.cpu0.dcache.demand_miss_rate::total     0.001109                       # miss rate for demand accesses
-system.cpu0.dcache.overall_miss_rate::.cpu0.data     0.001109                       # miss rate for overall accesses
-system.cpu0.dcache.overall_miss_rate::total     0.001109                       # miss rate for overall accesses
-system.cpu0.dcache.demand_avg_miss_latency::.cpu0.data 74959.770115                       # average overall miss latency
-system.cpu0.dcache.demand_avg_miss_latency::total 74959.770115                       # average overall miss latency
-system.cpu0.dcache.overall_avg_miss_latency::.cpu0.data 74959.770115                       # average overall miss latency
-system.cpu0.dcache.overall_avg_miss_latency::total 74959.770115                       # average overall miss latency
-system.cpu0.dcache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu0.dcache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu0.dcache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu0.dcache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu0.dcache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu0.dcache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu0.dcache.writebacks::.writebacks            1                       # number of writebacks
-system.cpu0.dcache.writebacks::total                1                       # number of writebacks
-system.cpu0.dcache.demand_mshr_misses::.cpu0.data          435                       # number of demand (read+write) MSHR misses
-system.cpu0.dcache.demand_mshr_misses::total          435                       # number of demand (read+write) MSHR misses
-system.cpu0.dcache.overall_mshr_misses::.cpu0.data          435                       # number of overall MSHR misses
-system.cpu0.dcache.overall_mshr_misses::total          435                       # number of overall MSHR misses
-system.cpu0.dcache.demand_mshr_miss_latency::.cpu0.data     32172500                       # number of demand (read+write) MSHR miss cycles
-system.cpu0.dcache.demand_mshr_miss_latency::total     32172500                       # number of demand (read+write) MSHR miss cycles
-system.cpu0.dcache.overall_mshr_miss_latency::.cpu0.data     32172500                       # number of overall MSHR miss cycles
-system.cpu0.dcache.overall_mshr_miss_latency::total     32172500                       # number of overall MSHR miss cycles
-system.cpu0.dcache.demand_mshr_miss_rate::.cpu0.data     0.001109                       # mshr miss rate for demand accesses
-system.cpu0.dcache.demand_mshr_miss_rate::total     0.001109                       # mshr miss rate for demand accesses
-system.cpu0.dcache.overall_mshr_miss_rate::.cpu0.data     0.001109                       # mshr miss rate for overall accesses
-system.cpu0.dcache.overall_mshr_miss_rate::total     0.001109                       # mshr miss rate for overall accesses
-system.cpu0.dcache.demand_avg_mshr_miss_latency::.cpu0.data 73959.770115                       # average overall mshr miss latency
-system.cpu0.dcache.demand_avg_mshr_miss_latency::total 73959.770115                       # average overall mshr miss latency
-system.cpu0.dcache.overall_avg_mshr_miss_latency::.cpu0.data 73959.770115                       # average overall mshr miss latency
-system.cpu0.dcache.overall_avg_mshr_miss_latency::total 73959.770115                       # average overall mshr miss latency
-system.cpu0.dcache.replacements                     7                       # number of replacements
-system.cpu0.dcache.ReadReq_hits::.cpu0.data       227523                       # number of ReadReq hits
-system.cpu0.dcache.ReadReq_hits::total         227523                       # number of ReadReq hits
-system.cpu0.dcache.ReadReq_misses::.cpu0.data          170                       # number of ReadReq misses
-system.cpu0.dcache.ReadReq_misses::total          170                       # number of ReadReq misses
-system.cpu0.dcache.ReadReq_miss_latency::.cpu0.data     13338000                       # number of ReadReq miss cycles
-system.cpu0.dcache.ReadReq_miss_latency::total     13338000                       # number of ReadReq miss cycles
-system.cpu0.dcache.ReadReq_accesses::.cpu0.data       227693                       # number of ReadReq accesses(hits+misses)
-system.cpu0.dcache.ReadReq_accesses::total       227693                       # number of ReadReq accesses(hits+misses)
-system.cpu0.dcache.ReadReq_miss_rate::.cpu0.data     0.000747                       # miss rate for ReadReq accesses
-system.cpu0.dcache.ReadReq_miss_rate::total     0.000747                       # miss rate for ReadReq accesses
-system.cpu0.dcache.ReadReq_avg_miss_latency::.cpu0.data 78458.823529                       # average ReadReq miss latency
-system.cpu0.dcache.ReadReq_avg_miss_latency::total 78458.823529                       # average ReadReq miss latency
-system.cpu0.dcache.ReadReq_mshr_misses::.cpu0.data          170                       # number of ReadReq MSHR misses
-system.cpu0.dcache.ReadReq_mshr_misses::total          170                       # number of ReadReq MSHR misses
-system.cpu0.dcache.ReadReq_mshr_miss_latency::.cpu0.data     13168000                       # number of ReadReq MSHR miss cycles
-system.cpu0.dcache.ReadReq_mshr_miss_latency::total     13168000                       # number of ReadReq MSHR miss cycles
-system.cpu0.dcache.ReadReq_mshr_miss_rate::.cpu0.data     0.000747                       # mshr miss rate for ReadReq accesses
-system.cpu0.dcache.ReadReq_mshr_miss_rate::total     0.000747                       # mshr miss rate for ReadReq accesses
-system.cpu0.dcache.ReadReq_avg_mshr_miss_latency::.cpu0.data 77458.823529                       # average ReadReq mshr miss latency
-system.cpu0.dcache.ReadReq_avg_mshr_miss_latency::total 77458.823529                       # average ReadReq mshr miss latency
-system.cpu0.dcache.WriteReq_hits::.cpu0.data       164345                       # number of WriteReq hits
-system.cpu0.dcache.WriteReq_hits::total        164345                       # number of WriteReq hits
-system.cpu0.dcache.WriteReq_misses::.cpu0.data          265                       # number of WriteReq misses
-system.cpu0.dcache.WriteReq_misses::total          265                       # number of WriteReq misses
-system.cpu0.dcache.WriteReq_miss_latency::.cpu0.data     19269500                       # number of WriteReq miss cycles
-system.cpu0.dcache.WriteReq_miss_latency::total     19269500                       # number of WriteReq miss cycles
-system.cpu0.dcache.WriteReq_accesses::.cpu0.data       164610                       # number of WriteReq accesses(hits+misses)
-system.cpu0.dcache.WriteReq_accesses::total       164610                       # number of WriteReq accesses(hits+misses)
-system.cpu0.dcache.WriteReq_miss_rate::.cpu0.data     0.001610                       # miss rate for WriteReq accesses
-system.cpu0.dcache.WriteReq_miss_rate::total     0.001610                       # miss rate for WriteReq accesses
-system.cpu0.dcache.WriteReq_avg_miss_latency::.cpu0.data 72715.094340                       # average WriteReq miss latency
-system.cpu0.dcache.WriteReq_avg_miss_latency::total 72715.094340                       # average WriteReq miss latency
-system.cpu0.dcache.WriteReq_mshr_misses::.cpu0.data          265                       # number of WriteReq MSHR misses
-system.cpu0.dcache.WriteReq_mshr_misses::total          265                       # number of WriteReq MSHR misses
-system.cpu0.dcache.WriteReq_mshr_miss_latency::.cpu0.data     19004500                       # number of WriteReq MSHR miss cycles
-system.cpu0.dcache.WriteReq_mshr_miss_latency::total     19004500                       # number of WriteReq MSHR miss cycles
-system.cpu0.dcache.WriteReq_mshr_miss_rate::.cpu0.data     0.001610                       # mshr miss rate for WriteReq accesses
-system.cpu0.dcache.WriteReq_mshr_miss_rate::total     0.001610                       # mshr miss rate for WriteReq accesses
-system.cpu0.dcache.WriteReq_avg_mshr_miss_latency::.cpu0.data 71715.094340                       # average WriteReq mshr miss latency
-system.cpu0.dcache.WriteReq_avg_mshr_miss_latency::total 71715.094340                       # average WriteReq mshr miss latency
-system.cpu0.dcache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.dcache.tags.tagsinuse          391.412897                       # Cycle average of tags in use
-system.cpu0.dcache.tags.total_refs             392303                       # Total number of references to valid blocks.
-system.cpu0.dcache.tags.sampled_refs              435                       # Sample count of references to valid blocks.
-system.cpu0.dcache.tags.avg_refs           901.845977                       # Average number of references to valid blocks.
-system.cpu0.dcache.tags.warmup_cycle           112500                       # Cycle when the warmup percentage was hit.
-system.cpu0.dcache.tags.occ_blocks::.cpu0.data   391.412897                       # Average occupied blocks per requestor
-system.cpu0.dcache.tags.occ_percent::.cpu0.data     0.382239                       # Average percentage of cache occupancy
-system.cpu0.dcache.tags.occ_percent::total     0.382239                       # Average percentage of cache occupancy
-system.cpu0.dcache.tags.occ_task_id_blocks::1024          428                       # Occupied blocks per task id
-system.cpu0.dcache.tags.age_task_id_blocks_1024::0           14                       # Occupied blocks per task id
-system.cpu0.dcache.tags.age_task_id_blocks_1024::3          414                       # Occupied blocks per task id
-system.cpu0.dcache.tags.occ_task_id_percent::1024     0.417969                       # Percentage of cache occupancy per task id
-system.cpu0.dcache.tags.tag_accesses           785041                       # Number of tag accesses
-system.cpu0.dcache.tags.data_accesses          785041                       # Number of data accesses
-system.cpu0.dcache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.dtb.rdAccesses                     227693                       # TLB accesses on read requests
-system.cpu0.dtb.wrAccesses                     164614                       # TLB accesses on write requests
-system.cpu0.dtb.rdMisses                           20                       # TLB misses on read requests
-system.cpu0.dtb.wrMisses                           16                       # TLB misses on write requests
-system.cpu0.dtb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.dtb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu0.dtb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu0.dtb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu0.dtb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu0.dtb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu0.dtb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu0.dtb_walker_cache.replacements            0                       # number of replacements
-system.cpu0.dtb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.dtb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu0.dtb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu0.dtb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu0.dtb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu0.dtb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu0.dtb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu0.dtb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu0.dtb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.icache.demand_hits::.cpu0.inst       776191                       # number of demand (read+write) hits
-system.cpu0.icache.demand_hits::total          776191                       # number of demand (read+write) hits
-system.cpu0.icache.overall_hits::.cpu0.inst       776191                       # number of overall hits
-system.cpu0.icache.overall_hits::total         776191                       # number of overall hits
-system.cpu0.icache.demand_misses::.cpu0.inst         1214                       # number of demand (read+write) misses
-system.cpu0.icache.demand_misses::total          1214                       # number of demand (read+write) misses
-system.cpu0.icache.overall_misses::.cpu0.inst         1214                       # number of overall misses
-system.cpu0.icache.overall_misses::total         1214                       # number of overall misses
-system.cpu0.icache.demand_miss_latency::.cpu0.inst     67759000                       # number of demand (read+write) miss cycles
-system.cpu0.icache.demand_miss_latency::total     67759000                       # number of demand (read+write) miss cycles
-system.cpu0.icache.overall_miss_latency::.cpu0.inst     67759000                       # number of overall miss cycles
-system.cpu0.icache.overall_miss_latency::total     67759000                       # number of overall miss cycles
-system.cpu0.icache.demand_accesses::.cpu0.inst       777405                       # number of demand (read+write) accesses
-system.cpu0.icache.demand_accesses::total       777405                       # number of demand (read+write) accesses
-system.cpu0.icache.overall_accesses::.cpu0.inst       777405                       # number of overall (read+write) accesses
-system.cpu0.icache.overall_accesses::total       777405                       # number of overall (read+write) accesses
-system.cpu0.icache.demand_miss_rate::.cpu0.inst     0.001562                       # miss rate for demand accesses
-system.cpu0.icache.demand_miss_rate::total     0.001562                       # miss rate for demand accesses
-system.cpu0.icache.overall_miss_rate::.cpu0.inst     0.001562                       # miss rate for overall accesses
-system.cpu0.icache.overall_miss_rate::total     0.001562                       # miss rate for overall accesses
-system.cpu0.icache.demand_avg_miss_latency::.cpu0.inst 55814.662273                       # average overall miss latency
-system.cpu0.icache.demand_avg_miss_latency::total 55814.662273                       # average overall miss latency
-system.cpu0.icache.overall_avg_miss_latency::.cpu0.inst 55814.662273                       # average overall miss latency
-system.cpu0.icache.overall_avg_miss_latency::total 55814.662273                       # average overall miss latency
-system.cpu0.icache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu0.icache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu0.icache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu0.icache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu0.icache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu0.icache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu0.icache.writebacks::.writebacks          731                       # number of writebacks
-system.cpu0.icache.writebacks::total              731                       # number of writebacks
-system.cpu0.icache.demand_mshr_misses::.cpu0.inst         1214                       # number of demand (read+write) MSHR misses
-system.cpu0.icache.demand_mshr_misses::total         1214                       # number of demand (read+write) MSHR misses
-system.cpu0.icache.overall_mshr_misses::.cpu0.inst         1214                       # number of overall MSHR misses
-system.cpu0.icache.overall_mshr_misses::total         1214                       # number of overall MSHR misses
-system.cpu0.icache.demand_mshr_miss_latency::.cpu0.inst     66545000                       # number of demand (read+write) MSHR miss cycles
-system.cpu0.icache.demand_mshr_miss_latency::total     66545000                       # number of demand (read+write) MSHR miss cycles
-system.cpu0.icache.overall_mshr_miss_latency::.cpu0.inst     66545000                       # number of overall MSHR miss cycles
-system.cpu0.icache.overall_mshr_miss_latency::total     66545000                       # number of overall MSHR miss cycles
-system.cpu0.icache.demand_mshr_miss_rate::.cpu0.inst     0.001562                       # mshr miss rate for demand accesses
-system.cpu0.icache.demand_mshr_miss_rate::total     0.001562                       # mshr miss rate for demand accesses
-system.cpu0.icache.overall_mshr_miss_rate::.cpu0.inst     0.001562                       # mshr miss rate for overall accesses
-system.cpu0.icache.overall_mshr_miss_rate::total     0.001562                       # mshr miss rate for overall accesses
-system.cpu0.icache.demand_avg_mshr_miss_latency::.cpu0.inst 54814.662273                       # average overall mshr miss latency
-system.cpu0.icache.demand_avg_mshr_miss_latency::total 54814.662273                       # average overall mshr miss latency
-system.cpu0.icache.overall_avg_mshr_miss_latency::.cpu0.inst 54814.662273                       # average overall mshr miss latency
-system.cpu0.icache.overall_avg_mshr_miss_latency::total 54814.662273                       # average overall mshr miss latency
-system.cpu0.icache.replacements                   731                       # number of replacements
-system.cpu0.icache.ReadReq_hits::.cpu0.inst       776191                       # number of ReadReq hits
-system.cpu0.icache.ReadReq_hits::total         776191                       # number of ReadReq hits
-system.cpu0.icache.ReadReq_misses::.cpu0.inst         1214                       # number of ReadReq misses
-system.cpu0.icache.ReadReq_misses::total         1214                       # number of ReadReq misses
-system.cpu0.icache.ReadReq_miss_latency::.cpu0.inst     67759000                       # number of ReadReq miss cycles
-system.cpu0.icache.ReadReq_miss_latency::total     67759000                       # number of ReadReq miss cycles
-system.cpu0.icache.ReadReq_accesses::.cpu0.inst       777405                       # number of ReadReq accesses(hits+misses)
-system.cpu0.icache.ReadReq_accesses::total       777405                       # number of ReadReq accesses(hits+misses)
-system.cpu0.icache.ReadReq_miss_rate::.cpu0.inst     0.001562                       # miss rate for ReadReq accesses
-system.cpu0.icache.ReadReq_miss_rate::total     0.001562                       # miss rate for ReadReq accesses
-system.cpu0.icache.ReadReq_avg_miss_latency::.cpu0.inst 55814.662273                       # average ReadReq miss latency
-system.cpu0.icache.ReadReq_avg_miss_latency::total 55814.662273                       # average ReadReq miss latency
-system.cpu0.icache.ReadReq_mshr_misses::.cpu0.inst         1214                       # number of ReadReq MSHR misses
-system.cpu0.icache.ReadReq_mshr_misses::total         1214                       # number of ReadReq MSHR misses
-system.cpu0.icache.ReadReq_mshr_miss_latency::.cpu0.inst     66545000                       # number of ReadReq MSHR miss cycles
-system.cpu0.icache.ReadReq_mshr_miss_latency::total     66545000                       # number of ReadReq MSHR miss cycles
-system.cpu0.icache.ReadReq_mshr_miss_rate::.cpu0.inst     0.001562                       # mshr miss rate for ReadReq accesses
-system.cpu0.icache.ReadReq_mshr_miss_rate::total     0.001562                       # mshr miss rate for ReadReq accesses
-system.cpu0.icache.ReadReq_avg_mshr_miss_latency::.cpu0.inst 54814.662273                       # average ReadReq mshr miss latency
-system.cpu0.icache.ReadReq_avg_mshr_miss_latency::total 54814.662273                       # average ReadReq mshr miss latency
-system.cpu0.icache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.icache.tags.tagsinuse          451.119631                       # Cycle average of tags in use
-system.cpu0.icache.tags.total_refs             777405                       # Total number of references to valid blocks.
-system.cpu0.icache.tags.sampled_refs             1214                       # Sample count of references to valid blocks.
-system.cpu0.icache.tags.avg_refs           640.366557                       # Average number of references to valid blocks.
-system.cpu0.icache.tags.warmup_cycle            24500                       # Cycle when the warmup percentage was hit.
-system.cpu0.icache.tags.occ_blocks::.cpu0.inst   451.119631                       # Average occupied blocks per requestor
-system.cpu0.icache.tags.occ_percent::.cpu0.inst     0.881093                       # Average percentage of cache occupancy
-system.cpu0.icache.tags.occ_percent::total     0.881093                       # Average percentage of cache occupancy
-system.cpu0.icache.tags.occ_task_id_blocks::1024          483                       # Occupied blocks per task id
-system.cpu0.icache.tags.age_task_id_blocks_1024::0           55                       # Occupied blocks per task id
-system.cpu0.icache.tags.age_task_id_blocks_1024::1            2                       # Occupied blocks per task id
-system.cpu0.icache.tags.age_task_id_blocks_1024::3          426                       # Occupied blocks per task id
-system.cpu0.icache.tags.occ_task_id_percent::1024     0.943359                       # Percentage of cache occupancy per task id
-system.cpu0.icache.tags.tag_accesses          1556024                       # Number of tag accesses
-system.cpu0.icache.tags.data_accesses         1556024                       # Number of data accesses
-system.cpu0.icache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.interrupts.clk_domain.clock          8000                       # Clock period in ticks
-system.cpu0.itb.rdAccesses                          0                       # TLB accesses on read requests
-system.cpu0.itb.wrAccesses                     777405                       # TLB accesses on write requests
-system.cpu0.itb.rdMisses                            0                       # TLB misses on read requests
-system.cpu0.itb.wrMisses                           93                       # TLB misses on write requests
-system.cpu0.itb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.itb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu0.itb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu0.itb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu0.itb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu0.itb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu0.itb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu0.itb_walker_cache.replacements            0                       # number of replacements
-system.cpu0.itb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.itb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu0.itb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu0.itb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu0.itb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu0.itb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu0.itb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu0.itb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu0.itb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.power_state.pwrStateResidencyTicks::ON   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu0.thread0.numInsts                        0                       # Number of Instructions committed
-system.cpu0.thread0.numOps                          0                       # Number of Ops committed
-system.cpu0.thread0.numMemRefs                      0                       # Number of Memory References
-system.cpu1.dcache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu1.dcache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu1.dcache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu1.dcache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu1.dcache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu1.dcache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu1.dcache.replacements                     0                       # number of replacements
-system.cpu1.dcache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.dcache.tags.tagsinuse                   0                       # Cycle average of tags in use
-system.cpu1.dcache.tags.total_refs                  0                       # Total number of references to valid blocks.
-system.cpu1.dcache.tags.sampled_refs                0                       # Sample count of references to valid blocks.
-system.cpu1.dcache.tags.avg_refs                  nan                       # Average number of references to valid blocks.
-system.cpu1.dcache.tags.warmup_cycle                0                       # Cycle when the warmup percentage was hit.
-system.cpu1.dcache.tags.tag_accesses                0                       # Number of tag accesses
-system.cpu1.dcache.tags.data_accesses               0                       # Number of data accesses
-system.cpu1.dcache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.dtb.rdAccesses                          0                       # TLB accesses on read requests
-system.cpu1.dtb.wrAccesses                          0                       # TLB accesses on write requests
-system.cpu1.dtb.rdMisses                            0                       # TLB misses on read requests
-system.cpu1.dtb.wrMisses                            0                       # TLB misses on write requests
-system.cpu1.dtb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.dtb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu1.dtb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu1.dtb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu1.dtb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu1.dtb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu1.dtb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu1.dtb_walker_cache.replacements            0                       # number of replacements
-system.cpu1.dtb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.dtb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu1.dtb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu1.dtb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu1.dtb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu1.dtb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu1.dtb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu1.dtb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu1.dtb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.icache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu1.icache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu1.icache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu1.icache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu1.icache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu1.icache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu1.icache.replacements                     0                       # number of replacements
-system.cpu1.icache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.icache.tags.tagsinuse                   0                       # Cycle average of tags in use
-system.cpu1.icache.tags.total_refs                  0                       # Total number of references to valid blocks.
-system.cpu1.icache.tags.sampled_refs                0                       # Sample count of references to valid blocks.
-system.cpu1.icache.tags.avg_refs                  nan                       # Average number of references to valid blocks.
-system.cpu1.icache.tags.warmup_cycle                0                       # Cycle when the warmup percentage was hit.
-system.cpu1.icache.tags.tag_accesses                0                       # Number of tag accesses
-system.cpu1.icache.tags.data_accesses               0                       # Number of data accesses
-system.cpu1.icache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.interrupts.clk_domain.clock          8000                       # Clock period in ticks
-system.cpu1.itb.rdAccesses                          0                       # TLB accesses on read requests
-system.cpu1.itb.wrAccesses                          0                       # TLB accesses on write requests
-system.cpu1.itb.rdMisses                            0                       # TLB misses on read requests
-system.cpu1.itb.wrMisses                            0                       # TLB misses on write requests
-system.cpu1.itb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.itb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu1.itb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu1.itb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu1.itb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu1.itb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu1.itb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu1.itb_walker_cache.replacements            0                       # number of replacements
-system.cpu1.itb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.itb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu1.itb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu1.itb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu1.itb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu1.itb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu1.itb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu1.itb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu1.itb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.power_state.pwrStateResidencyTicks::ON   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu1.thread0.numInsts                        0                       # Number of Instructions committed
-system.cpu1.thread0.numOps                          0                       # Number of Ops committed
-system.cpu1.thread0.numMemRefs                      0                       # Number of Memory References
-system.cpu2.dcache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu2.dcache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu2.dcache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu2.dcache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu2.dcache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu2.dcache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu2.dcache.replacements                     0                       # number of replacements
-system.cpu2.dcache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.dcache.tags.tagsinuse                   0                       # Cycle average of tags in use
-system.cpu2.dcache.tags.total_refs                  0                       # Total number of references to valid blocks.
-system.cpu2.dcache.tags.sampled_refs                0                       # Sample count of references to valid blocks.
-system.cpu2.dcache.tags.avg_refs                  nan                       # Average number of references to valid blocks.
-system.cpu2.dcache.tags.warmup_cycle                0                       # Cycle when the warmup percentage was hit.
-system.cpu2.dcache.tags.tag_accesses                0                       # Number of tag accesses
-system.cpu2.dcache.tags.data_accesses               0                       # Number of data accesses
-system.cpu2.dcache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.dtb.rdAccesses                          0                       # TLB accesses on read requests
-system.cpu2.dtb.wrAccesses                          0                       # TLB accesses on write requests
-system.cpu2.dtb.rdMisses                            0                       # TLB misses on read requests
-system.cpu2.dtb.wrMisses                            0                       # TLB misses on write requests
-system.cpu2.dtb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.dtb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu2.dtb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu2.dtb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu2.dtb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu2.dtb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu2.dtb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu2.dtb_walker_cache.replacements            0                       # number of replacements
-system.cpu2.dtb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.dtb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu2.dtb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu2.dtb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu2.dtb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu2.dtb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu2.dtb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu2.dtb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu2.dtb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.icache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu2.icache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu2.icache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu2.icache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu2.icache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu2.icache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu2.icache.replacements                     0                       # number of replacements
-system.cpu2.icache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.icache.tags.tagsinuse                   0                       # Cycle average of tags in use
-system.cpu2.icache.tags.total_refs                  0                       # Total number of references to valid blocks.
-system.cpu2.icache.tags.sampled_refs                0                       # Sample count of references to valid blocks.
-system.cpu2.icache.tags.avg_refs                  nan                       # Average number of references to valid blocks.
-system.cpu2.icache.tags.warmup_cycle                0                       # Cycle when the warmup percentage was hit.
-system.cpu2.icache.tags.tag_accesses                0                       # Number of tag accesses
-system.cpu2.icache.tags.data_accesses               0                       # Number of data accesses
-system.cpu2.icache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.interrupts.clk_domain.clock          8000                       # Clock period in ticks
-system.cpu2.itb.rdAccesses                          0                       # TLB accesses on read requests
-system.cpu2.itb.wrAccesses                          0                       # TLB accesses on write requests
-system.cpu2.itb.rdMisses                            0                       # TLB misses on read requests
-system.cpu2.itb.wrMisses                            0                       # TLB misses on write requests
-system.cpu2.itb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.itb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu2.itb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu2.itb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu2.itb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu2.itb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu2.itb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu2.itb_walker_cache.replacements            0                       # number of replacements
-system.cpu2.itb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.itb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu2.itb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu2.itb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu2.itb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu2.itb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu2.itb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu2.itb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu2.itb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.power_state.pwrStateResidencyTicks::ON   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu2.thread10496.numInsts                    0                       # Number of Instructions committed
-system.cpu2.thread10496.numOps                      0                       # Number of Ops committed
-system.cpu2.thread10496.numMemRefs                  0                       # Number of Memory References
-system.cpu3.dcache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu3.dcache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu3.dcache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu3.dcache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu3.dcache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu3.dcache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu3.dcache.replacements                     0                       # number of replacements
-system.cpu3.dcache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.dcache.tags.tagsinuse                   0                       # Cycle average of tags in use
-system.cpu3.dcache.tags.total_refs                  0                       # Total number of references to valid blocks.
-system.cpu3.dcache.tags.sampled_refs                0                       # Sample count of references to valid blocks.
-system.cpu3.dcache.tags.avg_refs                  nan                       # Average number of references to valid blocks.
-system.cpu3.dcache.tags.warmup_cycle                0                       # Cycle when the warmup percentage was hit.
-system.cpu3.dcache.tags.tag_accesses                0                       # Number of tag accesses
-system.cpu3.dcache.tags.data_accesses               0                       # Number of data accesses
-system.cpu3.dcache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.dtb.rdAccesses                          0                       # TLB accesses on read requests
-system.cpu3.dtb.wrAccesses                          0                       # TLB accesses on write requests
-system.cpu3.dtb.rdMisses                            0                       # TLB misses on read requests
-system.cpu3.dtb.wrMisses                            0                       # TLB misses on write requests
-system.cpu3.dtb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.dtb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu3.dtb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu3.dtb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu3.dtb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu3.dtb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu3.dtb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu3.dtb_walker_cache.replacements            0                       # number of replacements
-system.cpu3.dtb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.dtb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu3.dtb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu3.dtb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu3.dtb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu3.dtb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu3.dtb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu3.dtb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu3.dtb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.icache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu3.icache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu3.icache.blocked::no_mshrs                0                       # number of cycles access was blocked
-system.cpu3.icache.blocked::no_targets              0                       # number of cycles access was blocked
-system.cpu3.icache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu3.icache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu3.icache.replacements                     0                       # number of replacements
-system.cpu3.icache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.icache.tags.tagsinuse                   0                       # Cycle average of tags in use
-system.cpu3.icache.tags.total_refs                  0                       # Total number of references to valid blocks.
-system.cpu3.icache.tags.sampled_refs                0                       # Sample count of references to valid blocks.
-system.cpu3.icache.tags.avg_refs                  nan                       # Average number of references to valid blocks.
-system.cpu3.icache.tags.warmup_cycle                0                       # Cycle when the warmup percentage was hit.
-system.cpu3.icache.tags.tag_accesses                0                       # Number of tag accesses
-system.cpu3.icache.tags.data_accesses               0                       # Number of data accesses
-system.cpu3.icache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.interrupts.clk_domain.clock          8000                       # Clock period in ticks
-system.cpu3.itb.rdAccesses                          0                       # TLB accesses on read requests
-system.cpu3.itb.wrAccesses                          0                       # TLB accesses on write requests
-system.cpu3.itb.rdMisses                            0                       # TLB misses on read requests
-system.cpu3.itb.wrMisses                            0                       # TLB misses on write requests
-system.cpu3.itb.walker.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.itb_walker_cache.blocked_cycles::no_mshrs            0                       # number of cycles access was blocked
-system.cpu3.itb_walker_cache.blocked_cycles::no_targets            0                       # number of cycles access was blocked
-system.cpu3.itb_walker_cache.blocked::no_mshrs            0                       # number of cycles access was blocked
-system.cpu3.itb_walker_cache.blocked::no_targets            0                       # number of cycles access was blocked
-system.cpu3.itb_walker_cache.avg_blocked_cycles::no_mshrs          nan                       # average number of cycles each access was blocked
-system.cpu3.itb_walker_cache.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.cpu3.itb_walker_cache.replacements            0                       # number of replacements
-system.cpu3.itb_walker_cache.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.itb_walker_cache.tags.tagsinuse            0                       # Cycle average of tags in use
-system.cpu3.itb_walker_cache.tags.total_refs            0                       # Total number of references to valid blocks.
-system.cpu3.itb_walker_cache.tags.sampled_refs            0                       # Sample count of references to valid blocks.
-system.cpu3.itb_walker_cache.tags.avg_refs          nan                       # Average number of references to valid blocks.
-system.cpu3.itb_walker_cache.tags.warmup_cycle            0                       # Cycle when the warmup percentage was hit.
-system.cpu3.itb_walker_cache.tags.tag_accesses            0                       # Number of tag accesses
-system.cpu3.itb_walker_cache.tags.data_accesses            0                       # Number of data accesses
-system.cpu3.itb_walker_cache.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.power_state.pwrStateResidencyTicks::ON   1268411500                       # Cumulative time (in ticks) in various power states
-system.cpu3.thread0.numInsts                        0                       # Number of Instructions committed
-system.cpu3.thread0.numOps                          0                       # Number of Ops committed
-system.cpu3.thread0.numMemRefs                      0                       # Number of Memory References
-system.cpu_clk_domain.clock                       500                       # Clock period in ticks
-system.cpu_voltage_domain.voltage                   1                       # Voltage in Volts
-system.l2.demand_hits::.cpu0.inst                 338                       # number of demand (read+write) hits
-system.l2.demand_hits::.cpu0.data                   1                       # number of demand (read+write) hits
-system.l2.demand_hits::total                      339                       # number of demand (read+write) hits
-system.l2.overall_hits::.cpu0.inst                338                       # number of overall hits
-system.l2.overall_hits::.cpu0.data                  1                       # number of overall hits
-system.l2.overall_hits::total                     339                       # number of overall hits
-system.l2.demand_misses::.cpu0.inst               876                       # number of demand (read+write) misses
-system.l2.demand_misses::.cpu0.data               434                       # number of demand (read+write) misses
-system.l2.demand_misses::total                   1310                       # number of demand (read+write) misses
-system.l2.overall_misses::.cpu0.inst              876                       # number of overall misses
-system.l2.overall_misses::.cpu0.data              434                       # number of overall misses
-system.l2.overall_misses::total                  1310                       # number of overall misses
-system.l2.demand_miss_latency::.cpu0.inst     61171500                       # number of demand (read+write) miss cycles
-system.l2.demand_miss_latency::.cpu0.data     31507500                       # number of demand (read+write) miss cycles
-system.l2.demand_miss_latency::total         92679000                       # number of demand (read+write) miss cycles
-system.l2.overall_miss_latency::.cpu0.inst     61171500                       # number of overall miss cycles
-system.l2.overall_miss_latency::.cpu0.data     31507500                       # number of overall miss cycles
-system.l2.overall_miss_latency::total        92679000                       # number of overall miss cycles
-system.l2.demand_accesses::.cpu0.inst            1214                       # number of demand (read+write) accesses
-system.l2.demand_accesses::.cpu0.data             435                       # number of demand (read+write) accesses
-system.l2.demand_accesses::total                 1649                       # number of demand (read+write) accesses
-system.l2.overall_accesses::.cpu0.inst           1214                       # number of overall (read+write) accesses
-system.l2.overall_accesses::.cpu0.data            435                       # number of overall (read+write) accesses
-system.l2.overall_accesses::total                1649                       # number of overall (read+write) accesses
-system.l2.demand_miss_rate::.cpu0.inst       0.721582                       # miss rate for demand accesses
-system.l2.demand_miss_rate::.cpu0.data       0.997701                       # miss rate for demand accesses
-system.l2.demand_miss_rate::total            0.794421                       # miss rate for demand accesses
-system.l2.overall_miss_rate::.cpu0.inst      0.721582                       # miss rate for overall accesses
-system.l2.overall_miss_rate::.cpu0.data      0.997701                       # miss rate for overall accesses
-system.l2.overall_miss_rate::total           0.794421                       # miss rate for overall accesses
-system.l2.demand_avg_miss_latency::.cpu0.inst 69830.479452                       # average overall miss latency
-system.l2.demand_avg_miss_latency::.cpu0.data 72597.926267                       # average overall miss latency
-system.l2.demand_avg_miss_latency::total 70747.328244                       # average overall miss latency
-system.l2.overall_avg_miss_latency::.cpu0.inst 69830.479452                       # average overall miss latency
-system.l2.overall_avg_miss_latency::.cpu0.data 72597.926267                       # average overall miss latency
-system.l2.overall_avg_miss_latency::total 70747.328244                       # average overall miss latency
-system.l2.blocked_cycles::no_mshrs                  0                       # number of cycles access was blocked
-system.l2.blocked_cycles::no_targets                0                       # number of cycles access was blocked
-system.l2.blocked::no_mshrs                         0                       # number of cycles access was blocked
-system.l2.blocked::no_targets                       0                       # number of cycles access was blocked
-system.l2.avg_blocked_cycles::no_mshrs            nan                       # average number of cycles each access was blocked
-system.l2.avg_blocked_cycles::no_targets          nan                       # average number of cycles each access was blocked
-system.l2.demand_mshr_misses::.cpu0.inst          876                       # number of demand (read+write) MSHR misses
-system.l2.demand_mshr_misses::.cpu0.data          434                       # number of demand (read+write) MSHR misses
-system.l2.demand_mshr_misses::total              1310                       # number of demand (read+write) MSHR misses
-system.l2.overall_mshr_misses::.cpu0.inst          876                       # number of overall MSHR misses
-system.l2.overall_mshr_misses::.cpu0.data          434                       # number of overall MSHR misses
-system.l2.overall_mshr_misses::total             1310                       # number of overall MSHR misses
-system.l2.demand_mshr_miss_latency::.cpu0.inst     52411500                       # number of demand (read+write) MSHR miss cycles
-system.l2.demand_mshr_miss_latency::.cpu0.data     27167500                       # number of demand (read+write) MSHR miss cycles
-system.l2.demand_mshr_miss_latency::total     79579000                       # number of demand (read+write) MSHR miss cycles
-system.l2.overall_mshr_miss_latency::.cpu0.inst     52411500                       # number of overall MSHR miss cycles
-system.l2.overall_mshr_miss_latency::.cpu0.data     27167500                       # number of overall MSHR miss cycles
-system.l2.overall_mshr_miss_latency::total     79579000                       # number of overall MSHR miss cycles
-system.l2.demand_mshr_miss_rate::.cpu0.inst     0.721582                       # mshr miss rate for demand accesses
-system.l2.demand_mshr_miss_rate::.cpu0.data     0.997701                       # mshr miss rate for demand accesses
-system.l2.demand_mshr_miss_rate::total       0.794421                       # mshr miss rate for demand accesses
-system.l2.overall_mshr_miss_rate::.cpu0.inst     0.721582                       # mshr miss rate for overall accesses
-system.l2.overall_mshr_miss_rate::.cpu0.data     0.997701                       # mshr miss rate for overall accesses
-system.l2.overall_mshr_miss_rate::total      0.794421                       # mshr miss rate for overall accesses
-system.l2.demand_avg_mshr_miss_latency::.cpu0.inst 59830.479452                       # average overall mshr miss latency
-system.l2.demand_avg_mshr_miss_latency::.cpu0.data 62597.926267                       # average overall mshr miss latency
-system.l2.demand_avg_mshr_miss_latency::total 60747.328244                       # average overall mshr miss latency
-system.l2.overall_avg_mshr_miss_latency::.cpu0.inst 59830.479452                       # average overall mshr miss latency
-system.l2.overall_avg_mshr_miss_latency::.cpu0.data 62597.926267                       # average overall mshr miss latency
-system.l2.overall_avg_mshr_miss_latency::total 60747.328244                       # average overall mshr miss latency
-system.l2.replacements                              0                       # number of replacements
-system.l2.WritebackDirty_hits::.writebacks            1                       # number of WritebackDirty hits
-system.l2.WritebackDirty_hits::total                1                       # number of WritebackDirty hits
-system.l2.WritebackDirty_accesses::.writebacks            1                       # number of WritebackDirty accesses(hits+misses)
-system.l2.WritebackDirty_accesses::total            1                       # number of WritebackDirty accesses(hits+misses)
-system.l2.WritebackClean_hits::.writebacks          731                       # number of WritebackClean hits
-system.l2.WritebackClean_hits::total              731                       # number of WritebackClean hits
-system.l2.WritebackClean_accesses::.writebacks          731                       # number of WritebackClean accesses(hits+misses)
-system.l2.WritebackClean_accesses::total          731                       # number of WritebackClean accesses(hits+misses)
-system.l2.ReadExReq_misses::.cpu0.data            265                       # number of ReadExReq misses
-system.l2.ReadExReq_misses::total                 265                       # number of ReadExReq misses
-system.l2.ReadExReq_miss_latency::.cpu0.data     18605500                       # number of ReadExReq miss cycles
-system.l2.ReadExReq_miss_latency::total      18605500                       # number of ReadExReq miss cycles
-system.l2.ReadExReq_accesses::.cpu0.data          265                       # number of ReadExReq accesses(hits+misses)
-system.l2.ReadExReq_accesses::total               265                       # number of ReadExReq accesses(hits+misses)
-system.l2.ReadExReq_miss_rate::.cpu0.data            1                       # miss rate for ReadExReq accesses
-system.l2.ReadExReq_miss_rate::total                1                       # miss rate for ReadExReq accesses
-system.l2.ReadExReq_avg_miss_latency::.cpu0.data 70209.433962                       # average ReadExReq miss latency
-system.l2.ReadExReq_avg_miss_latency::total 70209.433962                       # average ReadExReq miss latency
-system.l2.ReadExReq_mshr_misses::.cpu0.data          265                       # number of ReadExReq MSHR misses
-system.l2.ReadExReq_mshr_misses::total            265                       # number of ReadExReq MSHR misses
-system.l2.ReadExReq_mshr_miss_latency::.cpu0.data     15955500                       # number of ReadExReq MSHR miss cycles
-system.l2.ReadExReq_mshr_miss_latency::total     15955500                       # number of ReadExReq MSHR miss cycles
-system.l2.ReadExReq_mshr_miss_rate::.cpu0.data            1                       # mshr miss rate for ReadExReq accesses
-system.l2.ReadExReq_mshr_miss_rate::total            1                       # mshr miss rate for ReadExReq accesses
-system.l2.ReadExReq_avg_mshr_miss_latency::.cpu0.data 60209.433962                       # average ReadExReq mshr miss latency
-system.l2.ReadExReq_avg_mshr_miss_latency::total 60209.433962                       # average ReadExReq mshr miss latency
-system.l2.ReadCleanReq_hits::.cpu0.inst           338                       # number of ReadCleanReq hits
-system.l2.ReadCleanReq_hits::total                338                       # number of ReadCleanReq hits
-system.l2.ReadCleanReq_misses::.cpu0.inst          876                       # number of ReadCleanReq misses
-system.l2.ReadCleanReq_misses::total              876                       # number of ReadCleanReq misses
-system.l2.ReadCleanReq_miss_latency::.cpu0.inst     61171500                       # number of ReadCleanReq miss cycles
-system.l2.ReadCleanReq_miss_latency::total     61171500                       # number of ReadCleanReq miss cycles
-system.l2.ReadCleanReq_accesses::.cpu0.inst         1214                       # number of ReadCleanReq accesses(hits+misses)
-system.l2.ReadCleanReq_accesses::total           1214                       # number of ReadCleanReq accesses(hits+misses)
-system.l2.ReadCleanReq_miss_rate::.cpu0.inst     0.721582                       # miss rate for ReadCleanReq accesses
-system.l2.ReadCleanReq_miss_rate::total      0.721582                       # miss rate for ReadCleanReq accesses
-system.l2.ReadCleanReq_avg_miss_latency::.cpu0.inst 69830.479452                       # average ReadCleanReq miss latency
-system.l2.ReadCleanReq_avg_miss_latency::total 69830.479452                       # average ReadCleanReq miss latency
-system.l2.ReadCleanReq_mshr_misses::.cpu0.inst          876                       # number of ReadCleanReq MSHR misses
-system.l2.ReadCleanReq_mshr_misses::total          876                       # number of ReadCleanReq MSHR misses
-system.l2.ReadCleanReq_mshr_miss_latency::.cpu0.inst     52411500                       # number of ReadCleanReq MSHR miss cycles
-system.l2.ReadCleanReq_mshr_miss_latency::total     52411500                       # number of ReadCleanReq MSHR miss cycles
-system.l2.ReadCleanReq_mshr_miss_rate::.cpu0.inst     0.721582                       # mshr miss rate for ReadCleanReq accesses
-system.l2.ReadCleanReq_mshr_miss_rate::total     0.721582                       # mshr miss rate for ReadCleanReq accesses
-system.l2.ReadCleanReq_avg_mshr_miss_latency::.cpu0.inst 59830.479452                       # average ReadCleanReq mshr miss latency
-system.l2.ReadCleanReq_avg_mshr_miss_latency::total 59830.479452                       # average ReadCleanReq mshr miss latency
-system.l2.ReadSharedReq_hits::.cpu0.data            1                       # number of ReadSharedReq hits
-system.l2.ReadSharedReq_hits::total                 1                       # number of ReadSharedReq hits
-system.l2.ReadSharedReq_misses::.cpu0.data          169                       # number of ReadSharedReq misses
-system.l2.ReadSharedReq_misses::total             169                       # number of ReadSharedReq misses
-system.l2.ReadSharedReq_miss_latency::.cpu0.data     12902000                       # number of ReadSharedReq miss cycles
-system.l2.ReadSharedReq_miss_latency::total     12902000                       # number of ReadSharedReq miss cycles
-system.l2.ReadSharedReq_accesses::.cpu0.data          170                       # number of ReadSharedReq accesses(hits+misses)
-system.l2.ReadSharedReq_accesses::total           170                       # number of ReadSharedReq accesses(hits+misses)
-system.l2.ReadSharedReq_miss_rate::.cpu0.data     0.994118                       # miss rate for ReadSharedReq accesses
-system.l2.ReadSharedReq_miss_rate::total     0.994118                       # miss rate for ReadSharedReq accesses
-system.l2.ReadSharedReq_avg_miss_latency::.cpu0.data 76343.195266                       # average ReadSharedReq miss latency
-system.l2.ReadSharedReq_avg_miss_latency::total 76343.195266                       # average ReadSharedReq miss latency
-system.l2.ReadSharedReq_mshr_misses::.cpu0.data          169                       # number of ReadSharedReq MSHR misses
-system.l2.ReadSharedReq_mshr_misses::total          169                       # number of ReadSharedReq MSHR misses
-system.l2.ReadSharedReq_mshr_miss_latency::.cpu0.data     11212000                       # number of ReadSharedReq MSHR miss cycles
-system.l2.ReadSharedReq_mshr_miss_latency::total     11212000                       # number of ReadSharedReq MSHR miss cycles
-system.l2.ReadSharedReq_mshr_miss_rate::.cpu0.data     0.994118                       # mshr miss rate for ReadSharedReq accesses
-system.l2.ReadSharedReq_mshr_miss_rate::total     0.994118                       # mshr miss rate for ReadSharedReq accesses
-system.l2.ReadSharedReq_avg_mshr_miss_latency::.cpu0.data 66343.195266                       # average ReadSharedReq mshr miss latency
-system.l2.ReadSharedReq_avg_mshr_miss_latency::total 66343.195266                       # average ReadSharedReq mshr miss latency
-system.l2.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.l2.tags.tagsinuse                  1157.328351                       # Cycle average of tags in use
-system.l2.tags.total_refs                        2387                       # Total number of references to valid blocks.
-system.l2.tags.sampled_refs                      1310                       # Sample count of references to valid blocks.
-system.l2.tags.avg_refs                      1.822137                       # Average number of references to valid blocks.
-system.l2.tags.warmup_cycle                     14000                       # Cycle when the warmup percentage was hit.
-system.l2.tags.occ_blocks::.cpu0.inst      760.556538                       # Average occupied blocks per requestor
-system.l2.tags.occ_blocks::.cpu0.data      396.771813                       # Average occupied blocks per requestor
-system.l2.tags.occ_percent::.cpu0.inst       0.023210                       # Average percentage of cache occupancy
-system.l2.tags.occ_percent::.cpu0.data       0.012109                       # Average percentage of cache occupancy
-system.l2.tags.occ_percent::total            0.035319                       # Average percentage of cache occupancy
-system.l2.tags.occ_task_id_blocks::1024          1310                       # Occupied blocks per task id
-system.l2.tags.age_task_id_blocks_1024::0           66                       # Occupied blocks per task id
-system.l2.tags.age_task_id_blocks_1024::1            1                       # Occupied blocks per task id
-system.l2.tags.age_task_id_blocks_1024::3         1243                       # Occupied blocks per task id
-system.l2.tags.occ_task_id_percent::1024     0.039978                       # Percentage of cache occupancy per task id
-system.l2.tags.tag_accesses                     20406                       # Number of tag accesses
-system.l2.tags.data_accesses                    20406                       # Number of data accesses
-system.l2.tags.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.mem_ctrls.bytes_read::.cpu0.inst         56064                       # Number of bytes read from this memory
-system.mem_ctrls.bytes_read::.cpu0.data         27776                       # Number of bytes read from this memory
-system.mem_ctrls.bytes_read::total              83840                       # Number of bytes read from this memory
-system.mem_ctrls.bytes_inst_read::.cpu0.inst        56064                       # Number of instructions bytes read from this memory
-system.mem_ctrls.bytes_inst_read::total         56064                       # Number of instructions bytes read from this memory
-system.mem_ctrls.num_reads::.cpu0.inst            876                       # Number of read requests responded to by this memory
-system.mem_ctrls.num_reads::.cpu0.data            434                       # Number of read requests responded to by this memory
-system.mem_ctrls.num_reads::total                1310                       # Number of read requests responded to by this memory
-system.mem_ctrls.bw_read::.cpu0.inst         44200167                       # Total read bandwidth from this memory (bytes/s)
-system.mem_ctrls.bw_read::.cpu0.data         21898256                       # Total read bandwidth from this memory (bytes/s)
-system.mem_ctrls.bw_read::total              66098423                       # Total read bandwidth from this memory (bytes/s)
-system.mem_ctrls.bw_inst_read::.cpu0.inst     44200167                       # Instruction read bandwidth from this memory (bytes/s)
-system.mem_ctrls.bw_inst_read::total         44200167                       # Instruction read bandwidth from this memory (bytes/s)
-system.mem_ctrls.bw_total::.cpu0.inst        44200167                       # Total bandwidth to/from this memory (bytes/s)
-system.mem_ctrls.bw_total::.cpu0.data        21898256                       # Total bandwidth to/from this memory (bytes/s)
-system.mem_ctrls.bw_total::total             66098423                       # Total bandwidth to/from this memory (bytes/s)
-system.mem_ctrls.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.membus.trans_dist::ReadResp               1045                       # Transaction distribution
-system.membus.trans_dist::ReadExReq               265                       # Transaction distribution
-system.membus.trans_dist::ReadExResp              265                       # Transaction distribution
-system.membus.trans_dist::ReadSharedReq          1045                       # Transaction distribution
-system.membus.pkt_count_system.l2.mem_side_port::system.mem_ctrls.port         2620                       # Packet count per connected requestor and responder (bytes)
-system.membus.pkt_count_system.l2.mem_side_port::total         2620                       # Packet count per connected requestor and responder (bytes)
-system.membus.pkt_count::total                   2620                       # Packet count per connected requestor and responder (bytes)
-system.membus.pkt_size_system.l2.mem_side_port::system.mem_ctrls.port        83840                       # Cumulative packet size per connected requestor and responder (bytes)
-system.membus.pkt_size_system.l2.mem_side_port::total        83840                       # Cumulative packet size per connected requestor and responder (bytes)
-system.membus.pkt_size::total                   83840                       # Cumulative packet size per connected requestor and responder (bytes)
-system.membus.snoops                                0                       # Total snoops (count)
-system.membus.snoopTraffic                          0                       # Total snoop traffic (bytes)
-system.membus.snoop_fanout::samples              1310                       # Request fanout histogram
-system.membus.snoop_fanout::mean                    0                       # Request fanout histogram
-system.membus.snoop_fanout::stdev                   0                       # Request fanout histogram
-system.membus.snoop_fanout::underflows              0      0.00%      0.00% # Request fanout histogram
-system.membus.snoop_fanout::0                    1310    100.00%    100.00% # Request fanout histogram
-system.membus.snoop_fanout::1                       0      0.00%    100.00% # Request fanout histogram
-system.membus.snoop_fanout::overflows               0      0.00%    100.00% # Request fanout histogram
-system.membus.snoop_fanout::min_value               0                       # Request fanout histogram
-system.membus.snoop_fanout::max_value               0                       # Request fanout histogram
-system.membus.snoop_fanout::total                1310                       # Request fanout histogram
-system.membus.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.membus.reqLayer8.occupancy             1318000                       # Layer occupancy (ticks)
-system.membus.reqLayer8.utilization               0.1                       # Layer utilization (%)
-system.membus.respLayer1.occupancy            7176050                       # Layer occupancy (ticks)
-system.membus.respLayer1.utilization              0.6                       # Layer utilization (%)
-system.tol2bus.trans_dist::ReadResp              1384                       # Transaction distribution
-system.tol2bus.trans_dist::WritebackDirty            1                       # Transaction distribution
-system.tol2bus.trans_dist::WritebackClean          731                       # Transaction distribution
-system.tol2bus.trans_dist::CleanEvict               6                       # Transaction distribution
-system.tol2bus.trans_dist::ReadExReq              265                       # Transaction distribution
-system.tol2bus.trans_dist::ReadExResp             265                       # Transaction distribution
-system.tol2bus.trans_dist::ReadCleanReq          1214                       # Transaction distribution
-system.tol2bus.trans_dist::ReadSharedReq          170                       # Transaction distribution
-system.tol2bus.pkt_count_system.cpu0.icache.mem_side_port::system.l2.cpu_side_port         3159                       # Packet count per connected requestor and responder (bytes)
-system.tol2bus.pkt_count_system.cpu0.dcache.mem_side_port::system.l2.cpu_side_port          877                       # Packet count per connected requestor and responder (bytes)
-system.tol2bus.pkt_count::total                  4036                       # Packet count per connected requestor and responder (bytes)
-system.tol2bus.pkt_size_system.cpu0.icache.mem_side_port::system.l2.cpu_side_port       124480                       # Cumulative packet size per connected requestor and responder (bytes)
-system.tol2bus.pkt_size_system.cpu0.dcache.mem_side_port::system.l2.cpu_side_port        27904                       # Cumulative packet size per connected requestor and responder (bytes)
-system.tol2bus.pkt_size::total                 152384                       # Cumulative packet size per connected requestor and responder (bytes)
-system.tol2bus.snoops                               0                       # Total snoops (count)
-system.tol2bus.snoopTraffic                         0                       # Total snoop traffic (bytes)
-system.tol2bus.snoop_fanout::samples             1649                       # Request fanout histogram
-system.tol2bus.snoop_fanout::mean            0.001213                       # Request fanout histogram
-system.tol2bus.snoop_fanout::stdev           0.034816                       # Request fanout histogram
-system.tol2bus.snoop_fanout::underflows             0      0.00%      0.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::0                   1647     99.88%     99.88% # Request fanout histogram
-system.tol2bus.snoop_fanout::1                      2      0.12%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::2                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::3                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::4                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::5                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::6                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::7                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::8                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::9                      0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::10                     0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::11                     0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::12                     0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::13                     0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::14                     0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::15                     0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::16                     0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::overflows              0      0.00%    100.00% # Request fanout histogram
-system.tol2bus.snoop_fanout::min_value              0                       # Request fanout histogram
-system.tol2bus.snoop_fanout::max_value              1                       # Request fanout histogram
-system.tol2bus.snoop_fanout::total               1649                       # Request fanout histogram
-system.tol2bus.power_state.pwrStateResidencyTicks::UNDEFINED   1268411500                       # Cumulative time (in ticks) in various power states
-system.tol2bus.reqLayer0.occupancy            1925500                       # Layer occupancy (ticks)
-system.tol2bus.reqLayer0.utilization              0.2                       # Layer utilization (%)
-system.tol2bus.respLayer0.occupancy           1821000                       # Layer occupancy (ticks)
-system.tol2bus.respLayer0.utilization             0.1                       # Layer utilization (%)
-system.tol2bus.respLayer1.occupancy            652500                       # Layer occupancy (ticks)
-system.tol2bus.respLayer1.utilization             0.1                       # Layer utilization (%)
-system.voltage_domain.voltage                       1                       # Voltage in Volts
-
----------- End Simulation Statistics   ----------
diff --git a/main.out b/main.out
deleted file mode 100755
index 42f400f79..000000000
Binary files a/main.out and /dev/null differ
diff --git a/ramulator b/ramulator
deleted file mode 160000
index 4edcb0d05..000000000
--- a/ramulator
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 4edcb0d05aac9ec46b032a7bf59595c0418287f7
diff --git a/ramulator_configs/1chan_2rank_nbr.cfg b/ramulator_configs/1chan_2rank_nbr.cfg
deleted file mode 100755
index 021d3ef3c..000000000
--- a/ramulator_configs/1chan_2rank_nbr.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_2rank_nbr_nbw.cfg b/ramulator_configs/1chan_2rank_nbr_nbw.cfg
deleted file mode 100755
index 49f5e629f..000000000
--- a/ramulator_configs/1chan_2rank_nbr_nbw.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_ideal_v2_modified
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_2rank_nbr_nbw_custom.cfg b/ramulator_configs/1chan_2rank_nbr_nbw_custom.cfg
deleted file mode 100755
index 400dacc1e..000000000
--- a/ramulator_configs/1chan_2rank_nbr_nbw_custom.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_ideal_v2_custom
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_2rank_nbr_nbw_lbb.cfg b/ramulator_configs/1chan_2rank_nbr_nbw_lbb.cfg
deleted file mode 100755
index c4ce76eca..000000000
--- a/ramulator_configs/1chan_2rank_nbr_nbw_lbb.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_2rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/1chan_2rank_nbr_nbw_lbb_64b.cfg
deleted file mode 100755
index eb46173b5..000000000
--- a/ramulator_configs/1chan_2rank_nbr_nbw_lbb_64b.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_4rank_nbr.cfg b/ramulator_configs/1chan_4rank_nbr.cfg
deleted file mode 100755
index b9ee327dd..000000000
--- a/ramulator_configs/1chan_4rank_nbr.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 4
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_4rank_nbr_nbw.cfg b/ramulator_configs/1chan_4rank_nbr_nbw.cfg
deleted file mode 100755
index 09fcde76f..000000000
--- a/ramulator_configs/1chan_4rank_nbr_nbw.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 4
- speed = DDR4_3200_ideal_v2_modified
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_4rank_nbr_nbw_custom.cfg b/ramulator_configs/1chan_4rank_nbr_nbw_custom.cfg
deleted file mode 100755
index 6df8e62af..000000000
--- a/ramulator_configs/1chan_4rank_nbr_nbw_custom.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 4
- speed = DDR4_3200_ideal_v2_custom
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_4rank_nbr_nbw_lbb.cfg b/ramulator_configs/1chan_4rank_nbr_nbw_lbb.cfg
deleted file mode 100755
index 5e6d43eeb..000000000
--- a/ramulator_configs/1chan_4rank_nbr_nbw_lbb.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 4
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/1chan_4rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/1chan_4rank_nbr_nbw_lbb_64b.cfg
deleted file mode 100755
index 1991af813..000000000
--- a/ramulator_configs/1chan_4rank_nbr_nbw_lbb_64b.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 4
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/2rank_nbr.cfg b/ramulator_configs/2rank_nbr.cfg
deleted file mode 100755
index 4fc615c81..000000000
--- a/ramulator_configs/2rank_nbr.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/2rank_nbr_lbb.cfg b/ramulator_configs/2rank_nbr_lbb.cfg
deleted file mode 100755
index 9a34f27fd..000000000
--- a/ramulator_configs/2rank_nbr_lbb.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/2rank_nbr_lbb_sts_freq.cfg b/ramulator_configs/2rank_nbr_lbb_sts_freq.cfg
deleted file mode 100755
index 7d95484ae..000000000
--- a/ramulator_configs/2rank_nbr_lbb_sts_freq.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_2933R_ideal_nbr_lbb_sts
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/2rank_nbr_lbb_ts_freq.cfg b/ramulator_configs/2rank_nbr_lbb_ts_freq.cfg
deleted file mode 100755
index e54badc99..000000000
--- a/ramulator_configs/2rank_nbr_lbb_ts_freq.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_2933R_ideal_nbr_lbb_ts
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_2rank_nbr.cfg b/ramulator_configs/4chan_2rank_nbr.cfg
deleted file mode 100755
index 20ebf94de..000000000
--- a/ramulator_configs/4chan_2rank_nbr.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_2rank_nbr_nbw.cfg b/ramulator_configs/4chan_2rank_nbr_nbw.cfg
deleted file mode 100755
index d6559919d..000000000
--- a/ramulator_configs/4chan_2rank_nbr_nbw.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v2_modified
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_2rank_nbr_nbw_custom.cfg b/ramulator_configs/4chan_2rank_nbr_nbw_custom.cfg
deleted file mode 100755
index 5d27259c5..000000000
--- a/ramulator_configs/4chan_2rank_nbr_nbw_custom.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v2_custom
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_2rank_nbr_nbw_lbb.cfg b/ramulator_configs/4chan_2rank_nbr_nbw_lbb.cfg
deleted file mode 100755
index 39fb53f6b..000000000
--- a/ramulator_configs/4chan_2rank_nbr_nbw_lbb.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_2rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/4chan_2rank_nbr_nbw_lbb_64b.cfg
deleted file mode 100755
index 983656b3e..000000000
--- a/ramulator_configs/4chan_2rank_nbr_nbw_lbb_64b.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_4rank_nbr.cfg b/ramulator_configs/4chan_4rank_nbr.cfg
deleted file mode 100755
index a1b65313d..000000000
--- a/ramulator_configs/4chan_4rank_nbr.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_4rank_nbr_nbw.cfg b/ramulator_configs/4chan_4rank_nbr_nbw.cfg
deleted file mode 100755
index f3ca6987d..000000000
--- a/ramulator_configs/4chan_4rank_nbr_nbw.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v2_modified
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_4rank_nbr_nbw_custom.cfg b/ramulator_configs/4chan_4rank_nbr_nbw_custom.cfg
deleted file mode 100755
index bedb845c4..000000000
--- a/ramulator_configs/4chan_4rank_nbr_nbw_custom.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v2_custom
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_4rank_nbr_nbw_lbb.cfg b/ramulator_configs/4chan_4rank_nbr_nbw_lbb.cfg
deleted file mode 100755
index 12c7f3708..000000000
--- a/ramulator_configs/4chan_4rank_nbr_nbw_lbb.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4chan_4rank_nbr_nbw_lbb_64b.cfg b/ramulator_configs/4chan_4rank_nbr_nbw_lbb_64b.cfg
deleted file mode 100755
index 9a61c4280..000000000
--- a/ramulator_configs/4chan_4rank_nbr_nbw_lbb_64b.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4rank_nbr.cfg b/ramulator_configs/4rank_nbr.cfg
deleted file mode 100755
index 0a84b40e3..000000000
--- a/ramulator_configs/4rank_nbr.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/4rank_nbr_lbb.cfg b/ramulator_configs/4rank_nbr_lbb.cfg
deleted file mode 100755
index b8382036d..000000000
--- a/ramulator_configs/4rank_nbr_lbb.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_nbr_lbb
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-2400-4CH2R-test.cfg b/ramulator_configs/DDR4-2400-4CH2R-test.cfg
deleted file mode 100755
index 483d8de8e..000000000
--- a/ramulator_configs/DDR4-2400-4CH2R-test.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_2400R
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-2400R-4CH2RANK-BASE.cfg b/ramulator_configs/DDR4-2400R-4CH2RANK-BASE.cfg
deleted file mode 100755
index 63447213a..000000000
--- a/ramulator_configs/DDR4-2400R-4CH2RANK-BASE.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_2400R_base
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK-BASE.cfg b/ramulator_configs/DDR4-3200-1CH2RANK-BASE.cfg
deleted file mode 100755
index 281e34c86..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK-BASE.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK.cfg b/ramulator_configs/DDR4-3200-1CH2RANK.cfg
deleted file mode 100755
index 8a84780fb..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base
- org = DDR4_4Gb_x8_w16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W16.cfg
deleted file mode 100755
index 3f32ca095..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W16.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_full_w16
- org = DDR4_4Gb_x8_w16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W32.cfg
deleted file mode 100755
index ed9193fa0..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W32.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_full_w32
- org = DDR4_4Gb_x8_w32
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W64.cfg
deleted file mode 100755
index 7c30a68d9..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W64.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_full_w64
- org = DDR4_4Gb_x8_w64
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W8.cfg
deleted file mode 100755
index 75bdffe7e..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_FULL_W8.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_full_w8
- org = DDR4_4Gb_x8_w8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W16.cfg
deleted file mode 100755
index fcd63a844..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W16.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_half_w16
- org = DDR4_4Gb_x8_w16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W32.cfg
deleted file mode 100755
index 69e12265b..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W32.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_half_w32
- org = DDR4_4Gb_x8_w32
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W64.cfg
deleted file mode 100755
index 72de9ac2d..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W64.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_half_w64
- org = DDR4_4Gb_x8_w64
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W8.cfg
deleted file mode 100755
index e7def411a..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_HALF_W8.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_half_w8
- org = DDR4_4Gb_x8_w8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W16.cfg
deleted file mode 100755
index a09f06ae9..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W16.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_quarter_w16
- org = DDR4_4Gb_x8_w16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W32.cfg
deleted file mode 100755
index 93f7f2a19..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W32.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_quarter_w32
- org = DDR4_4Gb_x8_w32
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W64.cfg
deleted file mode 100755
index 950b5d1ce..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W64.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_quarter_w64
- org = DDR4_4Gb_x8_w64
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W8.cfg
deleted file mode 100755
index 97fa4dc85..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_QUARTER_W8.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_quarter_w8
- org = DDR4_4Gb_x8_w8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W16.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W16.cfg
deleted file mode 100755
index a75ee7869..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_W16.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_w16
- org = DDR4_4Gb_x8_w16
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W32.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W32.cfg
deleted file mode 100755
index b783ba1be..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_W32.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_w32
- org = DDR4_4Gb_x8_w32
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W64.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W64.cfg
deleted file mode 100755
index 06510722f..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_W64.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_w64
- org = DDR4_4Gb_x8_w64
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH2RANK_W8.cfg b/ramulator_configs/DDR4-3200-1CH2RANK_W8.cfg
deleted file mode 100755
index 6e66051f0..000000000
--- a/ramulator_configs/DDR4-3200-1CH2RANK_W8.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 2
- speed = DDR4_3200_base_w8
- org = DDR4_4Gb_x8_w8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-1CH4RANK-BASE.cfg b/ramulator_configs/DDR4-3200-1CH4RANK-BASE.cfg
deleted file mode 100755
index 77b61b876..000000000
--- a/ramulator_configs/DDR4-3200-1CH4RANK-BASE.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 4
- speed = DDR4_3200_base
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-BASE.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-BASE.cfg
deleted file mode 100755
index 34682f61c..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-BASE.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_base
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv1.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv1.cfg
deleted file mode 100755
index 5d0717cce..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv1.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v1
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2.cfg
deleted file mode 100755
index 4fc615c81..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2_MODIFIED.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2_MODIFIED.cfg
deleted file mode 100755
index e164696a1..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv2_MODIFIED.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v2_modified
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv3.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv3.cfg
deleted file mode 100755
index bd6f9b5c4..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv3.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v3
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4.cfg
deleted file mode 100755
index 4d2510686..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v4
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4s.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4s.cfg
deleted file mode 100755
index 4dcac66bb..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv4s.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v4s
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5.cfg
deleted file mode 100755
index c3d436bd5..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v4
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5a.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5a.cfg
deleted file mode 100755
index ca3a4dc81..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv5a.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v5a
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv6.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv6.cfg
deleted file mode 100755
index f24bd61ab..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv6.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v4
- org = DDR4_4Gb_x8_2xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv7.cfg b/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv7.cfg
deleted file mode 100755
index f60729ed6..000000000
--- a/ramulator_configs/DDR4-3200-4CH2RANK-IDEALv7.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3200_ideal_v7
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-BASE.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-BASE.cfg
deleted file mode 100755
index 7411735e4..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-BASE.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_base
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = on
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv1.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv1.cfg
deleted file mode 100755
index 2e1f303e0..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv1.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v1
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2.cfg
deleted file mode 100755
index 0a84b40e3..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v2
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2_MODIFIED.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2_MODIFIED.cfg
deleted file mode 100755
index 4982d9053..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv2_MODIFIED.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v2_modified
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv3.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv3.cfg
deleted file mode 100755
index c21434bf1..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv3.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v3
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4.cfg
deleted file mode 100755
index 80265499c..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v4
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4s.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4s.cfg
deleted file mode 100755
index 82bd76870..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv4s.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v4s
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5.cfg
deleted file mode 100755
index 71e8a4e25..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v4
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5a.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5a.cfg
deleted file mode 100755
index 4210a749d..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv5a.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v5a
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv6.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv6.cfg
deleted file mode 100755
index a29964843..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv6.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v4
- org = DDR4_4Gb_x8_2xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv7.cfg b/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv7.cfg
deleted file mode 100755
index 037b5b331..000000000
--- a/ramulator_configs/DDR4-3200-4CH4RANK-IDEALv7.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3200_ideal_v7
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3600-4CH2RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3600-4CH2RANK-IDEALv5.cfg
deleted file mode 100755
index f0a940f0f..000000000
--- a/ramulator_configs/DDR4-3600-4CH2RANK-IDEALv5.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3600_ideal_v4
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3600-4CH4RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3600-4CH4RANK-IDEALv5.cfg
deleted file mode 100755
index 76970eda9..000000000
--- a/ramulator_configs/DDR4-3600-4CH4RANK-IDEALv5.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3600_ideal_v4
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3866-4CH2RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3866-4CH2RANK-IDEALv5.cfg
deleted file mode 100755
index ee838e94a..000000000
--- a/ramulator_configs/DDR4-3866-4CH2RANK-IDEALv5.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 2
- speed = DDR4_3866_ideal_v4
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-3866-4CH4RANK-IDEALv5.cfg b/ramulator_configs/DDR4-3866-4CH4RANK-IDEALv5.cfg
deleted file mode 100755
index 1fcadcbac..000000000
--- a/ramulator_configs/DDR4-3866-4CH4RANK-IDEALv5.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 4
- ranks = 4
- speed = DDR4_3866_ideal_v4
- org = DDR4_4Gb_x8_4xBank
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/ramulator_configs/DDR4-config.cfg b/ramulator_configs/DDR4-config.cfg
deleted file mode 100755
index e68e87442..000000000
--- a/ramulator_configs/DDR4-config.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-########################
-# Example config file
-# Comments start with #
-# There are restrictions for valid channel/rank numbers
- standard = DDR4
- channels = 1
- ranks = 1
- speed = DDR4_2400R
- org = DDR4_4Gb_x8
-# record_cmd_trace: (default is off): on, off
- record_cmd_trace = off
-# print_cmd_trace: (default is off): on, off
- print_cmd_trace = off
-
-### Below are parameters only for CPU trace
- cpu_tick = 8
- mem_tick = 3
-### Below are parameters only for multicore mode
-# When early_exit is on, all cores will be terminated when the earliest one finishes.
- early_exit = on
-# early_exit = on, off (default value is on)
-# If expected_limit_insts is set, some per-core statistics will be recorded when this limit (or the end of the whole trace if it's shorter than specified limit) is reached. The simulation won't stop and will roll back automatically until the last one reaches the limit.
- expected_limit_insts = 200000000
- warmup_insts = 100000000
- cache = no
-# cache = no, L1L2, L3, all (default value is no)
- translation = None
-# translation = None, Random (default value is None)
-#
-########################
diff --git a/src/base/enums/ByteOrder.hh b/src/base/enums/ByteOrder.hh
deleted file mode 100644
index 58d6c37eb..000000000
--- a/src/base/enums/ByteOrder.hh
+++ /dev/null
@@ -1,11 +0,0 @@
-#ifndef __ENUM__None__ByteOrder__
-#define __ENUM__None__ByteOrder__
-
-enum class ByteOrder {
-    big = 0,
-    little = 1,
-    Num_ByteOrder = 2
-};
-extern const char *ByteOrderStrings[static_cast<int>(ByteOrder::Num_ByteOrder)];
-
-#endif // __ENUM__None__ByteOrder__
diff --git a/src/mem/Ramulator.py b/src/mem/Ramulator.py
deleted file mode 100644
index 08a1d46ab..000000000
--- a/src/mem/Ramulator.py
+++ /dev/null
@@ -1,18 +0,0 @@
-# -*- mode:python -*-
-from m5.params import *
-from m5.objects.AbstractMemory import *
-
-# A wrapper for Ramulator multi-channel memory controller
-class Ramulator(AbstractMemory):
-    type = 'Ramulator'
-    cxx_header = "mem/ramulator.hh"
-
-    # A single port for now
-    port = SlavePort("Slave port")
-
-    config_file = Param.String("", "configuration file")
-    num_cpus = Param.Unsigned(1, "Number of cpu")
-    
-    # gagan
-    real_warm_up = Param.UInt64(100, "specify the real warm up time")
-    output_dir = Param.String("", "Ramulator trace output")
diff --git a/src/mem/SConscript b/src/mem/SConscript
index 63b82d6da..cf7adc866 100644
--- a/src/mem/SConscript
+++ b/src/mem/SConscript
@@ -100,11 +100,6 @@ if env['HAVE_DRAMSIM3']:
     Source('dramsim3_wrapper.cc')
     Source('dramsim3.cc')
 
-if env['HAVE_RAMULATOR']:
-    SimObject("Ramulator.py")
-    Source('ramulator.cc')
-    DebugFlag("Ramulator")
-
 SimObject('MemChecker.py')
 Source('mem_checker.cc')
 Source('mem_checker_monitor.cc')
diff --git a/src/mem/SConscript.orig b/src/mem/SConscript.orig
deleted file mode 100644
index cf7adc866..000000000
--- a/src/mem/SConscript.orig
+++ /dev/null
@@ -1,137 +0,0 @@
-# -*- mode:python -*-
-#
-# Copyright (c) 2018-2020 ARM Limited
-# All rights reserved
-#
-# The license below extends only to copyright in the software and shall
-# not be construed as granting a license to any other intellectual
-# property including but not limited to intellectual property relating
-# to a hardware implementation of the functionality of the software
-# licensed hereunder.  You may use the software subject to the license
-# terms below provided that you ensure that this notice is replicated
-# unmodified and in its entirety in all distributions of the software,
-# modified or unmodified, in source code or in binary form.
-#
-# Copyright (c) 2006 The Regents of The University of Michigan
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met: redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer;
-# redistributions in binary form must reproduce the above copyright
-# notice, this list of conditions and the following disclaimer in the
-# documentation and/or other materials provided with the distribution;
-# neither the name of the copyright holders nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-Import('*')
-
-SimObject('CommMonitor.py')
-Source('comm_monitor.cc')
-
-SimObject('AbstractMemory.py')
-SimObject('AddrMapper.py')
-SimObject('Bridge.py')
-SimObject('MemCtrl.py')
-SimObject('MemInterface.py')
-SimObject('DRAMInterface.py')
-SimObject('NVMInterface.py')
-SimObject('ExternalMaster.py')
-SimObject('ExternalSlave.py')
-SimObject('MemObject.py')
-SimObject('SimpleMemory.py')
-SimObject('XBar.py')
-SimObject('HMCController.py')
-SimObject('SerialLink.py')
-SimObject('MemDelay.py')
-
-Source('abstract_mem.cc')
-Source('addr_mapper.cc')
-Source('bridge.cc')
-Source('coherent_xbar.cc')
-Source('drampower.cc')
-Source('external_master.cc')
-Source('external_slave.cc')
-Source('mem_ctrl.cc')
-Source('mem_interface.cc')
-Source('noncoherent_xbar.cc')
-Source('packet.cc')
-Source('port.cc')
-Source('packet_queue.cc')
-Source('port_proxy.cc')
-Source('physical.cc')
-Source('simple_mem.cc')
-Source('snoop_filter.cc')
-Source('stack_dist_calc.cc')
-Source('token_port.cc')
-Source('tport.cc')
-Source('xbar.cc')
-Source('hmc_controller.cc')
-Source('htm.cc')
-Source('serial_link.cc')
-Source('mem_delay.cc')
-
-if env['TARGET_ISA'] != 'null':
-    Source('translating_port_proxy.cc')
-    Source('se_translating_port_proxy.cc')
-    Source('page_table.cc')
-
-if env['HAVE_DRAMSIM']:
-    SimObject('DRAMSim2.py')
-    Source('dramsim2_wrapper.cc')
-    Source('dramsim2.cc')
-
-if env['HAVE_DRAMSIM3']:
-    SimObject('DRAMsim3.py')
-    Source('dramsim3_wrapper.cc')
-    Source('dramsim3.cc')
-
-SimObject('MemChecker.py')
-Source('mem_checker.cc')
-Source('mem_checker_monitor.cc')
-
-DebugFlag('AddrRanges')
-DebugFlag('BaseXBar')
-DebugFlag('CoherentXBar')
-DebugFlag('NoncoherentXBar')
-DebugFlag('SnoopFilter')
-CompoundFlag('XBar', ['BaseXBar', 'CoherentXBar', 'NoncoherentXBar',
-                      'SnoopFilter'])
-
-DebugFlag('Bridge')
-DebugFlag('CommMonitor')
-DebugFlag('DRAM')
-DebugFlag('DRAMPower')
-DebugFlag('DRAMState')
-DebugFlag('NVM')
-DebugFlag('ExternalPort')
-DebugFlag('HtmMem', 'Hardware Transactional Memory (Mem side)')
-DebugFlag('LLSC')
-DebugFlag('MemCtrl')
-DebugFlag('MMU')
-DebugFlag('MemoryAccess')
-DebugFlag('PacketQueue')
-DebugFlag('StackDist')
-DebugFlag("DRAMSim2")
-DebugFlag("DRAMsim3")
-DebugFlag('HMCController')
-DebugFlag('SerialLink')
-DebugFlag('TokenPort')
-
-DebugFlag("MemChecker")
-DebugFlag("MemCheckerMonitor")
-DebugFlag("QOS")
diff --git a/src/mem/ramulator.cc b/src/mem/ramulator.cc
deleted file mode 100644
index 3618c3baa..000000000
--- a/src/mem/ramulator.cc
+++ /dev/null
@@ -1,283 +0,0 @@
-#include "base/callback.hh"
-#include "mem/ramulator.hh"
-#include "Ramulator/src/Gem5Wrapper.h"
-#include "Ramulator/src/Request.h"
-#include "sim/system.hh"
-#include "debug/Ramulator.hh"
-
-// daz3
-ramulator::Gem5Wrapper* wrapper1 = NULL;
-bool del_wrapper = false;
-Tick begin_tick = 0;
-Tick print_interval = 200000000;//0.2ms
-unsigned long my_read_cnt = 0;
-unsigned long my_write_cnt = 0;
-unsigned long my_total_cnt = 0;
-
-Ramulator::Ramulator(const Params *p):
-    AbstractMemory(p),
-    port(name() + ".port", *this),
-    requestsInFlight(0),
-    drain_manager(NULL),
-    config_file(p->config_file),
-    configs(p->config_file),
-    wrapper(NULL),
-    read_cb_func(std::bind(&Ramulator::readComplete, this, std::placeholders::_1)),
-    write_cb_func(std::bind(&Ramulator::writeComplete, this, std::placeholders::_1)),
-    ticks_per_clk(0),
-    resp_stall(false),
-    req_stall(false),
-    send_resp_event(this),
-    tick_event(this) 
-{
-  warmuptime = p->real_warm_up;
-
-  configs.set_core_num(p->num_cpus);
-  configs.set_tracefile_directory(p->output_dir);
-}
-Ramulator::~Ramulator()
-{
-    // delete wrapper;
-    // daz3
-    if(del_wrapper == false)
-    {
-        delete wrapper;
-        del_wrapper = true;
-    }
-}
-
-void Ramulator::init() {
-    if (!port.isConnected()){ 
-        fatal("Ramulator port not connected\n");
-    } else { 
-        port.sendRangeChange(); 
-    }
-
-    if (wrapper1 != NULL)
-    {
-        wrapper = wrapper1;
-    }
-    else
-    {
-        wrapper = new ramulator::Gem5Wrapper(configs, system()->cacheLineSize());
-        wrapper1 = wrapper;
-    }
-    // daz3
-    // wrapper = new ramulator::Gem5Wrapper(configs, system()->cacheLineSize());
-    ticks_per_clk = Tick(wrapper->tCK * SimClock::Float::ns);
-
-    DPRINTF(Ramulator, "Instantiated Ramulator with config file '%s' (tCK=%lf, %d ticks per clk)\n", 
-        config_file.c_str(), wrapper->tCK, ticks_per_clk);
-    //Callback* cb = new MakeCallback<ramulator::Gem5Wrapper, &ramulator::Gem5Wrapper::finish>(wrapper);
-    //registerExitCallback(cb);
-    //**** ramulator integration ******
-    registerExitCallback([this]() { wrapper->finish(); });
-}
-
-void Ramulator::startup() {
-    schedule(tick_event, clockEdge());
-}
-
-unsigned int Ramulator::drain(DrainManager* dm) {
-    // DPRINTF(Ramulator, "Requested to drain\n");
-    // // updated to include all in-flight requests
-    // // if (resp_queue.size()) {
-    // if (numOutstanding()) {
-    //     setDrainState(Drainable::Draining);
-    //     drain_manager = dm;
-    //     return 1;
-    // } else {
-    //     setDrainState(Drainable::Drained);
-    //     return 0;
-    // }
-    return 0;
-}
-
-Port& Ramulator::getPort(const std::string& if_name, PortID idx) {
-    if (if_name != "port") {
-        return AbstractMemory::getPort(if_name, idx);
-    } else {
-        return port;
-    }
-}
-
-void Ramulator::sendResponse() {
-    assert(!resp_stall);
-    assert(!resp_queue.empty());
-
-    DPRINTF(Ramulator, "Attempting to send response\n");
-
-    long addr = resp_queue.front()->getAddr();
-    if(addr){/*DO NOTHING. For avoid error unused-variable*/}
-    if (port.sendTimingResp(resp_queue.front())){
-        DPRINTF(Ramulator, "Response to %ld sent.\n", addr);
-        resp_queue.pop_front();
-        if (resp_queue.size() && !send_resp_event.scheduled())
-            schedule(send_resp_event, curTick());
-
-        // check if we were asked to drain and if we are now done
-        if (drain_manager && numOutstanding() == 0) {
-            drain_manager->signalDrainDone();
-            drain_manager = NULL;
-        }
-    } else 
-        resp_stall = true;
-}
-    
-void Ramulator::tick() {
-    wrapper->tick();
-    if (req_stall){
-        req_stall = false;
-        port.sendRetryReq();
-    }
-    //AbstractMemory::occupancyL3Cache = L3->occupancy();
-    schedule(tick_event, curTick() + ticks_per_clk);
-}
-
-// added an atomic packet response function to enable fast forwarding
-Tick Ramulator::recvAtomic(PacketPtr pkt) {
-    access(pkt);
-    //L3->call(pkt->getAddr());
-    // set an fixed arbitrary 50ns response time for atomic requests
-    return pkt->cacheResponding() ? 0 : 50000;
-}
-
-void Ramulator::recvFunctional(PacketPtr pkt) {
-    pkt->pushLabel(name());
-    functionalAccess(pkt);
-    for (auto i = resp_queue.begin(); i != resp_queue.end(); ++i)
-        pkt->trySatisfyFunctional(*i);
-    pkt->popLabel();
-}
-
-bool Ramulator::recvTimingReq(PacketPtr pkt) {
-    // we should never see a new request while in retry
-    assert(!req_stall);
-
-    for (PacketPtr pendPkt: pending_del)
-        delete pendPkt;
-    pending_del.clear();
-
-    // daz3
-    if (begin_tick == 0) {
-        begin_tick = curTick();
-    }
-
-    if (pkt->cacheResponding()) {
-        // snooper will supply based on copy of packet
-        // still target's responsibility to delete packet
-        pending_del.push_back(pkt);
-        return true;
-    }
-
-    // daz3
-    if (curTick()<=(begin_tick + warmuptime))
-      {
-        my_total_cnt++;
-        accessAndRespond(pkt);
-        return true;
-      }
-    
-    bool accepted = true;
-    if (pkt->isRead()) {
-      //DPRINTF(Ramulator, "context id: %d, thread id: %d\n", pkt->req->contextId(),
-      //    pkt->req->threadId());
-      ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::READ, read_cb_func, pkt->req->isPrefetch(), 0);
-        //daz3
-        // ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::READ, read_cb_func, 0);
-        accepted = wrapper->send(req);
-        if (accepted){
-            reads[req.addr].push_back(pkt);
-            DPRINTF(Ramulator, "Read to %ld accepted.\n", req.addr);
-
-            // added counter to track requests in flight
-            ++requestsInFlight;
-            // daz3
-            my_read_cnt++;
-            my_total_cnt++;
-        } else {
-            req_stall = true;
-        }
-    } else if (pkt->isWrite()) {
-        // Detailed CPU model always comes along with cache model enabled and
-        // write requests are caused by cache eviction, so it shouldn't be
-        // tallied for any core/thread
-        ramulator::Request req(pkt->getAddr(), ramulator::Request::Type::WRITE, write_cb_func, false, 0);
-        accepted = wrapper->send(req);
-        if (accepted){
-            accessAndRespond(pkt);
-            DPRINTF(Ramulator, "Write to %ld accepted and served.\n", req.addr);
-
-            // added counter to track requests in flight
-            ++requestsInFlight;
-            // daz3
-            my_write_cnt++;
-            my_total_cnt++;
-        } else {
-            req_stall = true;
-        }
-    } else {
-        // keep it simple and just respond if necessary
-        accessAndRespond(pkt);
-        // daz3
-        my_total_cnt++;
-    }
-    return accepted;
-}
-
-void Ramulator::recvRespRetry() {
-    DPRINTF(Ramulator, "Retrying\n");
-
-    assert(resp_stall);
-    resp_stall = false;
-    sendResponse();
-}
-
-void Ramulator::accessAndRespond(PacketPtr pkt) {
-    bool need_resp = pkt->needsResponse();
-    access(pkt);
-    if (need_resp) {
-        assert(pkt->isResponse());
-        pkt->headerDelay = pkt->payloadDelay = 0;
-
-        DPRINTF(Ramulator, "Queuing response for address %lld\n",
-                pkt->getAddr());
-
-        resp_queue.push_back(pkt);
-	// gagan : added 18 ns latency for the L3 cache
-        if (!resp_stall && !send_resp_event.scheduled())
-            schedule(send_resp_event, curTick());
-    } else 
-        pending_del.push_back(pkt);
-}
-
-void Ramulator::readComplete(ramulator::Request& req){
-    DPRINTF(Ramulator, "Read to %ld completed.\n", req.addr);
-    auto& pkt_q = reads.find(req.addr)->second;
-    PacketPtr pkt = pkt_q.front();
-    pkt_q.pop_front();
-    if (!pkt_q.size())
-        reads.erase(req.addr);
-
-    // added counter to track requests in flight
-    --requestsInFlight;
-
-    accessAndRespond(pkt);
-}
-
-void Ramulator::writeComplete(ramulator::Request& req){
-    DPRINTF(Ramulator, "Write to %ld completed.\n", req.addr);
-
-    // added counter to track requests in flight
-    --requestsInFlight;
-
-    // check if we were asked to drain and if we are now done
-    if (drain_manager && numOutstanding() == 0) {
-        drain_manager->signalDrainDone();
-        drain_manager = NULL;
-    }
-}
-
-Ramulator *RamulatorParams::create(){
-    return new Ramulator(this);
-}
diff --git a/src/mem/ramulator.hh b/src/mem/ramulator.hh
deleted file mode 100644
index 1a3529b5e..000000000
--- a/src/mem/ramulator.hh
+++ /dev/null
@@ -1,97 +0,0 @@
-#ifndef __RAMULATOR_HH__
-#define __RAMULATOR_HH__
-
-#include <deque>
-#include <tuple>
-#include <map>
-
-#include "mem/abstract_mem.hh"
-#include "params/Ramulator.hh"
-#include "Ramulator/src/Config.h"
-
-namespace ramulator{
-    class Request;
-    class Gem5Wrapper;
-}
-
-class Ramulator : public AbstractMemory {
-private:
-
-    class MemoryPort: public SlavePort {
-    private:
-        Ramulator& mem;
-    public:
-        MemoryPort(const std::string& _name, Ramulator& _mem): SlavePort(_name, &_mem), mem(_mem) {}
-    protected:
-        Tick recvAtomic(PacketPtr pkt) {
-            // modified to perform a fixed latency return for atomic packets to enable fast forwarding
-            // assert(false && "only accepts functional or timing packets");
-            return mem.recvAtomic(pkt);
-        }
-        
-        void recvFunctional(PacketPtr pkt) {
-            mem.recvFunctional(pkt);
-        }
-
-        bool recvTimingReq(PacketPtr pkt) {
-            return mem.recvTimingReq(pkt);
-        }
-
-        void recvRespRetry() {
-            mem.recvRespRetry();
-        }
-
-        AddrRangeList getAddrRanges() const {
-            AddrRangeList ranges;
-            ranges.push_back(mem.getAddrRange());
-            return ranges;
-        }
-    } port;
-
-    unsigned int requestsInFlight;
-    std::map<long, std::deque<PacketPtr> > reads;
-    std::map<long, std::deque<PacketPtr> > writes;
-    std::deque<PacketPtr> resp_queue;
-    std::deque<PacketPtr> pending_del;
-    DrainManager *drain_manager;
-
-    std::string config_file;
-    ramulator::Config configs;
-    ramulator::Gem5Wrapper *wrapper;
-    std::function<void(ramulator::Request&)> read_cb_func;
-    std::function<void(ramulator::Request&)> write_cb_func;
-    Tick ticks_per_clk;
-    bool resp_stall;
-    bool req_stall;
-    // gagan :
-    Tick warmuptime;
-
-    unsigned int numOutstanding() const { return requestsInFlight + resp_queue.size(); }
-    
-    void sendResponse();
-    void tick();
-    
-    EventWrapper<Ramulator, &Ramulator::sendResponse> send_resp_event;
-    EventWrapper<Ramulator, &Ramulator::tick> tick_event;
-
-public:
-    typedef RamulatorParams Params;
-    Ramulator(const Params *p);
-    virtual void init();
-    virtual void startup();
-    unsigned int drain(DrainManager* dm);
-    virtual Port& getPort(const std::string& if_name, 
-        PortID idx = InvalidPortID);
-    ~Ramulator();
-
-protected:
-    Tick recvAtomic(PacketPtr pkt);
-    void recvFunctional(PacketPtr pkt);
-    bool recvTimingReq(PacketPtr pkt);
-    void recvRespRetry();
-    void accessAndRespond(PacketPtr pkt);
-    void readComplete(ramulator::Request& req);
-    void writeComplete(ramulator::Request& req);
-};
-
-#endif // __RAMULATOR_HH__
diff --git a/src/python/m5/params.py b/src/python/m5/params.py
index 5bbafdf98..45082d7ac 100644
--- a/src/python/m5/params.py
+++ b/src/python/m5/params.py
@@ -222,7 +222,7 @@ class ParamDesc(object):
         return self.ptype(value).pretty_print(value)
 
     def cxx_predecls(self, code):
-        code('#include <stddef.h>')
+        code('#include <cstddef>')
         self.ptype.cxx_predecls(code)
 
     def pybind_predecls(self, code):
diff --git a/src/python/m5/params.py.orig b/src/python/m5/params.py.orig
deleted file mode 100644
index 45082d7ac..000000000
--- a/src/python/m5/params.py.orig
+++ /dev/null
@@ -1,2257 +0,0 @@
-# Copyright (c) 2012-2014, 2017-2019 ARM Limited
-# All rights reserved.
-#
-# The license below extends only to copyright in the software and shall
-# not be construed as granting a license to any other intellectual
-# property including but not limited to intellectual property relating
-# to a hardware implementation of the functionality of the software
-# licensed hereunder.  You may use the software subject to the license
-# terms below provided that you ensure that this notice is replicated
-# unmodified and in its entirety in all distributions of the software,
-# modified or unmodified, in source code or in binary form.
-#
-# Copyright (c) 2004-2006 The Regents of The University of Michigan
-# Copyright (c) 2010-2011 Advanced Micro Devices, Inc.
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are
-# met: redistributions of source code must retain the above copyright
-# notice, this list of conditions and the following disclaimer;
-# redistributions in binary form must reproduce the above copyright
-# notice, this list of conditions and the following disclaimer in the
-# documentation and/or other materials provided with the distribution;
-# neither the name of the copyright holders nor the names of its
-# contributors may be used to endorse or promote products derived from
-# this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#####################################################################
-#
-# Parameter description classes
-#
-# The _params dictionary in each class maps parameter names to either
-# a Param or a VectorParam object.  These objects contain the
-# parameter description string, the parameter type, and the default
-# value (if any).  The convert() method on these objects is used to
-# force whatever value is assigned to the parameter to the appropriate
-# type.
-#
-# Note that the default values are loaded into the class's attribute
-# space when the parameter dictionary is initialized (in
-# MetaSimObject._new_param()); after that point they aren't used.
-#
-#####################################################################
-
-from __future__ import print_function
-from six import with_metaclass
-import six
-if six.PY3:
-    long = int
-
-import copy
-import datetime
-import re
-import sys
-import time
-import math
-
-from . import proxy
-from . import ticks
-from .util import *
-
-def isSimObject(*args, **kwargs):
-    from . import SimObject
-    return SimObject.isSimObject(*args, **kwargs)
-
-def isSimObjectSequence(*args, **kwargs):
-    from . import SimObject
-    return SimObject.isSimObjectSequence(*args, **kwargs)
-
-def isSimObjectClass(*args, **kwargs):
-    from . import SimObject
-    return SimObject.isSimObjectClass(*args, **kwargs)
-
-allParams = {}
-
-class MetaParamValue(type):
-    def __new__(mcls, name, bases, dct):
-        cls = super(MetaParamValue, mcls).__new__(mcls, name, bases, dct)
-        if name in allParams:
-            warn("%s already exists in allParams. This may be caused by the " \
-                 "Python 2.7 compatibility layer." % (name, ))
-        allParams[name] = cls
-        return cls
-
-
-# Dummy base class to identify types that are legitimate for SimObject
-# parameters.
-class ParamValue(with_metaclass(MetaParamValue, object)):
-    cmd_line_settable = False
-
-    # Generate the code needed as a prerequisite for declaring a C++
-    # object of this type.  Typically generates one or more #include
-    # statements.  Used when declaring parameters of this type.
-    @classmethod
-    def cxx_predecls(cls, code):
-        pass
-
-    @classmethod
-    def pybind_predecls(cls, code):
-        cls.cxx_predecls(code)
-
-    # default for printing to .ini file is regular string conversion.
-    # will be overridden in some cases
-    def ini_str(self):
-        return str(self)
-
-    # default for printing to .json file is regular string conversion.
-    # will be overridden in some cases, mostly to use native Python
-    # types where there are similar JSON types
-    def config_value(self):
-        return str(self)
-
-    # Prerequisites for .ini parsing with cxx_ini_parse
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        pass
-
-    # parse a .ini file entry for this param from string expression
-    # src into lvalue dest (of the param's C++ type)
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('// Unhandled param type: %s' % cls.__name__)
-        code('%s false;' % ret)
-
-    # allows us to blithely call unproxy() on things without checking
-    # if they're really proxies or not
-    def unproxy(self, base):
-        return self
-
-    # Produce a human readable version of the stored value
-    def pretty_print(self, value):
-        return str(value)
-
-# Regular parameter description.
-class ParamDesc(object):
-    def __init__(self, ptype_str, ptype, *args, **kwargs):
-        self.ptype_str = ptype_str
-        # remember ptype only if it is provided
-        if ptype != None:
-            self.ptype = ptype
-
-        if args:
-            if len(args) == 1:
-                self.desc = args[0]
-            elif len(args) == 2:
-                self.default = args[0]
-                self.desc = args[1]
-            else:
-                raise TypeError('too many arguments')
-
-        if 'desc' in kwargs:
-            assert(not hasattr(self, 'desc'))
-            self.desc = kwargs['desc']
-            del kwargs['desc']
-
-        if 'default' in kwargs:
-            assert(not hasattr(self, 'default'))
-            self.default = kwargs['default']
-            del kwargs['default']
-
-        if kwargs:
-            raise TypeError('extra unknown kwargs %s' % kwargs)
-
-        if not hasattr(self, 'desc'):
-            raise TypeError('desc attribute missing')
-
-    def __getattr__(self, attr):
-        if attr == 'ptype':
-            from . import SimObject
-            ptype = SimObject.allClasses[self.ptype_str]
-            assert isSimObjectClass(ptype)
-            self.ptype = ptype
-            return ptype
-
-        raise AttributeError("'%s' object has no attribute '%s'" % \
-              (type(self).__name__, attr))
-
-    def example_str(self):
-        if hasattr(self.ptype, "ex_str"):
-            return self.ptype.ex_str
-        else:
-            return self.ptype_str
-
-    # Is the param available to be exposed on the command line
-    def isCmdLineSettable(self):
-        if hasattr(self.ptype, "cmd_line_settable"):
-            return self.ptype.cmd_line_settable
-        else:
-            return False
-
-    def convert(self, value):
-        if isinstance(value, proxy.BaseProxy):
-            value.set_param_desc(self)
-            return value
-        if 'ptype' not in self.__dict__ and isNullPointer(value):
-            # deferred evaluation of SimObject; continue to defer if
-            # we're just assigning a null pointer
-            return value
-        if isinstance(value, self.ptype):
-            return value
-        if isNullPointer(value) and isSimObjectClass(self.ptype):
-            return value
-        return self.ptype(value)
-
-    def pretty_print(self, value):
-        if isinstance(value, proxy.BaseProxy):
-           return str(value)
-        if isNullPointer(value):
-           return NULL
-        return self.ptype(value).pretty_print(value)
-
-    def cxx_predecls(self, code):
-        code('#include <cstddef>')
-        self.ptype.cxx_predecls(code)
-
-    def pybind_predecls(self, code):
-        self.ptype.pybind_predecls(code)
-
-    def cxx_decl(self, code):
-        code('${{self.ptype.cxx_type}} ${{self.name}};')
-
-# Vector-valued parameter description.  Just like ParamDesc, except
-# that the value is a vector (list) of the specified type instead of a
-# single value.
-
-class VectorParamValue(with_metaclass(MetaParamValue, list)):
-    def __setattr__(self, attr, value):
-        raise AttributeError("Not allowed to set %s on '%s'" % \
-                             (attr, type(self).__name__))
-
-    def config_value(self):
-        return [v.config_value() for v in self]
-
-    def ini_str(self):
-        return ' '.join([v.ini_str() for v in self])
-
-    def getValue(self):
-        return [ v.getValue() for v in self ]
-
-    def unproxy(self, base):
-        if len(self) == 1 and isinstance(self[0], proxy.BaseProxy):
-            # The value is a proxy (e.g. Parent.any, Parent.all or
-            # Parent.x) therefore try resolve it
-            return self[0].unproxy(base)
-        else:
-            return [v.unproxy(base) for v in self]
-
-class SimObjectVector(VectorParamValue):
-    # support clone operation
-    def __call__(self, **kwargs):
-        return SimObjectVector([v(**kwargs) for v in self])
-
-    def clear_parent(self, old_parent):
-        for v in self:
-            v.clear_parent(old_parent)
-
-    def set_parent(self, parent, name):
-        if len(self) == 1:
-            self[0].set_parent(parent, name)
-        else:
-            width = int(math.ceil(math.log(len(self))/math.log(10)))
-            for i,v in enumerate(self):
-                v.set_parent(parent, "%s%0*d" % (name, width, i))
-
-    def has_parent(self):
-        return any([e.has_parent() for e in self if not isNullPointer(e)])
-
-    # return 'cpu0 cpu1' etc. for print_ini()
-    def get_name(self):
-        return ' '.join([v._name for v in self])
-
-    # By iterating through the constituent members of the vector here
-    # we can nicely handle iterating over all a SimObject's children
-    # without having to provide lots of special functions on
-    # SimObjectVector directly.
-    def descendants(self):
-        for v in self:
-            for obj in v.descendants():
-                yield obj
-
-    def get_config_as_dict(self):
-        a = []
-        for v in self:
-            a.append(v.get_config_as_dict())
-        return a
-
-    # If we are replacing an item in the vector, make sure to set the
-    # parent reference of the new SimObject to be the same as the parent
-    # of the SimObject being replaced. Useful to have if we created
-    # a SimObjectVector of temporary objects that will be modified later in
-    # configuration scripts.
-    def __setitem__(self, key, value):
-        val = self[key]
-        if value.has_parent():
-            warn("SimObject %s already has a parent" % value.get_name() +\
-                 " that is being overwritten by a SimObjectVector")
-        value.set_parent(val.get_parent(), val._name)
-        super(SimObjectVector, self).__setitem__(key, value)
-
-    # Enumerate the params of each member of the SimObject vector. Creates
-    # strings that will allow indexing into the vector by the python code and
-    # allow it to be specified on the command line.
-    def enumerateParams(self, flags_dict = {},
-                        cmd_line_str = "",
-                        access_str = ""):
-        if hasattr(self, "_paramEnumed"):
-            print("Cycle detected enumerating params at %s?!" % (cmd_line_str))
-        else:
-            x = 0
-            for vals in self:
-                # Each entry in the SimObjectVector should be an
-                # instance of a SimObject
-                flags_dict = vals.enumerateParams(flags_dict,
-                                                  cmd_line_str + "%d." % x,
-                                                  access_str + "[%d]." % x)
-                x = x + 1
-
-        return flags_dict
-
-class VectorParamDesc(ParamDesc):
-    # Convert assigned value to appropriate type.  If the RHS is not a
-    # list or tuple, it generates a single-element list.
-    def convert(self, value):
-        if isinstance(value, (list, tuple)):
-            # list: coerce each element into new list
-            tmp_list = [ ParamDesc.convert(self, v) for v in value ]
-        elif isinstance(value, str):
-            # If input is a csv string
-            tmp_list = [ ParamDesc.convert(self, v) \
-                         for v in value.strip('[').strip(']').split(',') ]
-        else:
-            # singleton: coerce to a single-element list
-            tmp_list = [ ParamDesc.convert(self, value) ]
-
-        if isSimObjectSequence(tmp_list):
-            return SimObjectVector(tmp_list)
-        else:
-            return VectorParamValue(tmp_list)
-
-    # Produce a human readable example string that describes
-    # how to set this vector parameter in the absence of a default
-    # value.
-    def example_str(self):
-        s = super(VectorParamDesc, self).example_str()
-        help_str = "[" + s + "," + s + ", ...]"
-        return help_str
-
-    # Produce a human readable representation of the value of this vector param.
-    def pretty_print(self, value):
-        if isinstance(value, (list, tuple)):
-            tmp_list = [ ParamDesc.pretty_print(self, v) for v in value ]
-        elif isinstance(value, str):
-            tmp_list = [ ParamDesc.pretty_print(self, v) for v in value.split(',') ]
-        else:
-            tmp_list = [ ParamDesc.pretty_print(self, value) ]
-
-        return tmp_list
-
-    # This is a helper function for the new config system
-    def __call__(self, value):
-        if isinstance(value, (list, tuple)):
-            # list: coerce each element into new list
-            tmp_list = [ ParamDesc.convert(self, v) for v in value ]
-        elif isinstance(value, str):
-            # If input is a csv string
-            tmp_list = [ ParamDesc.convert(self, v) \
-                         for v in value.strip('[').strip(']').split(',') ]
-        else:
-            # singleton: coerce to a single-element list
-            tmp_list = [ ParamDesc.convert(self, value) ]
-
-        return VectorParamValue(tmp_list)
-
-    def cxx_predecls(self, code):
-        code('#include <vector>')
-        self.ptype.cxx_predecls(code)
-
-    def pybind_predecls(self, code):
-        code('#include <vector>')
-        self.ptype.pybind_predecls(code)
-
-    def cxx_decl(self, code):
-        code('std::vector< ${{self.ptype.cxx_type}} > ${{self.name}};')
-
-class ParamFactory(object):
-    def __init__(self, param_desc_class, ptype_str = None):
-        self.param_desc_class = param_desc_class
-        self.ptype_str = ptype_str
-
-    def __getattr__(self, attr):
-        if self.ptype_str:
-            attr = self.ptype_str + '.' + attr
-        return ParamFactory(self.param_desc_class, attr)
-
-    # E.g., Param.Int(5, "number of widgets")
-    def __call__(self, *args, **kwargs):
-        ptype = None
-        try:
-            ptype = allParams[self.ptype_str]
-        except KeyError:
-            # if name isn't defined yet, assume it's a SimObject, and
-            # try to resolve it later
-            pass
-        return self.param_desc_class(self.ptype_str, ptype, *args, **kwargs)
-
-Param = ParamFactory(ParamDesc)
-VectorParam = ParamFactory(VectorParamDesc)
-
-#####################################################################
-#
-# Parameter Types
-#
-# Though native Python types could be used to specify parameter types
-# (the 'ptype' field of the Param and VectorParam classes), it's more
-# flexible to define our own set of types.  This gives us more control
-# over how Python expressions are converted to values (via the
-# __init__() constructor) and how these values are printed out (via
-# the __str__() conversion method).
-#
-#####################################################################
-
-# String-valued parameter.  Just mixin the ParamValue class with the
-# built-in str class.
-class String(ParamValue,str):
-    cxx_type = 'std::string'
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(self, code):
-        code('#include <string>')
-
-    def __call__(self, value):
-        self = value
-        return value
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s = %s;' % (dest, src))
-        code('%s true;' % ret)
-
-    def getValue(self):
-        return self
-
-# superclass for "numeric" parameter values, to emulate math
-# operations in a type-safe way.  e.g., a Latency times an int returns
-# a new Latency object.
-class NumericParamValue(ParamValue):
-    @staticmethod
-    def unwrap(v):
-        return v.value if isinstance(v, NumericParamValue) else v
-
-    def __str__(self):
-        return str(self.value)
-
-    def __float__(self):
-        return float(self.value)
-
-    def __long__(self):
-        return long(self.value)
-
-    def __int__(self):
-        return int(self.value)
-
-    # hook for bounds checking
-    def _check(self):
-        return
-
-    def __mul__(self, other):
-        newobj = self.__class__(self)
-        newobj.value *= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    __rmul__ = __mul__
-
-    def __truediv__(self, other):
-        newobj = self.__class__(self)
-        newobj.value /= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    def __floordiv__(self, other):
-        newobj = self.__class__(self)
-        newobj.value //= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-
-    def __add__(self, other):
-        newobj = self.__class__(self)
-        newobj.value += NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    def __sub__(self, other):
-        newobj = self.__class__(self)
-        newobj.value -= NumericParamValue.unwrap(other)
-        newobj._check()
-        return newobj
-
-    def __iadd__(self, other):
-        self.value += NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __isub__(self, other):
-        self.value -= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __imul__(self, other):
-        self.value *= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __itruediv__(self, other):
-        self.value /= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __ifloordiv__(self, other):
-        self.value //= NumericParamValue.unwrap(other)
-        self._check()
-        return self
-
-    def __lt__(self, other):
-        return self.value < NumericParamValue.unwrap(other)
-
-    # Python 2.7 pre __future__.division operators
-    # TODO: Remove these when after "import division from __future__"
-    __div__ =  __truediv__
-    __idiv__ = __itruediv__
-
-    def config_value(self):
-        return self.value
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        # Assume that base/str.hh will be included anyway
-        # code('#include "base/str.hh"')
-        pass
-
-    # The default for parsing PODs from an .ini entry is to extract from an
-    # istringstream and let overloading choose the right type according to
-    # the dest type.
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s to_number(%s, %s);' % (ret, src, dest))
-
-# Metaclass for bounds-checked integer parameters.  See CheckedInt.
-class CheckedIntType(MetaParamValue):
-    def __init__(cls, name, bases, dict):
-        super(CheckedIntType, cls).__init__(name, bases, dict)
-
-        # CheckedInt is an abstract base class, so we actually don't
-        # want to do any processing on it... the rest of this code is
-        # just for classes that derive from CheckedInt.
-        if name == 'CheckedInt':
-            return
-
-        if not (hasattr(cls, 'min') and hasattr(cls, 'max')):
-            if not (hasattr(cls, 'size') and hasattr(cls, 'unsigned')):
-                panic("CheckedInt subclass %s must define either\n" \
-                      "    'min' and 'max' or 'size' and 'unsigned'\n",
-                      name);
-            if cls.unsigned:
-                cls.min = 0
-                cls.max = 2 ** cls.size - 1
-            else:
-                cls.min = -(2 ** (cls.size - 1))
-                cls.max = (2 ** (cls.size - 1)) - 1
-
-# Abstract superclass for bounds-checked integer parameters.  This
-# class is subclassed to generate parameter classes with specific
-# bounds.  Initialization of the min and max bounds is done in the
-# metaclass CheckedIntType.__init__.
-class CheckedInt(with_metaclass(CheckedIntType, NumericParamValue)):
-    cmd_line_settable = True
-
-    def _check(self):
-        if not self.min <= self.value <= self.max:
-            raise TypeError('Integer param out of bounds %d < %d < %d' % \
-                  (self.min, self.value, self.max))
-
-    def __init__(self, value):
-        if isinstance(value, str):
-            self.value = convert.toInteger(value)
-        elif isinstance(value, (int, long, float, NumericParamValue)):
-            self.value = long(value)
-        else:
-            raise TypeError("Can't convert object of type %s to CheckedInt" \
-                  % type(value).__name__)
-        self._check()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __index__(self):
-        return int(self.value)
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        # most derived types require this, so we just do it here once
-        code('#include "base/types.hh"')
-
-    def getValue(self):
-        return long(self.value)
-
-class Int(CheckedInt):      cxx_type = 'int';      size = 32; unsigned = False
-class Unsigned(CheckedInt): cxx_type = 'unsigned'; size = 32; unsigned = True
-
-class Int8(CheckedInt):     cxx_type =   'int8_t'; size =  8; unsigned = False
-class UInt8(CheckedInt):    cxx_type =  'uint8_t'; size =  8; unsigned = True
-class Int16(CheckedInt):    cxx_type =  'int16_t'; size = 16; unsigned = False
-class UInt16(CheckedInt):   cxx_type = 'uint16_t'; size = 16; unsigned = True
-class Int32(CheckedInt):    cxx_type =  'int32_t'; size = 32; unsigned = False
-class UInt32(CheckedInt):   cxx_type = 'uint32_t'; size = 32; unsigned = True
-class Int64(CheckedInt):    cxx_type =  'int64_t'; size = 64; unsigned = False
-class UInt64(CheckedInt):   cxx_type = 'uint64_t'; size = 64; unsigned = True
-
-class Counter(CheckedInt):  cxx_type = 'Counter';  size = 64; unsigned = True
-class Tick(CheckedInt):     cxx_type = 'Tick';     size = 64; unsigned = True
-class TcpPort(CheckedInt):  cxx_type = 'uint16_t'; size = 16; unsigned = True
-class UdpPort(CheckedInt):  cxx_type = 'uint16_t'; size = 16; unsigned = True
-
-class Percent(CheckedInt):  cxx_type = 'int'; min = 0; max = 100
-
-class Cycles(CheckedInt):
-    cxx_type = 'Cycles'
-    size = 64
-    unsigned = True
-
-    def getValue(self):
-        from _m5.core import Cycles
-        return Cycles(self.value)
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        # Assume that base/str.hh will be included anyway
-        # code('#include "base/str.hh"')
-        pass
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('uint64_t _temp;')
-        code('bool _ret = to_number(%s, _temp);' % src)
-        code('if (_ret)')
-        code('    %s = Cycles(_temp);' % dest)
-        code('%s _ret;' % ret)
-
-class Float(ParamValue, float):
-    cxx_type = 'double'
-    cmd_line_settable = True
-
-    def __init__(self, value):
-        if isinstance(value, (int, long, float, NumericParamValue, Float, str)):
-            self.value = float(value)
-        else:
-            raise TypeError("Can't convert object of type %s to Float" \
-                  % type(value).__name__)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        return float(self.value)
-
-    def config_value(self):
-        return self
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s (std::istringstream(%s) >> %s).eof();' % (ret, src, dest))
-
-class MemorySize(CheckedInt):
-    cxx_type = 'uint64_t'
-    ex_str = '512MB'
-    size = 64
-    unsigned = True
-    def __init__(self, value):
-        if isinstance(value, MemorySize):
-            self.value = value.value
-        else:
-            self.value = convert.toMemorySize(value)
-        self._check()
-
-class MemorySize32(CheckedInt):
-    cxx_type = 'uint32_t'
-    ex_str = '512MB'
-    size = 32
-    unsigned = True
-    def __init__(self, value):
-        if isinstance(value, MemorySize):
-            self.value = value.value
-        else:
-            self.value = convert.toMemorySize(value)
-        self._check()
-
-class Addr(CheckedInt):
-    cxx_type = 'Addr'
-    size = 64
-    unsigned = True
-    def __init__(self, value):
-        if isinstance(value, Addr):
-            self.value = value.value
-        else:
-            try:
-                # Often addresses are referred to with sizes. Ex: A device
-                # base address is at "512MB".  Use toMemorySize() to convert
-                # these into addresses. If the address is not specified with a
-                # "size", an exception will occur and numeric translation will
-                # proceed below.
-                self.value = convert.toMemorySize(value)
-            except (TypeError, ValueError):
-                # Convert number to string and use long() to do automatic
-                # base conversion (requires base=0 for auto-conversion)
-                self.value = long(str(value), base=0)
-
-        self._check()
-    def __add__(self, other):
-        if isinstance(other, Addr):
-            return self.value + other.value
-        else:
-            return self.value + other
-    def pretty_print(self, value):
-        try:
-            val = convert.toMemorySize(value)
-        except TypeError:
-            val = long(value)
-        return "0x%x" % long(val)
-
-class AddrRange(ParamValue):
-    cxx_type = 'AddrRange'
-
-    def __init__(self, *args, **kwargs):
-        # Disable interleaving and hashing by default
-        self.intlvBits = 0
-        self.intlvMatch = 0
-        self.masks = []
-
-        def handle_kwargs(self, kwargs):
-            # An address range needs to have an upper limit, specified
-            # either explicitly with an end, or as an offset using the
-            # size keyword.
-            if 'end' in kwargs:
-                self.end = Addr(kwargs.pop('end'))
-            elif 'size' in kwargs:
-                self.end = self.start + Addr(kwargs.pop('size'))
-            else:
-                raise TypeError("Either end or size must be specified")
-
-            # Now on to the optional bit
-            if 'intlvMatch' in kwargs:
-                self.intlvMatch = int(kwargs.pop('intlvMatch'))
-
-            if 'masks' in kwargs:
-                self.masks = [ long(x) for x in list(kwargs.pop('masks')) ]
-                self.intlvBits = len(self.masks)
-            else:
-                if 'intlvBits' in kwargs:
-                    self.intlvBits = int(kwargs.pop('intlvBits'))
-                    self.masks = [0] * self.intlvBits
-                    if 'intlvHighBit' not in kwargs:
-                        raise TypeError("No interleave bits specified")
-                    intlv_high_bit = int(kwargs.pop('intlvHighBit'))
-                    xor_high_bit = 0
-                    if 'xorHighBit' in kwargs:
-                        xor_high_bit = int(kwargs.pop('xorHighBit'))
-                    for i in range(0, self.intlvBits):
-                        bit1 = intlv_high_bit - i
-                        mask = 1 << bit1
-                        if xor_high_bit != 0:
-                            bit2 = xor_high_bit - i
-                            mask |= 1 << bit2
-                        self.masks[self.intlvBits - i - 1] = mask
-
-        if len(args) == 0:
-            self.start = Addr(kwargs.pop('start'))
-            handle_kwargs(self, kwargs)
-
-        elif len(args) == 1:
-            if kwargs:
-                self.start = Addr(args[0])
-                handle_kwargs(self, kwargs)
-            elif isinstance(args[0], (list, tuple)):
-                self.start = Addr(args[0][0])
-                self.end = Addr(args[0][1])
-            else:
-                self.start = Addr(0)
-                self.end = Addr(args[0])
-
-        elif len(args) == 2:
-            self.start = Addr(args[0])
-            self.end = Addr(args[1])
-        else:
-            raise TypeError("Too many arguments specified")
-
-        if kwargs:
-            raise TypeError("Too many keywords: %s" % list(kwargs.keys()))
-
-    def __str__(self):
-        if len(self.masks) == 0:
-            return '%s:%s' % (self.start, self.end)
-        else:
-            return '%s:%s:%s:%s' % (self.start, self.end, self.intlvMatch,
-                                    ':'.join(str(m) for m in self.masks))
-
-    def size(self):
-        # Divide the size by the size of the interleaving slice
-        return (long(self.end) - long(self.start)) >> self.intlvBits
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        Addr.cxx_predecls(code)
-        code('#include "base/addr_range.hh"')
-
-    @classmethod
-    def pybind_predecls(cls, code):
-        Addr.pybind_predecls(code)
-        code('#include "base/addr_range.hh"')
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-        code('#include <vector>')
-        code('#include "base/types.hh"')
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('bool _ret = true;')
-        code('uint64_t _start, _end, _intlvMatch = 0;')
-        code('std::vector<Addr> _masks;')
-        code('char _sep;')
-        code('std::istringstream _stream(${src});')
-        code('_stream >> _start;')
-        code('_stream.get(_sep);')
-        code('_ret = _sep == \':\';')
-        code('_stream >> _end;')
-        code('if (!_stream.fail() && !_stream.eof()) {')
-        code('    _stream.get(_sep);')
-        code('    _ret = ret && _sep == \':\';')
-        code('    _stream >> _intlvMatch;')
-        code('    while (!_stream.fail() && !_stream.eof()) {')
-        code('        _stream.get(_sep);')
-        code('        _ret = ret && _sep == \':\';')
-        code('        Addr mask;')
-        code('        _stream >> mask;')
-        code('        _masks.push_back(mask);')
-        code('    }')
-        code('}')
-        code('_ret = _ret && !_stream.fail() && _stream.eof();')
-        code('if (_ret)')
-        code('   ${dest} = AddrRange(_start, _end, _masks, _intlvMatch);')
-        code('${ret} _ret;')
-
-    def getValue(self):
-        # Go from the Python class to the wrapped C++ class
-        from _m5.range import AddrRange
-
-        return AddrRange(long(self.start), long(self.end),
-                         self.masks, int(self.intlvMatch))
-
-# Boolean parameter type.  Python doesn't let you subclass bool, since
-# it doesn't want to let you create multiple instances of True and
-# False.  Thus this is a little more complicated than String.
-class Bool(ParamValue):
-    cxx_type = 'bool'
-    cmd_line_settable = True
-
-    def __init__(self, value):
-        try:
-            self.value = convert.toBool(value)
-        except TypeError:
-            self.value = bool(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        return bool(self.value)
-
-    def __str__(self):
-        return str(self.value)
-
-    # implement truth value testing for Bool parameters so that these params
-    # evaluate correctly during the python configuration phase
-    def __bool__(self):
-        return bool(self.value)
-
-    # Python 2.7 uses __nonzero__ instead of __bool__
-    __nonzero__ = __bool__
-
-    def ini_str(self):
-        if self.value:
-            return 'true'
-        return 'false'
-
-    def config_value(self):
-        return self.value
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        # Assume that base/str.hh will be included anyway
-        # code('#include "base/str.hh"')
-        pass
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('%s to_bool(%s, %s);' % (ret, src, dest))
-
-def IncEthernetAddr(addr, val = 1):
-    bytes = [ int(x, 16) for x in addr.split(':') ]
-    bytes[5] += val
-    for i in (5, 4, 3, 2, 1):
-        val,rem = divmod(bytes[i], 256)
-        bytes[i] = rem
-        if val == 0:
-            break
-        bytes[i - 1] += val
-    assert(bytes[0] <= 255)
-    return ':'.join(map(lambda x: '%02x' % x, bytes))
-
-_NextEthernetAddr = "00:90:00:00:00:01"
-def NextEthernetAddr():
-    global _NextEthernetAddr
-
-    value = _NextEthernetAddr
-    _NextEthernetAddr = IncEthernetAddr(_NextEthernetAddr, 1)
-    return value
-
-class EthernetAddr(ParamValue):
-    cxx_type = 'Net::EthAddr'
-    ex_str = "00:90:00:00:00:01"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, value):
-        if value == NextEthernetAddr:
-            self.value = value
-            return
-
-        if not isinstance(value, str):
-            raise TypeError("expected an ethernet address and didn't get one")
-
-        bytes = value.split(':')
-        if len(bytes) != 6:
-            raise TypeError('invalid ethernet address %s' % value)
-
-        for byte in bytes:
-            if not 0 <= int(byte, base=16) <= 0xff:
-                raise TypeError('invalid ethernet address %s' % value)
-
-        self.value = value
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def unproxy(self, base):
-        if self.value == NextEthernetAddr:
-            return EthernetAddr(self.value())
-        return self
-
-    def getValue(self):
-        from _m5.net import EthAddr
-        return EthAddr(self.value)
-
-    def __str__(self):
-        return self.value
-
-    def ini_str(self):
-        return self.value
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s = Net::EthAddr(%s);' % (dest, src))
-        code('%s true;' % ret)
-
-# When initializing an IpAddress, pass in an existing IpAddress, a string of
-# the form "a.b.c.d", or an integer representing an IP.
-class IpAddress(ParamValue):
-    cxx_type = 'Net::IpAddress'
-    ex_str = "127.0.0.1"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, value):
-        if isinstance(value, IpAddress):
-            self.ip = value.ip
-        else:
-            try:
-                self.ip = convert.toIpAddress(value)
-            except TypeError:
-                self.ip = long(value)
-        self.verifyIp()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        tup = [(self.ip >> i)  & 0xff for i in (24, 16, 8, 0)]
-        return '%d.%d.%d.%d' % tuple(tup)
-
-    def __eq__(self, other):
-        if isinstance(other, IpAddress):
-            return self.ip == other.ip
-        elif isinstance(other, str):
-            try:
-                return self.ip == convert.toIpAddress(other)
-            except:
-                return False
-        else:
-            return self.ip == other
-
-    def __ne__(self, other):
-        return not (self == other)
-
-    def verifyIp(self):
-        if self.ip < 0 or self.ip >= (1 << 32):
-            raise TypeError("invalid ip address %#08x" % self.ip)
-
-    def getValue(self):
-        from _m5.net import IpAddress
-        return IpAddress(self.ip)
-
-# When initializing an IpNetmask, pass in an existing IpNetmask, a string of
-# the form "a.b.c.d/n" or "a.b.c.d/e.f.g.h", or an ip and netmask as
-# positional or keyword arguments.
-class IpNetmask(IpAddress):
-    cxx_type = 'Net::IpNetmask'
-    ex_str = "127.0.0.0/24"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, *args, **kwargs):
-        def handle_kwarg(self, kwargs, key, elseVal = None):
-            if key in kwargs:
-                setattr(self, key, kwargs.pop(key))
-            elif elseVal:
-                setattr(self, key, elseVal)
-            else:
-                raise TypeError("No value set for %s" % key)
-
-        if len(args) == 0:
-            handle_kwarg(self, kwargs, 'ip')
-            handle_kwarg(self, kwargs, 'netmask')
-
-        elif len(args) == 1:
-            if kwargs:
-                if not 'ip' in kwargs and not 'netmask' in kwargs:
-                    raise TypeError("Invalid arguments")
-                handle_kwarg(self, kwargs, 'ip', args[0])
-                handle_kwarg(self, kwargs, 'netmask', args[0])
-            elif isinstance(args[0], IpNetmask):
-                self.ip = args[0].ip
-                self.netmask = args[0].netmask
-            else:
-                (self.ip, self.netmask) = convert.toIpNetmask(args[0])
-
-        elif len(args) == 2:
-            self.ip = args[0]
-            self.netmask = args[1]
-        else:
-            raise TypeError("Too many arguments specified")
-
-        if kwargs:
-            raise TypeError("Too many keywords: %s" % list(kwargs.keys()))
-
-        self.verify()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        return "%s/%d" % (super(IpNetmask, self).__str__(), self.netmask)
-
-    def __eq__(self, other):
-        if isinstance(other, IpNetmask):
-            return self.ip == other.ip and self.netmask == other.netmask
-        elif isinstance(other, str):
-            try:
-                return (self.ip, self.netmask) == convert.toIpNetmask(other)
-            except:
-                return False
-        else:
-            return False
-
-    def verify(self):
-        self.verifyIp()
-        if self.netmask < 0 or self.netmask > 32:
-            raise TypeError("invalid netmask %d" % netmask)
-
-    def getValue(self):
-        from _m5.net import IpNetmask
-        return IpNetmask(self.ip, self.netmask)
-
-# When initializing an IpWithPort, pass in an existing IpWithPort, a string of
-# the form "a.b.c.d:p", or an ip and port as positional or keyword arguments.
-class IpWithPort(IpAddress):
-    cxx_type = 'Net::IpWithPort'
-    ex_str = "127.0.0.1:80"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/inet.hh"')
-
-    def __init__(self, *args, **kwargs):
-        def handle_kwarg(self, kwargs, key, elseVal = None):
-            if key in kwargs:
-                setattr(self, key, kwargs.pop(key))
-            elif elseVal:
-                setattr(self, key, elseVal)
-            else:
-                raise TypeError("No value set for %s" % key)
-
-        if len(args) == 0:
-            handle_kwarg(self, kwargs, 'ip')
-            handle_kwarg(self, kwargs, 'port')
-
-        elif len(args) == 1:
-            if kwargs:
-                if not 'ip' in kwargs and not 'port' in kwargs:
-                    raise TypeError("Invalid arguments")
-                handle_kwarg(self, kwargs, 'ip', args[0])
-                handle_kwarg(self, kwargs, 'port', args[0])
-            elif isinstance(args[0], IpWithPort):
-                self.ip = args[0].ip
-                self.port = args[0].port
-            else:
-                (self.ip, self.port) = convert.toIpWithPort(args[0])
-
-        elif len(args) == 2:
-            self.ip = args[0]
-            self.port = args[1]
-        else:
-            raise TypeError("Too many arguments specified")
-
-        if kwargs:
-            raise TypeError("Too many keywords: %s" % list(kwargs.keys()))
-
-        self.verify()
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        return "%s:%d" % (super(IpWithPort, self).__str__(), self.port)
-
-    def __eq__(self, other):
-        if isinstance(other, IpWithPort):
-            return self.ip == other.ip and self.port == other.port
-        elif isinstance(other, str):
-            try:
-                return (self.ip, self.port) == convert.toIpWithPort(other)
-            except:
-                return False
-        else:
-            return False
-
-    def verify(self):
-        self.verifyIp()
-        if self.port < 0 or self.port > 0xffff:
-            raise TypeError("invalid port %d" % self.port)
-
-    def getValue(self):
-        from _m5.net import IpWithPort
-        return IpWithPort(self.ip, self.port)
-
-time_formats = [ "%a %b %d %H:%M:%S %Z %Y",
-                 "%a %b %d %H:%M:%S %Y",
-                 "%Y/%m/%d %H:%M:%S",
-                 "%Y/%m/%d %H:%M",
-                 "%Y/%m/%d",
-                 "%m/%d/%Y %H:%M:%S",
-                 "%m/%d/%Y %H:%M",
-                 "%m/%d/%Y",
-                 "%m/%d/%y %H:%M:%S",
-                 "%m/%d/%y %H:%M",
-                 "%m/%d/%y"]
-
-
-def parse_time(value):
-    from time import gmtime, strptime, struct_time, time
-    from datetime import datetime, date
-
-    if isinstance(value, struct_time):
-        return value
-
-    if isinstance(value, (int, long)):
-        return gmtime(value)
-
-    if isinstance(value, (datetime, date)):
-        return value.timetuple()
-
-    if isinstance(value, str):
-        if value in ('Now', 'Today'):
-            return time.gmtime(time.time())
-
-        for format in time_formats:
-            try:
-                return strptime(value, format)
-            except ValueError:
-                pass
-
-    raise ValueError("Could not parse '%s' as a time" % value)
-
-class Time(ParamValue):
-    cxx_type = 'tm'
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include <time.h>')
-
-    def __init__(self, value):
-        self.value = parse_time(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        from _m5.core import tm
-        import calendar
-
-        return tm.gmtime(calendar.timegm(self.value))
-
-    def __str__(self):
-        return time.asctime(self.value)
-
-    def ini_str(self):
-        return str(self)
-
-    def get_config_as_dict(self):
-        assert false
-        return str(self)
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <time.h>')
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('char *_parse_ret = strptime((${src}).c_str(),')
-        code('    "%a %b %d %H:%M:%S %Y", &(${dest}));')
-        code('${ret} _parse_ret && *_parse_ret == \'\\0\';');
-
-# Enumerated types are a little more complex.  The user specifies the
-# type as Enum(foo) where foo is either a list or dictionary of
-# alternatives (typically strings, but not necessarily so).  (In the
-# long run, the integer value of the parameter will be the list index
-# or the corresponding dictionary value.  For now, since we only check
-# that the alternative is valid and then spit it into a .ini file,
-# there's not much point in using the dictionary.)
-
-# What Enum() must do is generate a new type encapsulating the
-# provided list/dictionary so that specific values of the parameter
-# can be instances of that type.  We define two hidden internal
-# classes (_ListEnum and _DictEnum) to serve as base classes, then
-# derive the new type from the appropriate base class on the fly.
-
-allEnums = {}
-# Metaclass for Enum types
-class MetaEnum(MetaParamValue):
-    def __new__(mcls, name, bases, dict):
-
-        cls = super(MetaEnum, mcls).__new__(mcls, name, bases, dict)
-        allEnums[name] = cls
-        return cls
-
-    def __init__(cls, name, bases, init_dict):
-        if 'map' in init_dict:
-            if not isinstance(cls.map, dict):
-                raise TypeError("Enum-derived class attribute 'map' " \
-                      "must be of type dict")
-            # build list of value strings from map
-            cls.vals = list(cls.map.keys())
-            cls.vals.sort()
-        elif 'vals' in init_dict:
-            if not isinstance(cls.vals, list):
-                raise TypeError("Enum-derived class attribute 'vals' " \
-                      "must be of type list")
-            # build string->value map from vals sequence
-            cls.map = {}
-            for idx,val in enumerate(cls.vals):
-                cls.map[val] = idx
-        else:
-            raise TypeError("Enum-derived class must define "\
-                  "attribute 'map' or 'vals'")
-
-        if cls.is_class:
-            cls.cxx_type = '%s' % name
-        else:
-            cls.cxx_type = 'Enums::%s' % name
-
-        super(MetaEnum, cls).__init__(name, bases, init_dict)
-
-    # Generate C++ class declaration for this enum type.
-    # Note that we wrap the enum in a class/struct to act as a namespace,
-    # so that the enum strings can be brief w/o worrying about collisions.
-    def cxx_decl(cls, code):
-        wrapper_name = cls.wrapper_name
-        wrapper = 'struct' if cls.wrapper_is_struct else 'namespace'
-        name = cls.__name__ if cls.enum_name is None else cls.enum_name
-        idem_macro = '__ENUM__%s__%s__' % (wrapper_name, name)
-
-        code('''\
-#ifndef $idem_macro
-#define $idem_macro
-
-''')
-        if cls.is_class:
-            code('''\
-enum class $name {
-''')
-        else:
-            code('''\
-$wrapper $wrapper_name {
-    enum $name {
-''')
-            code.indent(1)
-        code.indent(1)
-        for val in cls.vals:
-            code('$val = ${{cls.map[val]}},')
-        code('Num_$name = ${{len(cls.vals)}}')
-        code.dedent(1)
-        code('};')
-
-        if cls.is_class:
-            code('''\
-extern const char *${name}Strings[static_cast<int>(${name}::Num_${name})];
-''')
-        elif cls.wrapper_is_struct:
-            code('static const char *${name}Strings[Num_${name}];')
-        else:
-            code('extern const char *${name}Strings[Num_${name}];')
-
-        if not cls.is_class:
-            code.dedent(1)
-            code('};')
-
-        code()
-        code('#endif // $idem_macro')
-
-    def cxx_def(cls, code):
-        wrapper_name = cls.wrapper_name
-        file_name = cls.__name__
-        name = cls.__name__ if cls.enum_name is None else cls.enum_name
-
-        code('#include "enums/$file_name.hh"')
-        if cls.wrapper_is_struct:
-            code('const char *${wrapper_name}::${name}Strings'
-                '[Num_${name}] =')
-        else:
-            if cls.is_class:
-                code('''\
-const char *${name}Strings[static_cast<int>(${name}::Num_${name})] =
-''')
-            else:
-                code('namespace Enums {')
-                code.indent(1)
-                code('const char *${name}Strings[Num_${name}] =')
-
-        code('{')
-        code.indent(1)
-        for val in cls.vals:
-            code('"$val",')
-        code.dedent(1)
-        code('};')
-
-        if not cls.wrapper_is_struct and not cls.is_class:
-            code.dedent(1)
-            code('} // namespace $wrapper_name')
-
-
-    def pybind_def(cls, code):
-        name = cls.__name__
-        enum_name = cls.__name__ if cls.enum_name is None else cls.enum_name
-        wrapper_name = enum_name if cls.is_class else cls.wrapper_name
-
-        code('''#include "pybind11/pybind11.h"
-#include "pybind11/stl.h"
-
-#include <sim/init.hh>
-
-namespace py = pybind11;
-
-static void
-module_init(py::module &m_internal)
-{
-    py::module m = m_internal.def_submodule("enum_${name}");
-
-''')
-        if cls.is_class:
-            code('py::enum_<${enum_name}>(m, "enum_${name}")')
-        else:
-            code('py::enum_<${wrapper_name}::${enum_name}>(m, "enum_${name}")')
-
-        code.indent()
-        code.indent()
-        for val in cls.vals:
-            code('.value("${val}", ${wrapper_name}::${val})')
-        code('.value("Num_${name}", ${wrapper_name}::Num_${enum_name})')
-        if not cls.is_class:
-            code('.export_values()')
-        code(';')
-        code.dedent()
-
-        code('}')
-        code.dedent()
-        code()
-        code('static EmbeddedPyBind embed_enum("enum_${name}", module_init);')
-
-
-# Base class for enum types.
-class Enum(with_metaclass(MetaEnum, ParamValue)):
-    vals = []
-    cmd_line_settable = True
-
-    # The name of the wrapping namespace or struct
-    wrapper_name = 'Enums'
-
-    # If true, the enum is wrapped in a struct rather than a namespace
-    wrapper_is_struct = False
-
-    is_class = False
-
-    # If not None, use this as the enum name rather than this class name
-    enum_name = None
-
-    def __init__(self, value):
-        if value not in self.map:
-            raise TypeError("Enum param got bad value '%s' (not in %s)" \
-                  % (value, self.vals))
-        self.value = value
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "enums/$0.hh"', cls.__name__)
-
-    @classmethod
-    def cxx_ini_parse(cls, code, src, dest, ret):
-        code('if (false) {')
-        for elem_name in cls.map.keys():
-            code('} else if (%s == "%s") {' % (src, elem_name))
-            code.indent()
-            name = cls.__name__ if cls.enum_name is None else cls.enum_name
-            code('%s = %s::%s;' % (dest, name if cls.is_class else 'Enums',
-                                   elem_name))
-            code('%s true;' % ret)
-            code.dedent()
-        code('} else {')
-        code('    %s false;' % ret)
-        code('}')
-
-    def getValue(self):
-        import m5.internal.params
-        e = getattr(m5.internal.params, "enum_%s" % self.__class__.__name__)
-        return e(self.map[self.value])
-
-    def __str__(self):
-        return self.value
-
-# This param will generate a scoped c++ enum and its python bindings.
-class ScopedEnum(Enum):
-    vals = []
-    cmd_line_settable = True
-
-    # The name of the wrapping namespace or struct
-    wrapper_name = None
-
-    # If true, the enum is wrapped in a struct rather than a namespace
-    wrapper_is_struct = False
-
-    # If true, the generated enum is a scoped enum
-    is_class = True
-
-    # If not None, use this as the enum name rather than this class name
-    enum_name = None
-
-class ByteOrder(ScopedEnum):
-    """Enum representing component's byte order (endianness)"""
-
-    vals = [
-        'big',
-        'little',
-    ]
-
-# how big does a rounding error need to be before we warn about it?
-frequency_tolerance = 0.001  # 0.1%
-
-class TickParamValue(NumericParamValue):
-    cxx_type = 'Tick'
-    ex_str = "1MHz"
-    cmd_line_settable = True
-
-    @classmethod
-    def cxx_predecls(cls, code):
-        code('#include "base/types.hh"')
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def getValue(self):
-        return long(self.value)
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    # Ticks are expressed in seconds in JSON files and in plain
-    # Ticks in .ini files.  Switch based on a config flag
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('${ret} to_number(${src}, ${dest});')
-
-class Latency(TickParamValue):
-    ex_str = "100ns"
-
-    def __init__(self, value):
-        if isinstance(value, (Latency, Clock)):
-            self.ticks = value.ticks
-            self.value = value.value
-        elif isinstance(value, Frequency):
-            self.ticks = value.ticks
-            self.value = 1.0 / value.value
-        elif value.endswith('t'):
-            self.ticks = True
-            self.value = int(value[:-1])
-        else:
-            self.ticks = False
-            self.value = convert.toLatency(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __getattr__(self, attr):
-        if attr in ('latency', 'period'):
-            return self
-        if attr == 'frequency':
-            return Frequency(self)
-        raise AttributeError("Latency object has no attribute '%s'" % attr)
-
-    def getValue(self):
-        if self.ticks or self.value == 0:
-            value = self.value
-        else:
-            value = ticks.fromSeconds(self.value)
-        return long(value)
-
-    def config_value(self):
-        return self.getValue()
-
-    # convert latency to ticks
-    def ini_str(self):
-        return '%d' % self.getValue()
-
-class Frequency(TickParamValue):
-    ex_str = "1GHz"
-
-    def __init__(self, value):
-        if isinstance(value, (Latency, Clock)):
-            if value.value == 0:
-                self.value = 0
-            else:
-                self.value = 1.0 / value.value
-            self.ticks = value.ticks
-        elif isinstance(value, Frequency):
-            self.value = value.value
-            self.ticks = value.ticks
-        else:
-            self.ticks = False
-            self.value = convert.toFrequency(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __getattr__(self, attr):
-        if attr == 'frequency':
-            return self
-        if attr in ('latency', 'period'):
-            return Latency(self)
-        raise AttributeError("Frequency object has no attribute '%s'" % attr)
-
-    # convert latency to ticks
-    def getValue(self):
-        if self.ticks or self.value == 0:
-            value = self.value
-        else:
-            value = ticks.fromSeconds(1.0 / self.value)
-        return long(value)
-
-    def config_value(self):
-        return self.getValue()
-
-    def ini_str(self):
-        return '%d' % self.getValue()
-
-# A generic Frequency and/or Latency value. Value is stored as a
-# latency, just like Latency and Frequency.
-class Clock(TickParamValue):
-    def __init__(self, value):
-        if isinstance(value, (Latency, Clock)):
-            self.ticks = value.ticks
-            self.value = value.value
-        elif isinstance(value, Frequency):
-            self.ticks = value.ticks
-            self.value = 1.0 / value.value
-        elif value.endswith('t'):
-            self.ticks = True
-            self.value = int(value[:-1])
-        else:
-            self.ticks = False
-            self.value = convert.anyToLatency(value)
-
-    def __call__(self, value):
-        self.__init__(value)
-        return value
-
-    def __str__(self):
-        return "%s" % Latency(self)
-
-    def __getattr__(self, attr):
-        if attr == 'frequency':
-            return Frequency(self)
-        if attr in ('latency', 'period'):
-            return Latency(self)
-        raise AttributeError("Frequency object has no attribute '%s'" % attr)
-
-    def getValue(self):
-        return self.period.getValue()
-
-    def config_value(self):
-        return self.period.config_value()
-
-    def ini_str(self):
-        return self.period.ini_str()
-
-class Voltage(Float):
-    ex_str = "1V"
-
-    def __new__(cls, value):
-        value = convert.toVoltage(value)
-        return super(cls, Voltage).__new__(cls, value)
-
-    def __init__(self, value):
-        value = convert.toVoltage(value)
-        super(Voltage, self).__init__(value)
-
-class Current(Float):
-    ex_str = "1mA"
-
-    def __new__(cls, value):
-        value = convert.toCurrent(value)
-        return super(cls, Current).__new__(cls, value)
-
-    def __init__(self, value):
-        value = convert.toCurrent(value)
-        super(Current, self).__init__(value)
-
-class Energy(Float):
-    ex_str = "1pJ"
-
-    def __new__(cls, value):
-        value = convert.toEnergy(value)
-        return super(cls, Energy).__new__(cls, value)
-
-    def __init__(self, value):
-        value = convert.toEnergy(value)
-        super(Energy, self).__init__(value)
-
-class NetworkBandwidth(float,ParamValue):
-    cxx_type = 'float'
-    ex_str = "1Gbps"
-    cmd_line_settable = True
-
-    def __new__(cls, value):
-        # convert to bits per second
-        val = convert.toNetworkBandwidth(value)
-        return super(cls, NetworkBandwidth).__new__(cls, val)
-
-    def __str__(self):
-        return str(self.val)
-
-    def __call__(self, value):
-        val = convert.toNetworkBandwidth(value)
-        self.__init__(val)
-        return value
-
-    def getValue(self):
-        # convert to seconds per byte
-        value = 8.0 / float(self)
-        # convert to ticks per byte
-        value = ticks.fromSeconds(value)
-        return float(value)
-
-    def ini_str(self):
-        return '%f' % self.getValue()
-
-    def config_value(self):
-        return '%f' % self.getValue()
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s (std::istringstream(%s) >> %s).eof();' % (ret, src, dest))
-
-class MemoryBandwidth(float,ParamValue):
-    cxx_type = 'float'
-    ex_str = "1GB/s"
-    cmd_line_settable = True
-
-    def __new__(cls, value):
-        # convert to bytes per second
-        val = convert.toMemoryBandwidth(value)
-        return super(cls, MemoryBandwidth).__new__(cls, val)
-
-    def __call__(self, value):
-        val = convert.toMemoryBandwidth(value)
-        self.__init__(val)
-        return value
-
-    def getValue(self):
-        # convert to seconds per byte
-        value = float(self)
-        if value:
-            value = 1.0 / float(self)
-        # convert to ticks per byte
-        value = ticks.fromSeconds(value)
-        return float(value)
-
-    def ini_str(self):
-        return '%f' % self.getValue()
-
-    def config_value(self):
-        return '%f' % self.getValue()
-
-    @classmethod
-    def cxx_ini_predecls(cls, code):
-        code('#include <sstream>')
-
-    @classmethod
-    def cxx_ini_parse(self, code, src, dest, ret):
-        code('%s (std::istringstream(%s) >> %s).eof();' % (ret, src, dest))
-
-#
-# "Constants"... handy aliases for various values.
-#
-
-# Special class for NULL pointers.  Note the special check in
-# make_param_value() above that lets these be assigned where a
-# SimObject is required.
-# only one copy of a particular node
-class NullSimObject(with_metaclass(Singleton, object)):
-    _name = 'Null'
-
-    def __call__(cls):
-        return cls
-
-    def _instantiate(self, parent = None, path = ''):
-        pass
-
-    def ini_str(self):
-        return 'Null'
-
-    def unproxy(self, base):
-        return self
-
-    def set_path(self, parent, name):
-        pass
-
-    def set_parent(self, parent, name):
-        pass
-
-    def clear_parent(self, old_parent):
-        pass
-
-    def descendants(self):
-        return
-        yield None
-
-    def get_config_as_dict(self):
-        return {}
-
-    def __str__(self):
-        return self._name
-
-    def config_value(self):
-        return None
-
-    def getValue(self):
-        return None
-
-# The only instance you'll ever need...
-NULL = NullSimObject()
-
-def isNullPointer(value):
-    return isinstance(value, NullSimObject)
-
-# Some memory range specifications use this as a default upper bound.
-MaxAddr = Addr.max
-MaxTick = Tick.max
-AllMemory = AddrRange(0, MaxAddr)
-
-
-#####################################################################
-#
-# Port objects
-#
-# Ports are used to interconnect objects in the memory system.
-#
-#####################################################################
-
-# Port reference: encapsulates a reference to a particular port on a
-# particular SimObject.
-class PortRef(object):
-    def __init__(self, simobj, name, role, is_source):
-        assert(isSimObject(simobj) or isSimObjectClass(simobj))
-        self.simobj = simobj
-        self.name = name
-        self.role = role
-        self.is_source = is_source
-        self.peer = None   # not associated with another port yet
-        self.ccConnected = False # C++ port connection done?
-        self.index = -1  # always -1 for non-vector ports
-
-    def __str__(self):
-        return '%s.%s' % (self.simobj, self.name)
-
-    def __len__(self):
-        # Return the number of connected ports, i.e. 0 is we have no
-        # peer and 1 if we do.
-        return int(self.peer != None)
-
-    # for config.ini, print peer's name (not ours)
-    def ini_str(self):
-        return str(self.peer)
-
-    # for config.json
-    def get_config_as_dict(self):
-        return {'role' : self.role, 'peer' : str(self.peer),
-                'is_source' : str(self.is_source)}
-
-    def __getattr__(self, attr):
-        if attr == 'peerObj':
-            # shorthand for proxies
-            return self.peer.simobj
-        raise AttributeError("'%s' object has no attribute '%s'" % \
-              (self.__class__.__name__, attr))
-
-    # Full connection is symmetric (both ways).  Called via
-    # SimObject.__setattr__ as a result of a port assignment, e.g.,
-    # "obj1.portA = obj2.portB", or via VectorPortElementRef.__setitem__,
-    # e.g., "obj1.portA[3] = obj2.portB".
-    def connect(self, other):
-        if isinstance(other, VectorPortRef):
-            # reference to plain VectorPort is implicit append
-            other = other._get_next()
-        if self.peer and not proxy.isproxy(self.peer):
-            fatal("Port %s is already connected to %s, cannot connect %s\n",
-                  self, self.peer, other);
-        self.peer = other
-
-        if proxy.isproxy(other):
-            other.set_param_desc(PortParamDesc())
-            return
-        elif not isinstance(other, PortRef):
-            raise TypeError("assigning non-port reference '%s' to port '%s'" \
-                  % (other, self))
-
-        if not Port.is_compat(self, other):
-            fatal("Ports %s and %s with roles '%s' and '%s' "
-                    "are not compatible", self, other, self.role, other.role)
-
-        if other.peer is not self:
-            other.connect(self)
-
-    # Allow a compatible port pair to be spliced between a port and its
-    # connected peer. Useful operation for connecting instrumentation
-    # structures into a system when it is necessary to connect the
-    # instrumentation after the full system has been constructed.
-    def splice(self, new_1, new_2):
-        if not self.peer or proxy.isproxy(self.peer):
-            fatal("Port %s not connected, cannot splice in new peers\n", self)
-
-        if not isinstance(new_1, PortRef) or not isinstance(new_2, PortRef):
-            raise TypeError(
-                  "Splicing non-port references '%s','%s' to port '%s'" % \
-                  (new_1, new_2, self))
-
-        old_peer = self.peer
-
-        if Port.is_compat(old_peer, new_1) and Port.is_compat(self, new_2):
-            old_peer.peer = new_1
-            new_1.peer = old_peer
-            self.peer = new_2
-            new_2.peer = self
-        elif Port.is_compat(old_peer, new_2) and Port.is_compat(self, new_1):
-            old_peer.peer = new_2
-            new_2.peer = old_peer
-            self.peer = new_1
-            new_1.peer = self
-        else:
-            fatal("Ports %s(%s) and %s(%s) can't be compatibly spliced with "
-                    "%s(%s) and %s(%s)", self, self.role,
-                    old_peer, old_peer.role, new_1, new_1.role,
-                    new_2, new_2.role)
-
-    def clone(self, simobj, memo):
-        if self in memo:
-            return memo[self]
-        newRef = copy.copy(self)
-        memo[self] = newRef
-        newRef.simobj = simobj
-        assert(isSimObject(newRef.simobj))
-        if self.peer and not proxy.isproxy(self.peer):
-            peerObj = self.peer.simobj(_memo=memo)
-            newRef.peer = self.peer.clone(peerObj, memo)
-            assert(not isinstance(newRef.peer, VectorPortRef))
-        return newRef
-
-    def unproxy(self, simobj):
-        assert(simobj is self.simobj)
-        if proxy.isproxy(self.peer):
-            try:
-                realPeer = self.peer.unproxy(self.simobj)
-            except:
-                print("Error in unproxying port '%s' of %s" %
-                      (self.name, self.simobj.path()))
-                raise
-            self.connect(realPeer)
-
-    # Call C++ to create corresponding port connection between C++ objects
-    def ccConnect(self):
-        if self.ccConnected: # already done this
-            return
-
-        peer = self.peer
-        if not self.peer: # nothing to connect to
-            return
-
-        port = self.simobj.getPort(self.name, self.index)
-        peer_port = peer.simobj.getPort(peer.name, peer.index)
-        port.bind(peer_port)
-
-        self.ccConnected = True
-
-# A reference to an individual element of a VectorPort... much like a
-# PortRef, but has an index.
-class VectorPortElementRef(PortRef):
-    def __init__(self, simobj, name, role, is_source, index):
-        PortRef.__init__(self, simobj, name, role, is_source)
-        self.index = index
-
-    def __str__(self):
-        return '%s.%s[%d]' % (self.simobj, self.name, self.index)
-
-# A reference to a complete vector-valued port (not just a single element).
-# Can be indexed to retrieve individual VectorPortElementRef instances.
-class VectorPortRef(object):
-    def __init__(self, simobj, name, role, is_source):
-        assert(isSimObject(simobj) or isSimObjectClass(simobj))
-        self.simobj = simobj
-        self.name = name
-        self.role = role
-        self.is_source = is_source
-        self.elements = []
-
-    def __str__(self):
-        return '%s.%s[:]' % (self.simobj, self.name)
-
-    def __len__(self):
-        # Return the number of connected peers, corresponding the the
-        # length of the elements.
-        return len(self.elements)
-
-    # for config.ini, print peer's name (not ours)
-    def ini_str(self):
-        return ' '.join([el.ini_str() for el in self.elements])
-
-    # for config.json
-    def get_config_as_dict(self):
-        return {'role' : self.role,
-                'peer' : [el.ini_str() for el in self.elements],
-                'is_source' : str(self.is_source)}
-
-    def __getitem__(self, key):
-        if not isinstance(key, int):
-            raise TypeError("VectorPort index must be integer")
-        if key >= len(self.elements):
-            # need to extend list
-            ext = [VectorPortElementRef(
-                    self.simobj, self.name, self.role, self.is_source, i)
-                   for i in range(len(self.elements), key+1)]
-            self.elements.extend(ext)
-        return self.elements[key]
-
-    def _get_next(self):
-        return self[len(self.elements)]
-
-    def __setitem__(self, key, value):
-        if not isinstance(key, int):
-            raise TypeError("VectorPort index must be integer")
-        self[key].connect(value)
-
-    def connect(self, other):
-        if isinstance(other, (list, tuple)):
-            # Assign list of port refs to vector port.
-            # For now, append them... not sure if that's the right semantics
-            # or if it should replace the current vector.
-            for ref in other:
-                self._get_next().connect(ref)
-        else:
-            # scalar assignment to plain VectorPort is implicit append
-            self._get_next().connect(other)
-
-    def clone(self, simobj, memo):
-        if self in memo:
-            return memo[self]
-        newRef = copy.copy(self)
-        memo[self] = newRef
-        newRef.simobj = simobj
-        assert(isSimObject(newRef.simobj))
-        newRef.elements = [el.clone(simobj, memo) for el in self.elements]
-        return newRef
-
-    def unproxy(self, simobj):
-        [el.unproxy(simobj) for el in self.elements]
-
-    def ccConnect(self):
-        [el.ccConnect() for el in self.elements]
-
-# Port description object.  Like a ParamDesc object, this represents a
-# logical port in the SimObject class, not a particular port on a
-# SimObject instance.  The latter are represented by PortRef objects.
-class Port(object):
-    # Port("role", "description")
-
-    _compat_dict = { }
-
-    @classmethod
-    def compat(cls, role, peer):
-        cls._compat_dict.setdefault(role, set()).add(peer)
-        cls._compat_dict.setdefault(peer, set()).add(role)
-
-    @classmethod
-    def is_compat(cls, one, two):
-        for port in one, two:
-            if not port.role in Port._compat_dict:
-                fatal("Unrecognized role '%s' for port %s\n", port.role, port)
-        return one.role in Port._compat_dict[two.role]
-
-    def __init__(self, role, desc, is_source=False):
-        self.desc = desc
-        self.role = role
-        self.is_source = is_source
-
-    # Generate a PortRef for this port on the given SimObject with the
-    # given name
-    def makeRef(self, simobj):
-        return PortRef(simobj, self.name, self.role, self.is_source)
-
-    # Connect an instance of this port (on the given SimObject with
-    # the given name) with the port described by the supplied PortRef
-    def connect(self, simobj, ref):
-        self.makeRef(simobj).connect(ref)
-
-    # No need for any pre-declarations at the moment as we merely rely
-    # on an unsigned int.
-    def cxx_predecls(self, code):
-        pass
-
-    def pybind_predecls(self, code):
-        cls.cxx_predecls(self, code)
-
-    # Declare an unsigned int with the same name as the port, that
-    # will eventually hold the number of connected ports (and thus the
-    # number of elements for a VectorPort).
-    def cxx_decl(self, code):
-        code('unsigned int port_${{self.name}}_connection_count;')
-
-Port.compat('GEM5 REQUESTOR', 'GEM5 RESPONDER')
-
-class RequestPort(Port):
-    # RequestPort("description")
-    def __init__(self, desc):
-        super(RequestPort, self).__init__(
-                'GEM5 REQUESTOR', desc, is_source=True)
-
-class ResponsePort(Port):
-    # ResponsePort("description")
-    def __init__(self, desc):
-        super(ResponsePort, self).__init__('GEM5 RESPONDER', desc)
-
-# VectorPort description object.  Like Port, but represents a vector
-# of connections (e.g., as on a XBar).
-class VectorPort(Port):
-    def makeRef(self, simobj):
-        return VectorPortRef(simobj, self.name, self.role, self.is_source)
-
-class VectorRequestPort(VectorPort):
-    # VectorRequestPort("description")
-    def __init__(self, desc):
-        super(VectorRequestPort, self).__init__(
-                'GEM5 REQUESTOR', desc, is_source=True)
-
-class VectorResponsePort(VectorPort):
-    # VectorResponsePort("description")
-    def __init__(self, desc):
-        super(VectorResponsePort, self).__init__('GEM5 RESPONDER', desc)
-
-# Old names, maintained for compatibility.
-MasterPort = RequestPort
-SlavePort = ResponsePort
-VectorMasterPort = VectorRequestPort
-VectorSlavePort = VectorResponsePort
-
-# 'Fake' ParamDesc for Port references to assign to the _pdesc slot of
-# proxy objects (via set_param_desc()) so that proxy error messages
-# make sense.
-class PortParamDesc(with_metaclass(Singleton, object)):
-    ptype_str = 'Port'
-    ptype = Port
-
-class DeprecatedParam(object):
-    """A special type for deprecated parameter variable names.
-
-    There are times when we need to change the name of parameter, but this
-    breaks the external-facing python API used in configuration files. Using
-    this "type" for a parameter will warn users that they are using the old
-    name, but allow for backwards compatibility.
-
-    Usage example:
-    In the following example, the `time` parameter is changed to `delay`.
-
-    ```
-    class SomeDevice(SimObject):
-        delay = Param.Latency('1ns', 'The time to wait before something')
-        time = DeprecatedParam(delay, '`time` is now called `delay`')
-    ```
-    """
-
-    def __init__(self, new_param, message=''):
-        """new_param: the new parameter variable that users should be using
-        instead of this parameter variable.
-        message: an optional message to print when warning the user
-        """
-        self.message = message
-        self.newParam = new_param
-        # Note: We won't know the string variable names until later in the
-        # SimObject initialization process. Note: we expect that the setters
-        # will be called when the SimObject type (class) is initialized so
-        # these variables should be filled in before the instance of the
-        # SimObject with this parameter is constructed
-        self._oldName = ''
-        self._newName = ''
-
-    @property
-    def oldName(self):
-        assert(self._oldName != '') # should already be set
-        return self._oldName
-
-    @oldName.setter
-    def oldName(self, name):
-        assert(self._oldName == '') # Cannot "re-set" this value
-        self._oldName = name
-
-    @property
-    def newName(self):
-        assert(self._newName != '') # should already be set
-        return self._newName
-
-    @newName.setter
-    def newName(self, name):
-        assert(self._newName == '') # Cannot "re-set" this value
-        self._newName = name
-
-    def printWarning(self, instance_name, simobj_name):
-        """Issue a warning that this variable name should not be used.
-
-        instance_name: str, the name of the instance used in python
-        simobj_name: str, the name of the SimObject type
-        """
-        if not self.message:
-            self.message = "See {} for more information".format(simobj_name)
-        warn('{}.{} is deprecated. {}'.format(
-            instance_name, self._oldName, self.message))
-
-baseEnums = allEnums.copy()
-baseParams = allParams.copy()
-
-def clear():
-    global allEnums, allParams
-
-    allEnums = baseEnums.copy()
-    allParams = baseParams.copy()
-
-__all__ = ['Param', 'VectorParam',
-           'Enum', 'ScopedEnum', 'Bool', 'String', 'Float',
-           'Int', 'Unsigned', 'Int8', 'UInt8', 'Int16', 'UInt16',
-           'Int32', 'UInt32', 'Int64', 'UInt64',
-           'Counter', 'Addr', 'Tick', 'Percent',
-           'TcpPort', 'UdpPort', 'EthernetAddr',
-           'IpAddress', 'IpNetmask', 'IpWithPort',
-           'MemorySize', 'MemorySize32',
-           'Latency', 'Frequency', 'Clock', 'Voltage', 'Current', 'Energy',
-           'NetworkBandwidth', 'MemoryBandwidth',
-           'AddrRange',
-           'MaxAddr', 'MaxTick', 'AllMemory',
-           'Time',
-           'NextEthernetAddr', 'NULL',
-           'Port', 'RequestPort', 'ResponsePort', 'MasterPort', 'SlavePort',
-           'VectorPort', 'VectorRequestPort', 'VectorResponsePort',
-           'VectorMasterPort', 'VectorSlavePort',
-           'DeprecatedParam',
-           ]
diff --git a/test.cpp b/test.cpp
deleted file mode 100644
index c926713af..000000000
--- a/test.cpp
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <iostream>
-#include <algorithm>
-#define TEST_NUM 50
-using namespace std;
-
-
-int main(){
-	size_t array[TEST_NUM];
-
-	for(int i=0;i<TEST_NUM;i++)
-		array[i]=TEST_NUM-i;
-
-	cout<<"=============\n";
-	cout<<"BEFORE   SORT\n";
-	cout<<"=============\n";
-	for(int i=0;i<TEST_NUM;i++)
-		cout<<array[i]<<", " ;
-	cout<<endl;
-
-	for(int i=0;i<TEST_NUM;i++)
-		std::sort(array, array+ TEST_NUM ) ;
-	
-
-	cout<<"=============\n";
-	cout<<"AFTER    SORT\n";
-	cout<<"=============\n";
-	for(int i=0;i<TEST_NUM;i++)
-		cout<<array[i]<<", " ;
-	cout<<endl;
-
-
-}
